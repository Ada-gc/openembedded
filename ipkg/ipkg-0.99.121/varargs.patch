--- C.old/sprintf_alloc.c	2004-01-13 15:51:48.000000000 -0700
+++ C/sprintf_alloc.c	2004-05-20 16:47:25.240772176 -0700
@@ -20,12 +20,12 @@
 
 #include "sprintf_alloc.h"
 
-static int vsprintf_alloc(char **str, const char *fmt, va_list ap);
-
 int sprintf_alloc(char **str, const char *fmt, ...)
 {
     int ret;
     va_list ap;
+    char *new_str;
+    int n, size = 100;
 
     if (!str) {
       fprintf(stderr, "Null string pointer passed to sprintf_alloc\n");
@@ -35,29 +35,27 @@
       fprintf(stderr, "Null fmt string passed to sprintf_alloc\n");
       return -1;
     }
-    va_start(ap, fmt);
-    ret = vsprintf_alloc(str, fmt, ap);
-    va_end(ap);
 
-    return ret;
-}
+    /* On x86_64 systems, any strings over 100 were segfaulting.  
+       It seems that the ap needs to be reinitalized before every
+       use of the v*printf() functions. I pulled the functionality out
+       of vsprintf_alloc and combined it all here instead. 
+    */
+    
+
+    /* ripped more or less straight out of PRINTF(3) */
+
+    if ((new_str = malloc(size)) == NULL) 
+      return -1;
 
-/* ripped more or less straight out of PRINTF(3) */
-static int vsprintf_alloc(char **str, const char *fmt, va_list ap)
-{
-    char *new_str;
-    /* Guess we need no more than 100 bytes. */
-    int n, size = 100;
- 
-    if ((new_str = malloc (size)) == NULL)
-	return -1;
     *str = new_str;
-    while (1) {
-	/* Try to print in the allocated space. */
-	n = vsnprintf (new_str, size, fmt, ap);
-	/* If that worked, return the size. */
-	if (n > -1 && n < size)
-	    return n;
+    while(1) {
+      va_start(ap, fmt);
+      n = vsnprintf (new_str, size, fmt, ap);
+      va_end(ap);
+      /* If that worked, return the size. */
+      if (n > -1 && n < size)
+	return n;
 	/* Else try again with more space. */
 	if (n > -1)    /* glibc 2.1 */
 	    size = n+1; /* precisely what is needed */
@@ -71,4 +69,6 @@
 	}
 	*str = new_str;
     }
+
+    return -1; /* Just to be correct - it probably won't get here */
 }
