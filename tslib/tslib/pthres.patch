
#
# Patch managed by http://www.mn-logistik.de/unsupported/pxa250/patcher
#

--- tslib/configure.in~tslib-pthres
+++ tslib/configure.in
@@ -10,6 +10,8 @@
   [ "x$enableval" = "xyes" ] && PLUGINS="$PLUGINS dejitter.la", PLUGINS="$PLUGINS dejitter.la")
 AC_ARG_ENABLE(variance, [  --enable-variance       Enable building of variance filter [default=yes]],
   [ "x$enableval" = "xyes" ] && PLUGINS="$PLUGINS variance.la", PLUGINS="$PLUGINS variance.la")
+AC_ARG_ENABLE(pthres, [  --enable-pthres       Enable building of pthres filter [default=yes]],
+  [ "x$enableval" = "xyes" ] && PLUGINS="$PLUGINS pthres.la", PLUGINS="$PLUGINS pthres.la")
 
 AC_MSG_CHECKING(--enable-debug argument)
 AC_ARG_ENABLE(debug,    [  --enable-debug          Enable debug messages from filters [default=no]], 
--- tslib/plugins/Makefile.am~tslib-pthres
+++ tslib/plugins/Makefile.am
@@ -19,7 +19,7 @@
 LIBS			=
 plugindir		= $(PLUGIN_DIR)
 
-EXTRA_LTLIBRARIES	= variance.la dejitter.la linear.la
+EXTRA_LTLIBRARIES	= variance.la dejitter.la linear.la pthres.la
 plugin_LTLIBRARIES	= $(PLUGINS)
 
 variance_la_SOURCES	= variance.c
@@ -30,3 +30,6 @@
 
 linear_la_SOURCES	= linear.c
 linear_la_LDFLAGS	= -module $(LTVSN)
+
+pthres_la_SOURCES	= pthres.c
+pthres_la_LDFLAGS	= -module $(LTVSN)
--- /dev/null
+++ tslib/plugins/pthres.c
@@ -0,0 +1,157 @@
+/*
+ *  tslib/plugins/pthres.c
+ *
+ *  Copyright (C) 2003 Texas Instruments, Inc.
+ *
+ *  Based on:
+ *    tslib/plugins/linear.c
+ *    Copyright (C) 2001 Russell King.
+ *
+ * This file is placed under the LGPL.  Please see the file
+ * COPYING for more details.
+ *
+ * Ensure a release is always pressure 0, and that a press is always >=1.
+ */
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <errno.h>
+#include <limits.h>
+
+#include "tslib.h"
+#include "tslib-filter.h"
+
+struct tslib_pthres {
+	struct tslib_module_info module;
+	int	pmin;
+	int	pmax;
+};
+
+static int
+pthres_read(struct tslib_module_info *info, struct ts_sample *samp, int nr)
+{
+	struct tslib_pthres *p = (struct tslib_pthres *)info;
+	int ret;
+	static int xsave = 0, ysave = 0;
+	static int press = 0;
+
+	ret = info->next->ops->read(info->next, samp, nr);
+	if (ret >= 0) {
+		int nr = 0, i;
+		struct ts_sample *s;
+
+		for (s = samp, i = 0; i < ret; i++, s++) {
+			if (s->pressure < p->pmin) {
+				if (press != 0) {
+					/* release */
+					press = 0;
+					s->pressure = 0;
+					s->x = xsave;
+					s->y = ysave;
+				} else {
+					/* release with no press, outside bounds, dropping */
+					int left = ret - nr - 1;
+					if (left > 0) {
+						memmove(s, s + 1, left * sizeof(struct ts_sample));
+						s--;
+						continue;
+					}
+					break;
+				}
+			} else {
+				if (s->pressure > p->pmax) {
+					/* pressure outside bounds, dropping */
+					int left = ret - nr - 1;
+					if (left > 0) {
+						memmove(s, s + 1, left * sizeof(struct ts_sample));
+						s--;
+						continue;
+					}
+					break;
+				}
+				/* press */
+				press = 1;
+				xsave = s->x;
+				ysave = s->y;
+			}
+			nr++;
+		}
+		return nr;
+	}
+	return ret;
+}
+
+static int pthres_fini(struct tslib_module_info *info)
+{
+	free(info);
+	return 0;
+}
+
+static const struct tslib_ops pthres_ops =
+{
+	read:		pthres_read,
+	fini:		pthres_fini,
+};
+
+static int threshold_vars(struct tslib_module_info *inf, char *str, void *data)
+{
+	struct tslib_pthres *p = (struct tslib_pthres *)inf;
+	unsigned long v;
+	int err = errno;
+
+	v = strtoul(str, NULL, 0);
+
+	if (v == ULONG_MAX && errno == ERANGE)
+		return -1;
+
+	errno = err;
+	switch ((int)data) {
+	case 0:
+		p->pmin = v;
+		break;
+
+	case 1:
+		p->pmax = v;
+		break;
+
+	default:
+		return -1;
+	}
+	return 0;
+}
+
+
+static const struct tslib_vars pthres_vars[] =
+{
+	{ "pmin",	(void *)0, threshold_vars },
+	{ "pmax",	(void *)1, threshold_vars }
+};
+
+#define NR_VARS (sizeof(pthres_vars) / sizeof(pthres_vars[0]))
+
+struct tslib_module_info *mod_init(struct tsdev *dev, const char *params)
+{
+
+	struct tslib_pthres *p;
+
+	p = malloc(sizeof(struct tslib_pthres));
+	if (p == NULL)
+		return NULL;
+
+	p->module.ops = &pthres_ops;
+
+	p->pmin = 1;
+	p->pmax = INT_MAX;
+
+	/*
+	 * Parse the parameters.
+	 */
+	if (tslib_parse_vars(&p->module, pthres_vars, NR_VARS, params)) {
+		free(p);
+		return NULL;
+	}
+
+	return &p->module;
+}
--- tslib/etc/ts.conf~tslib-pthres
+++ tslib/etc/ts.conf
@@ -1,3 +1,4 @@
-module variance delta=30 pthreshold=1
-module dejitter delta=100 pthreshold=1
+module pthres pmin=1
+module variance delta=30
+module dejitter delta=100
 module linear
--- tslib/plugins/variance.c~tslib-pthres
+++ tslib/plugins/variance.c
@@ -33,7 +33,6 @@
 
 struct tslib_variance {
 	struct tslib_module_info module;
-	unsigned int pthreshold;
 	unsigned int delta;
         struct ts_sample last;
         struct ts_sample noise;
@@ -62,7 +61,7 @@
 		} else if (!info->next->ops->read(info->next, &cur, 1))
 			return count;
 
-		if (cur.pressure < var->pthreshold) {
+		if (cur.pressure == 0) {
 			/* Flush the queue immediately when the pen is just
 			 * released, otherwise the previous layer will
 			 * get the pen up notification too late. This 
@@ -151,10 +150,6 @@
 		var->delta = v;
 		break;
 
-	case 2:
-		var->pthreshold = v;
-		break;
-
 	default:
 		return -1;
 	}
@@ -164,7 +159,6 @@
 static const struct tslib_vars variance_vars[] =
 {
 	{ "delta",	(void *)1, variance_limit },
-	{ "pthreshold",	(void *)2, variance_limit }
 };
 
 #define NR_VARS (sizeof(variance_vars) / sizeof(variance_vars[0]))
@@ -180,7 +174,6 @@
 	var->module.ops = &variance_ops;
 
 	var->delta = 30;
-	var->pthreshold = 1;
 	var->flags = 0;
 
 	if (tslib_parse_vars(&var->module, variance_vars, NR_VARS, params)) {
--- tslib/plugins/dejitter.c~tslib-pthres
+++ tslib/plugins/dejitter.c
@@ -63,7 +63,6 @@
 
 struct tslib_dejitter {
 	struct tslib_module_info module;
-	unsigned int pthreshold;
 	unsigned int delta;
 	unsigned int x;
 	unsigned int y;
@@ -110,7 +109,7 @@
 
 	ret = info->next->ops->read(info->next, samp, nr);
 	for (s = samp; ret > 0; s++, ret--) {
-		if (s->pressure < djt->pthreshold) {
+		if (s->pressure == 0) {
 			/*
 			 * Pen was released. Reset the state and
 			 * forget all history events.
@@ -184,10 +183,6 @@
 		djt->delta = v;
 		break;
 
-	case 2:
-		djt->pthreshold = v;
-		break;
-
 	default:
 		return -1;
 	}
@@ -197,7 +192,6 @@
 static const struct tslib_vars dejitter_vars[] =
 {
 	{ "delta",	(void *)1, dejitter_limit },
-	{ "pthreshold",	(void *)2, dejitter_limit }
 };
 
 #define NR_VARS (sizeof(dejitter_vars) / sizeof(dejitter_vars[0]))
@@ -213,7 +207,6 @@
 	djt->module.ops = &dejitter_ops;
 
 	djt->delta = 100;
-	djt->pthreshold = 1;
         djt->head = 0;
 
 	if (tslib_parse_vars(&djt->module, dejitter_vars, NR_VARS, params)) {
