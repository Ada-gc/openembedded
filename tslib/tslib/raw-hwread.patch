
#
# Patch managed by http://www.mn-logistik.de/unsupported/pxa250/patcher
#

--- tslib/plugins/Makefile.am~raw-hwread
+++ tslib/plugins/Makefile.am
@@ -19,9 +19,10 @@
 LIBS			=
 plugindir		= $(PLUGIN_DIR)
 
-EXTRA_LTLIBRARIES	= variance.la dejitter.la linear.la pthres.la
+EXTRA_LTLIBRARIES	= variance.la dejitter.la linear.la pthres.la corgi.la collie.la ucb1x00.la h3600.la mk712.la arctic2.la
 plugin_LTLIBRARIES	= $(PLUGINS)
 
+# filters
 variance_la_SOURCES	= variance.c
 variance_la_LDFLAGS	= -module $(LTVSN)
 
@@ -33,3 +34,22 @@
 
 pthres_la_SOURCES	= pthres.c
 pthres_la_LDFLAGS	= -module $(LTVSN)
+
+# hw access
+corgi_la_SOURCES	= corgi-raw.c
+corgi_la_LDFLAGS	= -module $(LTVSN)
+
+collie_la_SOURCES	= collie-raw.c
+collie_la_LDFLAGS	= -module $(LTVSN)
+
+ucb1x00_la_SOURCES	= ucb1x00-raw.c
+ucb1x00_la_LDFLAGS	= -module $(LTVSN)
+
+h3600_la_SOURCES	= h3600-raw.c
+h3600_la_LDFLAGS	= -module $(LTVSN)
+
+mk712_la_SOURCES	= mk712-raw.c
+mk712_la_LDFLAGS	= -module $(LTVSN)
+
+arctic2_la_SOURCES	= arctic2-raw.c
+arctic2_la_LDFLAGS	= -module $(LTVSN)
--- /dev/null
+++ tslib/plugins/corgi-raw.c
@@ -0,0 +1,60 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include "config.h"
+#include "tslib-private.h"
+
+struct corgi_ts_event { /* Used in the Sharp Zaurus SL-C700 */
+	short pressure;
+	short x;
+	short y;
+	short millisecs;
+};
+
+static int corgi_read(struct tslib_module_info *inf, struct ts_sample *samp, int nr)
+{
+	struct tsdev *ts = inf->dev;
+	struct corgi_ts_event *corgi_evt;
+	int ret;
+	int total = 0;
+	corgi_evt = alloca(sizeof(*corgi_evt) * nr);
+	ret = read(ts->fd, corgi_evt, sizeof(*corgi_evt) * nr);
+	if(ret > 0) {
+		int nr = ret / sizeof(*corgi_evt);
+		while(ret >= sizeof(*corgi_evt)) {
+			samp->x = corgi_evt->x;
+			samp->y = corgi_evt->y;
+			samp->pressure = corgi_evt->pressure;
+#ifdef DEBUG
+        fprintf(stderr,"RAW---------------------------> %d %d %d\n",samp->x,samp->y,samp->pressure);
+#endif /*DEBUG*/
+			samp->tv.tv_usec = corgi_evt->millisecs % 1000;
+			samp->tv.tv_sec = corgi_evt->millisecs / 1000;
+			samp++;
+			corgi_evt++;
+			ret -= sizeof(*corgi_evt);
+		}
+	} else {
+		return -1;
+	}
+	ret = nr;
+	return ret;
+}
+
+static const struct tslib_ops corgi_ops =
+{
+	read:	corgi_read,
+};
+
+struct tslib_module_info *mod_init(struct tsdev *dev, const char *params)
+{
+	struct tslib_module_info *m;
+
+	m = malloc(sizeof(struct tslib_module_info));
+	if (m == NULL)
+		return NULL;
+
+	m->ops = &corgi_ops;
+	return m;
+}
--- tslib/src/ts_read_raw_module.c~raw-hwread
+++ tslib/src/ts_read_raw_module.c
@@ -28,44 +28,6 @@
 #ifdef USE_INPUT_API
 #include <linux/input.h>
 #else
-struct ts_event  {   /* Used in UCB1x00 style touchscreens (the default) */
-	unsigned short pressure;
-	unsigned short x;
-	unsigned short y;
-	unsigned short pad;
-	struct timeval stamp;
-};
-struct h3600_ts_event { /* Used in the Compaq IPAQ */
-	unsigned short pressure;
-	unsigned short x;
-	unsigned short y;
-	unsigned short pad;
-};
-struct mk712_ts_event { /* Used in the Hitachi Webpad */
-	unsigned int header;
-	unsigned int x;
-	unsigned int y;
-	unsigned int reserved;
-};
-struct arctic2_ts_event { /* Used in the IBM Arctic II */
-	signed short pressure;
-	signed int x;
-	signed int y;
-	int millisecs;
-	int flags;
-};
-struct collie_ts_event { /* Used in the Sharp Zaurus SL-5000d and SL-5500 */
-	long y;
-	long x;
-	long pressure;
-	long long millisecs;
-};
-struct corgi_ts_event { /* Used in the Sharp Zaurus SL-C700 */
-	short pressure;
-	short x;
-	short y;
-	short millisecs;
-};
 #endif /* USE_INPUT_API */
 
 #include "tslib-private.h"
@@ -75,17 +37,8 @@
 	struct tsdev *ts = inf->dev;
 #ifdef USE_INPUT_API
 	struct input_event ev;
-#else
-	struct ts_event *evt;
-	struct h3600_ts_event *hevt;
-	struct mk712_ts_event *mevt;
-	struct arctic2_ts_event *aevt;
-	struct collie_ts_event *collie_evt;
-	struct corgi_ts_event *corgi_evt;
-	char *tseventtype=NULL;
-	char *defaulttseventtype="UCB1x00";
 #endif /* USE_INPUT_API */
-	int ret;
+	int ret = nr;
 	int total = 0;
 
 #ifdef USE_INPUT_API
@@ -220,143 +173,6 @@
 	if (ret) ret = -1;
 	if (total) ret = total;
 #endif
-
-#else
-	tseventtype = getenv("TSLIB_TSEVENTTYPE");
-	if(tseventtype==NULL) tseventtype=defaulttseventtype;
-
-	if( strcmp(tseventtype,"H3600") == 0) { /* iPAQ style h3600 touchscreen events */
-		hevt = alloca(sizeof(*hevt) * nr);
-		ret = read(ts->fd, hevt, sizeof(*hevt) * nr);
-		if(ret > 0) {
-			int nr = ret / sizeof(*hevt);
-			while(ret >= sizeof(*hevt)) {
-				samp->x = hevt->x;
-				samp->y = hevt->y;
-				samp->pressure = hevt->pressure;
-#ifdef DEBUG
-        fprintf(stderr,"RAW---------------------------> %d %d %d\n",samp->x,samp->y,samp->pressure);
-#endif /*DEBUG*/
-				gettimeofday(&samp->tv,NULL);
-				samp++;
-				hevt++;
-				ret -= sizeof(*hevt);
-			}
-		} else {
-			return -1;
-		}
-	} else if( strcmp(tseventtype,"MK712") == 0) { /* Hitachi Webpad events */
-		mevt = alloca(sizeof(*mevt) * nr);
-		ret = read(ts->fd, mevt, sizeof(*mevt) * nr);
-		if(ret > 0) {
-			int nr = ret / sizeof(*mevt);
-			while(ret >= sizeof(*mevt)) {
-				samp->x = (short)mevt->x;
-				samp->y = (short)mevt->y;
-				if(mevt->header==0)
-					samp->pressure=1;
-				else
-					samp->pressure=0;
-#ifdef DEBUG
-        fprintf(stderr,"RAW---------------------------> %d %d %d\n",samp->x,samp->y,samp->pressure);
-#endif /*DEBUG*/
-				gettimeofday(&samp->tv,NULL);
-				samp++;
-				mevt++;
-				ret -= sizeof(*mevt);
-			}
-		} else {
-			return -1;
-		}
-
-	} else if( strcmp(tseventtype,"ARCTIC2") == 0) { /* IBM Arctic II events */
-		aevt = alloca(sizeof(*aevt) * nr);
-		ret = read(ts->fd, aevt, sizeof(*aevt) * nr);
-		if(ret > 0) {
-			int nr = ret / sizeof(*aevt);
-			while(ret >= sizeof(*aevt)) {
-				samp->x = (short)aevt->x;
-				samp->y = (short)aevt->y;
-				samp->pressure = aevt->pressure;
-#ifdef DEBUG
-        fprintf(stderr,"RAW---------------------------> %d %d %d\n",samp->x,samp->y,samp->pressure);
-#endif /*DEBUG*/
-				gettimeofday(&samp->tv,NULL);
-				samp++;
-				aevt++;
-				ret -= sizeof(*aevt);
-			}
-		} else {
-			return -1;
-		}
-
-	} else if( strcmp(tseventtype,"COLLIE") == 0) { /* Sharp Zaurus SL-5000d/5500 events */
-		collie_evt = alloca(sizeof(*collie_evt) * nr);
-		ret = read(ts->fd, collie_evt, sizeof(*collie_evt) * nr);
-		if(ret > 0) {
-			int nr = ret / sizeof(*collie_evt);
-			while(ret >= sizeof(*collie_evt)) {
-				samp->x = collie_evt->x;
-				samp->y = collie_evt->y;
-				samp->pressure = collie_evt->pressure;
-#ifdef DEBUG
-        fprintf(stderr,"RAW---------------------------> %d %d %d\n",samp->x,samp->y,samp->pressure);
-#endif /*DEBUG*/
-				samp->tv.tv_usec = collie_evt->millisecs % 1000;
-				samp->tv.tv_sec = collie_evt->millisecs / 1000;
-				samp++;
-				collie_evt++;
-				ret -= sizeof(*collie_evt);
-			}
-		} else {
-			return -1;
-		}
-
-	} else if( strcmp(tseventtype,"CORGI") == 0) { /* Sharp Zaurus SL-C700 events */
-		corgi_evt = alloca(sizeof(*corgi_evt) * nr);
-		ret = read(ts->fd, corgi_evt, sizeof(*corgi_evt) * nr);
-		if(ret > 0) {
-			int nr = ret / sizeof(*corgi_evt);
-			while(ret >= sizeof(*corgi_evt)) {
-				samp->x = corgi_evt->x;
-				samp->y = corgi_evt->y;
-				samp->pressure = corgi_evt->pressure;
-#ifdef DEBUG
-        fprintf(stderr,"RAW---------------------------> %d %d %d\n",samp->x,samp->y,samp->pressure);
-#endif /*DEBUG*/
-				samp->tv.tv_usec = corgi_evt->millisecs % 1000;
-				samp->tv.tv_sec = corgi_evt->millisecs / 1000;
-				samp++;
-				corgi_evt++;
-				ret -= sizeof(*corgi_evt);
-			}
-		} else {
-			return -1;
-		}
-
-	} else { /* Use normal UCB1x00 type events */
-		evt = alloca(sizeof(*evt) * nr);
-		ret = read(ts->fd, evt, sizeof(*evt) * nr);
-		if(ret > 0) {
-			int nr = ret / sizeof(*evt);
-			while(ret >= sizeof(*evt)) {
-				samp->x = evt->x;
-				samp->y = evt->y;
-				samp->pressure = evt->pressure;
-#ifdef DEBUG
-        fprintf(stderr,"RAW---------------------------> %d %d %d\n",samp->x,samp->y,samp->pressure);
-#endif /*DEBUG*/
-				samp->tv.tv_usec = evt->stamp.tv_usec;
-				samp->tv.tv_sec = evt->stamp.tv_sec;
-				samp++;
-				evt++;
-				ret -= sizeof(*evt);
-			}
-		} else {
-			return -1;
-		}
-	}
-	ret = nr;
 #endif /* USE_INPUT_API */
 
 	return ret;
--- /dev/null
+++ tslib/plugins/collie-raw.c
@@ -0,0 +1,61 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include "config.h"
+#include "tslib-private.h"
+
+struct collie_ts_event { /* Used in the Sharp Zaurus SL-5000d and SL-5500 */
+	long y;
+	long x;
+	long pressure;
+	long long millisecs;
+};
+
+static int collie_read(struct tslib_module_info *inf, struct ts_sample *samp, int nr)
+{
+	struct tsdev *ts = inf->dev;
+	struct collie_ts_event *collie_evt;
+	int ret;
+	int total = 0;
+	collie_evt = alloca(sizeof(*collie_evt) * nr);
+	ret = read(ts->fd, collie_evt, sizeof(*collie_evt) * nr);
+	if(ret > 0) {
+		int nr = ret / sizeof(*collie_evt);
+		while(ret >= sizeof(*collie_evt)) {
+			samp->x = collie_evt->x;
+			samp->y = collie_evt->y;
+			samp->pressure = collie_evt->pressure;
+#ifdef DEBUG
+        fprintf(stderr,"RAW---------------------------> %d %d %d\n",samp->x,samp->y,samp->pressure);
+#endif /*DEBUG*/
+			samp->tv.tv_usec = collie_evt->millisecs % 1000;
+			samp->tv.tv_sec = collie_evt->millisecs / 1000;
+			samp++;
+			collie_evt++;
+			ret -= sizeof(*collie_evt);
+		}
+	} else {
+		return -1;
+	}
+
+	ret = nr;
+	return ret;
+}
+
+static const struct tslib_ops collie_ops =
+{
+	read:	collie_read,
+};
+
+struct tslib_module_info *mod_init(struct tsdev *dev, const char *params)
+{
+	struct tslib_module_info *m;
+
+	m = malloc(sizeof(struct tslib_module_info));
+	if (m == NULL)
+		return NULL;
+
+	m->ops = &collie_ops;
+	return m;
+}
--- tslib/configure.in~raw-hwread
+++ tslib/configure.in
@@ -4,15 +4,30 @@
 AM_INIT_AUTOMAKE(libts,0.0.1)
 AM_CONFIG_HEADER(config.h)
 
+# filters
 AC_ARG_ENABLE(linear,   [  --enable-linear         Enable building of linear scaling [default=yes]],
   [ "x$enableval" = "xyes" ] && PLUGINS="$PLUGINS linear.la", PLUGINS="$PLUGINS linear.la")
 AC_ARG_ENABLE(dejitter, [  --enable-dejitter       Enable building of dejitter filter [default=yes]],
   [ "x$enableval" = "xyes" ] && PLUGINS="$PLUGINS dejitter.la", PLUGINS="$PLUGINS dejitter.la")
 AC_ARG_ENABLE(variance, [  --enable-variance       Enable building of variance filter [default=yes]],
   [ "x$enableval" = "xyes" ] && PLUGINS="$PLUGINS variance.la", PLUGINS="$PLUGINS variance.la")
-AC_ARG_ENABLE(pthres, [  --enable-pthres       Enable building of pthres filter [default=yes]],
+AC_ARG_ENABLE(pthres,   [  --enable-pthres         Enable building of pthres filter [default=yes]],
   [ "x$enableval" = "xyes" ] && PLUGINS="$PLUGINS pthres.la", PLUGINS="$PLUGINS pthres.la")
 
+# hardware access modules
+AC_ARG_ENABLE(ucb1x00,  [  --enable-ucb1x00        Enable building of ucb1x00 raw module (UCB1x00 support) [default=yes]],
+  [ "x$enableval" = "xyes" ] && PLUGINS="$PLUGINS ucb1x00.la", PLUGINS="$PLUGINS ucb1x00.la")
+AC_ARG_ENABLE(corgi,    [  --enable-corgi          Enable building of corgi raw module (Sharp Zaurus sl-c7x0 support) [default=yes]],
+  [ "x$enableval" = "xyes" ] && PLUGINS="$PLUGINS corgi.la", PLUGINS="$PLUGINS corgi.la")
+AC_ARG_ENABLE(collie,   [  --enable-collie         Enable building of collie raw module (Sharp Zaurus sl-5500/5000d support) [default=yes]],
+  [ "x$enableval" = "xyes" ] && PLUGINS="$PLUGINS collie.la", PLUGINS="$PLUGINS collie.la")
+AC_ARG_ENABLE(h3600,    [  --enable-h3600          Enable building of h3600 raw module (HP iPaq H3600 support) [default=yes]],
+  [ "x$enableval" = "xyes" ] && PLUGINS="$PLUGINS h3600.la", PLUGINS="$PLUGINS h3600.la")
+AC_ARG_ENABLE(mk712,    [  --enable-mk712          Enable building of mk712 raw module (Hitachi Webpad support) [default=yes]],
+  [ "x$enableval" = "xyes" ] && PLUGINS="$PLUGINS mk712.la", PLUGINS="$PLUGINS mk712.la")
+AC_ARG_ENABLE(arctic2,  [  --enable-arctic2        Enable building of arctic2 raw module (IBM Arctic II support) [default=yes]],
+  [ "x$enableval" = "xyes" ] && PLUGINS="$PLUGINS arctic2.la", PLUGINS="$PLUGINS arctic2.la")
+
 AC_MSG_CHECKING(--enable-debug argument)
 AC_ARG_ENABLE(debug,    [  --enable-debug          Enable debug messages from filters [default=no]], 
   , [enable_debug="no"])
--- /dev/null
+++ tslib/plugins/h3600-raw.c
@@ -0,0 +1,60 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include "config.h"
+#include "tslib-private.h"
+
+struct h3600_ts_event { /* Used in the Compaq IPAQ */
+	unsigned short pressure;
+	unsigned short x;
+	unsigned short y;
+	unsigned short pad;
+};
+
+static int h3600_read(struct tslib_module_info *inf, struct ts_sample *samp, int nr)
+{
+	struct tsdev *ts = inf->dev;
+	struct h3600_ts_event *h3600_evt;
+	int ret;
+	int total = 0;
+	h3600_evt = alloca(sizeof(*h3600_evt) * nr);
+	ret = read(ts->fd, h3600_evt, sizeof(*h3600_evt) * nr);
+	if(ret > 0) {
+		int nr = ret / sizeof(*h3600_evt);
+		while(ret >= sizeof(*h3600_evt)) {
+			samp->x = h3600_evt->x;
+			samp->y = h3600_evt->y;
+			samp->pressure = h3600_evt->pressure;
+#ifdef DEBUG
+        fprintf(stderr,"RAW---------------------------> %d %d %d\n",samp->x,samp->y,samp->pressure);
+#endif /*DEBUG*/
+			gettimeofday(&samp->tv,NULL);
+			samp++;
+			h3600_evt++;
+			ret -= sizeof(*h3600_evt);
+		}
+	} else {
+		return -1;
+	}
+
+	ret = nr;
+	return ret;
+}
+
+static const struct tslib_ops h3600_ops =
+{
+	read:	h3600_read,
+};
+
+struct tslib_module_info *mod_init(struct tsdev *dev, const char *params)
+{
+	struct tslib_module_info *m;
+
+	m = malloc(sizeof(struct tslib_module_info));
+	if (m == NULL)
+		return NULL;
+
+	m->ops = &h3600_ops;
+	return m;
+}
--- tslib/etc/ts.conf~raw-hwread
+++ tslib/etc/ts.conf
@@ -1,3 +1,21 @@
+# Uncomment collie if you're using a Sharp Zaurus SL-5500/SL-5000d
+# module_raw collie
+
+# Uncomment corgi if you're using a Sharp Zaurus SL-C700/C750/C760/C860
+# module_raw corgi
+
+# Uncomment ucb1x00 if you're using a device with a UCB1200/1300/1400 TS interface
+# module_raw ucb1x00
+
+# Uncomment h3600 if you're using an HP iPaq h3600 or similar
+# module_raw h3600
+
+# Uncomment mk712 if you're using a Hitachi Webpad
+# module_raw mk712
+
+# Uncomment arctic2 if you're using an IBM Arctic II
+# module_raw arctic2
+
 module pthres pmin=1
 module variance delta=30
 module dejitter delta=100
--- /dev/null
+++ tslib/plugins/mk712-raw.c
@@ -0,0 +1,63 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include "config.h"
+#include "tslib-private.h"
+
+struct mk712_ts_event { /* Used in the Hitachi Webpad */
+	unsigned int header;
+	unsigned int x;
+	unsigned int y;
+	unsigned int reserved;
+};
+
+static int mk712_read(struct tslib_module_info *inf, struct ts_sample *samp, int nr)
+{
+	struct tsdev *ts = inf->dev;
+	struct mk712_ts_event *mk712_evt;
+	int ret;
+	int total = 0;
+	mk712_evt = alloca(sizeof(*mk712_evt) * nr);
+	ret = read(ts->fd, mk712_evt, sizeof(*mk712_evt) * nr);
+	if(ret > 0) {
+		int nr = ret / sizeof(*mk712_evt);
+		while(ret >= sizeof(*mk712_evt)) {
+			samp->x = (short)mk712_evt->x;
+			samp->y = (short)mk712_evt->y;
+			if(mk712_evt->header==0)
+				samp->pressure=1;
+			else
+				samp->pressure=0;
+#ifdef DEBUG
+        fprintf(stderr,"RAW---------------------------> %d %d %d\n",samp->x,samp->y,samp->pressure);
+#endif /*DEBUG*/
+			gettimeofday(&samp->tv,NULL);
+			samp++;
+			mk712_evt++;
+			ret -= sizeof(*mk712_evt);
+		}
+	} else {
+		return -1;
+	}
+
+	ret = nr;
+	return ret;
+}
+
+static const struct tslib_ops mk712_ops =
+{
+	read:	mk712_read,
+};
+
+struct tslib_module_info *mod_init(struct tsdev *dev, const char *params)
+{
+	struct tslib_module_info *m;
+
+	m = malloc(sizeof(struct tslib_module_info));
+	if (m == NULL)
+		return NULL;
+
+	m->ops = &mk712_ops;
+	return m;
+}
--- /dev/null
+++ tslib/plugins/arctic2-raw.c
@@ -0,0 +1,61 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include "config.h"
+#include "tslib-private.h"
+
+struct arctic2_ts_event { /* Used in the IBM Arctic II */
+	signed short pressure;
+	signed int x;
+	signed int y;
+	int millisecs;
+	int flags;
+};
+
+static int arctic2_read(struct tslib_module_info *inf, struct ts_sample *samp, int nr)
+{
+	struct tsdev *ts = inf->dev;
+	struct arctic2_ts_event *arctic2_evt;
+	int ret;
+	int total = 0;
+	arctic2_evt = alloca(sizeof(*arctic2_evt) * nr);
+	ret = read(ts->fd, arctic2_evt, sizeof(*arctic2_evt) * nr);
+	if(ret > 0) {
+		int nr = ret / sizeof(*arctic2_evt);
+		while(ret >= sizeof(*arctic2_evt)) {
+			samp->x = (short)arctic2_evt->x;
+			samp->y = (short)arctic2_evt->y;
+			samp->pressure = arctic2_evt->pressure;
+#ifdef DEBUG
+        fprintf(stderr,"RAW---------------------------> %d %d %d\n",samp->x,samp->y,samp->pressure);
+#endif /*DEBUG*/
+			gettimeofday(&samp->tv,NULL);
+			samp++;
+			arctic2_evt++;
+			ret -= sizeof(*arctic2_evt);
+		}
+	} else {
+		return -1;
+	}
+
+	ret = nr;
+	return ret;
+}
+
+static const struct tslib_ops arctic2_ops =
+{
+	read:	arctic2_read,
+};
+
+struct tslib_module_info *mod_init(struct tsdev *dev, const char *params)
+{
+	struct tslib_module_info *m;
+
+	m = malloc(sizeof(struct tslib_module_info));
+	if (m == NULL)
+		return NULL;
+
+	m->ops = &arctic2_ops;
+	return m;
+}
--- tslib/README~raw-hwread
+++ tslib/README
@@ -40,8 +40,6 @@
 Environment Variables
 =====================
 
-TSLIB_TSEVENTTYPE		Event type for non input api raw reads.
-				Default: UCB1x00
 TSLIB_TSDEVICE			TS device file name.
 				Default (non inputapi): /dev/touchscreen/ucb1x00  
 				Default (inputapi): /dev/input/event0
--- /dev/null
+++ tslib/plugins/ucb1x00-raw.c
@@ -0,0 +1,62 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+
+#include "config.h"
+#include "tslib-private.h"
+
+struct ucb1x00_ts_event  {   /* Used in UCB1x00 style touchscreens */
+	unsigned short pressure;
+	unsigned short x;
+	unsigned short y;
+	unsigned short pad;
+	struct timeval stamp;
+};
+
+static int ucb1x00_read(struct tslib_module_info *inf, struct ts_sample *samp, int nr)
+{
+	struct tsdev *ts = inf->dev;
+	struct ucb1x00_ts_event *ucb1x00_evt;
+	int ret;
+	int total = 0;
+	ucb1x00_evt = alloca(sizeof(*ucb1x00_evt) * nr);
+	ret = read(ts->fd, ucb1x00_evt, sizeof(*ucb1x00_evt) * nr);
+	if(ret > 0) {
+		int nr = ret / sizeof(*ucb1x00_evt);
+		while(ret >= sizeof(*ucb1x00_evt)) {
+			samp->x = ucb1x00_evt->x;
+			samp->y = ucb1x00_evt->y;
+			samp->pressure = ucb1x00_evt->pressure;
+#ifdef DEBUG
+        fprintf(stderr,"RAW---------------------------> %d %d %d\n",samp->x,samp->y,samp->pressure);
+#endif /*DEBUG*/
+			samp->tv.tv_usec = ucb1x00_evt->stamp.tv_usec;
+			samp->tv.tv_sec = ucb1x00_evt->stamp.tv_sec;
+			samp++;
+			ucb1x00_evt++;
+			ret -= sizeof(*ucb1x00_evt);
+		}
+	} else {
+		return -1;
+	}
+
+	ret = nr;
+	return ret;
+}
+
+static const struct tslib_ops ucb1x00_ops =
+{
+	read:	ucb1x00_read,
+};
+
+struct tslib_module_info *mod_init(struct tsdev *dev, const char *params)
+{
+	struct tslib_module_info *m;
+
+	m = malloc(sizeof(struct tslib_module_info));
+	if (m == NULL)
+		return NULL;
+
+	m->ops = &ucb1x00_ops;
+	return m;
+}
