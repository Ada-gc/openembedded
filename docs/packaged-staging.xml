<?xml version='1.0'   encoding='utf-8'?>
<!--
  ex:ts=4:sw=4:sts=4:et
  -*- tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*-
-->
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
                      "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<book>
    <bookinfo>
        <title>OpenEmbedded Packaged-Staging Project</title>
        <authorgroup>
            <corpauthor>Koen Kooi</corpauthor>
        </authorgroup>
        <copyright>
            <year>2006</year>
            <holder>Koen Kooi</holder>
        </copyright>

0. Introduction

This branch will hold the code for the Google Summer of Code 2006 project "Putting staging under packagemanagement"

The goal is to populate (and de-populate) the staging area using packages OE generates instead of manually poking .h and .so files into it.

First we need to identify three classes of packages:

* 'native'  - These packages run on the buildsystem (e.g. quilt-native)
* 'cross'   - These packages run on the buildsystem, but creates things for the target system (e.g gcc-cross)
* 'regular' - These packages run on the targetsystem (e.g. glibc)

And some terminology:

* 'current metadata' 	- the metadata found in the org.openembedded.dev branch
* 'the branch' 		- the org.openembedded.packaged-staging branch


1. Installing packages If we have packages that can be installed into the staging area we have two modes of operation:    * Start over from scratch    * Incrementally install and remove packages 1.1 Start over from scratchFor each to be built package we will repopulate the staging directory from scratch. The benefits are a clean environment and avoids packages picking stuff up at random. Conflicts when installing packages can only happen when two different providers are trying to install the same file. This can only be a bug of the OpenEmbedded meta data. This approach will not require any conflict handling or resolution

1.2 Incrementally installing packagesIn contrast to repopluating the staging area from scratch we install additional dependencies and remove conflicting packages. The installing and removing of packages is assumed to be faster than repopulating from scratch. Once a package completed we could consider removing the non-native depends to avoid a growing staging directory. One issue is with the clean task. We could assume that cleaning a package will remove it from the staging area as well. There is one possible problem with it. Let us assume we want to clean quilt-native, virtually every package DEPENDS on it, we would have to clean the staging area completely. If this is the wished behaviour needs to be discussed. 

2. Implementation

2.1 Rearranging tasks

In the current metadata packaging happens after staging:

============================================================
--- classes/base.bbclass	18c5b851966c94c02ada5f5c8563f8d59ecb0972+++ classes/base.bbclass	97972c3da5a46e53731eca2d4935d1f7ed45b5aa@@ -593,7 +593,7 @@ base_do_compile() { }

-addtask stage after do_compile+addtask stage after do_install


============================================================--- classes/package.bbclass	35e8e063abe6888f5dbc0a4e6862c7ce05e6e10d+++ classes/package.bbclass	5eeb3a5518350fcf30706cbe34aadc9bae46c360@@ -726,4 +726,4 @@ EXPORT_FUNCTIONS do_package do_shlibs do do_package[dirs] = "${D}" populate_packages[dirs] = "${D}" EXPORT_FUNCTIONS do_package do_shlibs do_split_locales mapping_rename_hook+addtask package before do_stage after do_install-addtask package before do_build after do_stage

I haven't been able to spot any troubles with this change.

2.2 Keeping track of what regular packages OE generates

OE is able to do debian-style shared lib renaming (fontconfig -> libfontconfig0.ipk) and saves the mappings in staging/pkgmaps. The pkgmaps file is lacking some vital info however. The resulting algo is pretty neat:

PACKAGEFUNCS += "do_write_ipk_list"

python do_write_ipk_list () {
        import os, sys
        ipkdir = bb.data.getVar('DEPLOY_DIR_IPK', d, 1)
        stagingdir = bb.data.getVar('STAGING_DIR', d, 1)
        tmpdir = bb.data.getVar('TMPDIR', d, 1)
        p = bb.data.getVar('P', d, 1)
        pr = bb.data.getVar('PR', d, 1)

        packages = bb.data.getVar('PACKAGES', d, 1)
        if not packages:
                bb.debug(1, "PACKAGES not defined, nothing to package")
                return

        if packages == []:
                bb.debug(1, "No packages; nothing to do")
                return

        # Generate ipk.conf if it or the stamp doesnt exist
        listfile = os.path.join(stagingdir,"pkgmaps","%s-%s.spawn" %  ( p , pr ))
        os.system('mkdir -p ' + stagingdir + '/pkgmaps')
        if not os.access(listfile, os.R_OK):
                os.system('rm -f ' + listfile)
                f = open(listfile,"w")
                for spawn in packages.split():
                        #check if the packagename has changed due to debian shlib renaming
                        localdata = bb.data.createCopy(d)
                        pkgname = bb.data.getVar('PKG_%s' % spawn, localdata, 1)
                        if not pkgname:
                                pkgname = spawn
                        f.write("%s\n" % pkgname)
                f.close()
}

So now OE will spit out a spawnfile for each revision of a recipe, instead of one per recipe as the pkgmap code does.

2.3 Installing regular packages

Now we know what OE generates we can install those:

PSTAGE_INSTALL_CMD      = "ipkg-cl install -force-depends -f ${DEPLOY_DIR_PSTAGE}/ipkg.conf -o "
PSTAGE_UPDATE_CMD       = "ipkg-cl update -f ${DEPLOY_DIR_PSTAGE}/ipkg.conf -o "
SPAWNFILE               = "${STAGING_DIR}/pkgmaps/${P}-${PR}.spawn"
SPAWNIPK                = ${spawn}
STAGING_BASEDIR         = "${STAGING_LIBDIR}/.."


       #check for generated packages
        if [ -e ${SPAWNFILE} ]; then
                oenote "List of spawned packages found: ${P}.spawn"
                for spawn in `cat ${SPAWNFILE} | grep -v locale` ; do \
                        if [ -e ${DEPLOY_DIR_IPK}/${spawn}_* ]; then
                                ${PSTAGE_INSTALL_CMD} ${STAGING_BASEDIR} ${spawn}
                                # clean up .la files to avoid having references to the builddirs in the binaries
                                for lafile in ${STAGING_LIBDIR}/*.la ; do \
                                        sed -i s:installed=yes:installed=no:g ${lafile}
                                done
                        else
                                oenote "${spawn} not found, probably empty package"
                        fi
                done
                exit 0
        else
                oenote "Spawn file not found!"
        fi



</book>


