Index: evas/src/lib/engines/common/evas_font_query.c
===================================================================
--- evas/src/lib/engines/common/evas_font_query.c	(revision 2)
+++ evas/src/lib/engines/common/evas_font_query.c	(working copy)
@@ -59,7 +59,10 @@
    return error;
 }
 
-/* string extents */
+/* string extents
+ * Note: no need for special rtl handling
+ * we can assume there's not between languages kerning
+ * and that spaces get the same wide anywhere. */
 EAPI void
 evas_common_font_query_size(RGBA_Font *fn, const char *text, int *w, int *h)
 {
@@ -128,6 +131,7 @@
    if (h) *h = evas_common_font_max_ascent_get(fn) + evas_common_font_max_descent_get(fn);
 }
 
+
 /* text x inset */
 EAPI int
 evas_common_font_query_inset(RGBA_Font *fn, const char *text)
@@ -165,7 +169,10 @@
    return fg->glyph_out->left;
 }
 
-/* h & v advance */
+/* h & v advance
+ * Note: no need for special rtl handling
+ * we can assume there's not between languages kerning
+ * and that spaces get the same wide anywhere. */
 EAPI void
 evas_common_font_query_advance(RGBA_Font *fn, const char *text, int *h_adv, int *v_adv)
 {
@@ -218,19 +225,34 @@
    if (h_adv) *h_adv = pen_x - start_x;
 }
 
+
 /* x y w h for char at char pos */
 EAPI int
-evas_common_font_query_char_coords(RGBA_Font *fn, const char *text, int pos, int *cx, int *cy, int *cw, int *ch)
+evas_common_font_query_char_coords(RGBA_Font *fn, const char *in_text, int pos, int *cx, int *cy, int *cw, int *ch)
 {
    int use_kerning;
    int pen_x, pen_y;
    int prev_chr_end;
    int chr;
    int asc, desc;
+   int char_index = 0; /* the index of the current char */
+   int position;
+   const char *text = in_text;
+   int ret_val = 0;
    FT_UInt prev_index;
    RGBA_Font_Int *fi;
    FT_Face pface = NULL;
 
+#ifdef INTERNATIONAL_SUPPORT
+   int len = 0;
+   EvasIntlParType direction = FRIBIDI_TYPE_ON;
+   EvasIntlLevel *level_list;
+   EvasIntlStrIndex *logical_to_visual;
+
+   char *visual_text = evas_intl_utf8_to_visual(in_text, &len, &direction, &logical_to_visual, NULL, &level_list);
+   text = (visual_text) ? visual_text : in_text;
+#endif
+
    fi = fn->fonts->data;
 
    pen_x = 0;
@@ -241,7 +263,27 @@
    prev_chr_end = 0;
    asc = evas_common_font_max_ascent_get(fn);
    desc = evas_common_font_max_descent_get(fn);
-   for (chr = 0; text[chr];)
+
+   /* find the actual index, not the byte position */
+   position = 0;
+   chr = 0;
+   while (in_text[chr] && chr < pos) {
+      evas_common_font_utf8_get_next((unsigned char *)in_text, &chr);
+      position++;
+   }
+   /* if it's a bad position, break */
+   if (chr != pos) goto end;
+   /* if it's the end, the correct position is one after */
+   if (!in_text[chr]) position++;
+   
+#ifdef INTERNATIONAL_SUPPORT 
+   /* if it's an in string position (not end), get logical position */
+   if (position < len)
+      position = evas_intl_position_logical_to_visual(logical_to_visual, position);
+#endif
+
+
+   for (char_index = 0, chr = 0; text[chr]; char_index++)
      {
 	int pchr;
 	FT_UInt index;
@@ -251,17 +293,34 @@
 
 	pchr = chr;
 	gl = evas_common_font_utf8_get_next((unsigned char *)text, &chr);
+	
 	if (gl == 0) break;
+
 	index = evas_common_font_glyph_search(fn, &fi, gl);
 	kern = 0;
         /* hmmm kerning means i can't sanely do my own cached metric tables! */
 	/* grrr - this means font face sharing is kinda... not an option if */
 	/* you want performance */
 	if ((use_kerning) && (prev_index) && (index) &&
-	    (pface == fi->src->ft.face))
-	  if (evas_common_font_query_kerning(fi, prev_index, index, &kern))
-	    pen_x += kern;
+	     (pface == fi->src->ft.face))
+	   {
+#ifdef INTERNATIONAL_SUPPORT
+	      /* if it's rtl, the kerning matching should be reversed, i.e prev
+	       * index is now the index and the other way around. */
+	      if (evas_intl_is_rtl_char(level_list, char_index))
+		{
+		   if (evas_common_font_query_kerning(fi, index, prev_index, &kern))
+		      pen_x += kern;
+		}
+	      else
+#endif
+              {
 
+	         if (evas_common_font_query_kerning(fi, prev_index, index, &kern))
+	            pen_x += kern;
+	      }
+           }
+
 	pface = fi->src->ft.face;
 	fg = evas_common_font_int_cache_glyph_get(fi, index);
 	if (!fg) continue;
@@ -282,34 +341,57 @@
 	     chr_w += (chr_x - prev_chr_end);
 	     chr_x = prev_chr_end;
 	  }
-	if (pchr == pos)
+	/* we need to see if the char at the visual position is the char wanted */
+	if (char_index == position)
 	  {
 	     if (cx) *cx = chr_x;
 	     if (cy) *cy = -asc;
 	     if (cw) *cw = chr_w;
 	     if (ch) *ch = asc + desc;
-	     return 1;
+	     ret_val = 1;
+	     goto end;
 	  }
 	prev_chr_end = chr_x + chr_w;
 	pen_x += fg->glyph->advance.x >> 16;
 	prev_index = index;
      }
-   return 0;
+end:
+
+#ifdef INTERNATIONAL_SUPPORT
+   if (level_list) free(level_list);
+   if (logical_to_visual) free(logical_to_visual);
+   if (visual_text) free(visual_text);
+#endif
+
+   return ret_val;
 }
 
 /* char pos of text at xy pos */
 EAPI int
-evas_common_font_query_text_at_pos(RGBA_Font *fn, const char *text, int x, int y, int *cx, int *cy, int *cw, int *ch)
+evas_common_font_query_text_at_pos(RGBA_Font *fn, const char *in_text, int x, int y, int *cx, int *cy, int *cw, int *ch)
 {
    int use_kerning;
    int pen_x, pen_y;
    int prev_chr_end;
    int chr;
    int asc, desc;
+   int char_index = 0; /* the index of the current char */
+   const char *text = in_text;
+   int ret_val = -1;
    FT_UInt prev_index;
    RGBA_Font_Int *fi;
    FT_Face pface = NULL;
+   
+#ifdef INTERNATIONAL_SUPPORT
+   int len = 0;
+   EvasIntlParType direction = FRIBIDI_TYPE_ON;
+   EvasIntlLevel *level_list;
+   EvasIntlStrIndex *visual_to_logical;
 
+   char *visual_text = evas_intl_utf8_to_visual(in_text, &len, &direction, NULL, &visual_to_logical, &level_list);
+   text = (visual_text) ? visual_text : in_text;
+#endif
+
    fi = fn->fonts->data;
 
    pen_x = 0;
@@ -320,7 +402,8 @@
    prev_chr_end = 0;
    asc = evas_common_font_max_ascent_get(fn);
    desc = evas_common_font_max_descent_get(fn);
-   for (chr = 0; text[chr];)
+
+   for (char_index = 0, chr = 0; text[chr]; char_index++)
      {
 	int pchr;
 	FT_UInt index;
@@ -328,7 +411,8 @@
 	int chr_x, chr_y, chr_w;
         int gl, kern;
 
-	pchr = chr;
+	
+
 	gl = evas_common_font_utf8_get_next((unsigned char *)text, &chr);
 	if (gl == 0) break;
 	index = evas_common_font_glyph_search(fn, &fi, gl);
@@ -337,10 +421,25 @@
 	/* grrr - this means font face sharing is kinda... not an option if */
 	/* you want performance */
 	if ((use_kerning) && (prev_index) && (index) &&
-	    (pface == fi->src->ft.face))
-	  if (evas_common_font_query_kerning(fi, prev_index, index, &kern))
-	    pen_x += kern;
+	     (pface == fi->src->ft.face))
+	   {
+#ifdef INTERNATIONAL_SUPPORT
+	      /* if it's rtl, the kerning matching should be reversed, i.e prev
+	       * index is now the index and the other way around. */
+	      if (evas_intl_is_rtl_char(level_list, char_index))
+		{
+		   if (evas_common_font_query_kerning(fi, index, prev_index, &kern))
+		      pen_x += kern;
+		}
+	      else
+#endif
+              {
 
+	         if (evas_common_font_query_kerning(fi, prev_index, index, &kern))
+	            pen_x += kern;
+	      }
+           }
+
 	pface = fi->src->ft.face;
 	fg = evas_common_font_int_cache_glyph_get(fi, index);
 	if (!fg) continue;
@@ -368,13 +467,38 @@
 	     if (cy) *cy = -asc;
 	     if (cw) *cw = chr_w;
 	     if (ch) *ch = asc + desc;
-	     return pchr;
+#ifdef INTERNATIONAL_SUPPORT
+             {
+		int i;
+		int logical_chr;
+		int position = evas_intl_position_visual_to_logical(visual_to_logical, char_index);
+
+		 
+		/* ensure even if the list won't run */
+		pchr = 0;					
+		for (logical_chr = 0, i = 0; i <= position; i++) {
+             	   pchr = logical_chr;
+             	   evas_common_font_utf8_get_next((unsigned char *)in_text, &logical_chr);
+                }
+             }
+#endif
+	     ret_val = pchr;
+	     goto end;
 	  }
 	prev_chr_end = chr_x + chr_w;
 	pen_x += fg->glyph->advance.x >> 16;
 	prev_index = index;
      }
-   return -1;
+
+end:
+   
+#ifdef INTERNATIONAL_SUPPORT
+   if (level_list) free(level_list);
+   if (visual_to_logical) free(visual_to_logical);
+   if (visual_text) free(visual_text);
+#endif
+
+   return ret_val;
 }
 
 /* last char pos of text at xy pos
@@ -587,4 +711,4 @@
    return ret_val;
 }
 
-#endif
+#endif
\ No newline at end of file
Index: evas/src/lib/canvas/evas_object_textblock.c
===================================================================
--- evas/src/lib/canvas/evas_object_textblock.c	(revision 2)
+++ evas/src/lib/canvas/evas_object_textblock.c	(working copy)
@@ -1579,17 +1579,16 @@
 static int
 _layout_text_cutoff_get(Ctxt *c, Evas_Object_Textblock_Format *fmt, Evas_Object_Textblock_Item *it)
 {
-   int cx, cy, cw, ch;
 
    if (fmt->font.font)
-     return c->ENFN->font_char_at_coords_get(c->ENDT, fmt->font.font, it->text,
+     return c->ENFN->font_last_up_to_pos(c->ENDT, fmt->font.font, it->text,
 					     c->w -
 					     c->o->style_pad.l -
 					     c->o->style_pad.r -
 					     c->marginl -
 					     c->marginr -
 					     c->x,
-					     0, &cx, &cy, &cw, &ch);
+					     0);
    return -1;
 }
 
@@ -1629,7 +1628,6 @@
 	if (_is_white(chr)) break;
 	tp = p;
      }
-   p = tp;
    if (p < 0) p = 0;
    if ((p >= 0) && (_is_white(chr)))
      evas_common_font_utf8_get_next((unsigned char *)(str), &p);
@@ -1916,7 +1914,10 @@
 			      {
 				 _layout_item_text_cutoff(c, it, wrap);
 				 twrap = wrap;
-				 ch = evas_common_font_utf8_get_next((unsigned char *)str, &twrap);
+				 /*we don't want to move next, that's why it's
+				  * commented out.
+				  * ch = evas_common_font_utf8_get_next((unsigned char *)str, &twrap);
+				  */
 				 str = str + twrap;
 			      }
 			    /* intersects a word */
