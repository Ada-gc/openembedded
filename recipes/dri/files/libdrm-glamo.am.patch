From 5a9a074897b1955f7400b968e0e010a72df98452 Mon Sep 17 00:00:00 2001
From: Martin Jansa <Martin.Jansa@gmail.com>
Date: Mon, 12 Oct 2009 09:16:32 +0200
Subject: [PATCH] Autoconf/Automake stuff for glamo

---
 configure.ac       |    9 +++++++++
 libdrm/Makefile.am |    6 +++++-
 2 files changed, 14 insertions(+), 1 deletions(-)

diff --git a/configure.ac b/configure.ac
index 870c056..e4046c0 100644
--- a/configure.ac
+++ b/configure.ac
@@ -58,6 +58,11 @@ AC_ARG_ENABLE(radeon-experimental-api,
 	      [Enable support for radeon's KMS API (default: disabled)]),
 	      [RADEON=$enableval], [RADEON=no])
 
+AC_ARG_ENABLE(glamo-experimental-api,
+	      AS_HELP_STRING([--enable-glamo-experimental-api],
+	      [Enable support for glamo's KMS API (default: disabled)]),
+	      [GLAMO=$enableval], [GLAMO=no])
+
 dnl ===========================================================================
 dnl check compiler flags
 AC_DEFUN([LIBDRM_CC_TRY_FLAG], [
@@ -138,6 +143,8 @@ AM_CONDITIONAL(HAVE_NOUVEAU, [test "x$NOUVEAU" = xyes])
 
 AM_CONDITIONAL(HAVE_RADEON, [test "x$RADEON" = xyes])
 
+AM_CONDITIONAL(HAVE_GLAMO, [test "x$GLAMO" = xyes])
+
 PKG_CHECK_MODULES(CAIRO, cairo, [HAVE_CAIRO=yes], [HAVE_CAIRO=no])
 if test "x$HAVE_CAIRO" = xyes; then
 	AC_DEFINE(HAVE_CAIRO, 1, [Have cairo support])
@@ -181,6 +188,8 @@ AC_OUTPUT([
 	libdrm/radeon/libdrm_radeon.pc
 	libdrm/nouveau/Makefile
 	libdrm/nouveau/libdrm_nouveau.pc
+	libdrm/glamo/Makefile           
+	libdrm/glamo/libdrm_glamo.pc    
 	shared-core/Makefile
 	tests/Makefile
 	tests/modeprint/Makefile
diff --git a/libdrm/Makefile.am b/libdrm/Makefile.am
index d13bead..e5c810d 100644
--- a/libdrm/Makefile.am
+++ b/libdrm/Makefile.am
@@ -30,7 +30,11 @@ if HAVE_RADEON
 RADEON_SUBDIR = radeon
 endif
 
-SUBDIRS = . $(INTEL_SUBDIR) $(NOUVEAU_SUBDIR) $(RADEON_SUBDIR)
+if HAVE_GLAMO
+GLAMO_SUBDIR = glamo
+endif
+
+SUBDIRS = . $(INTEL_SUBDIR) $(NOUVEAU_SUBDIR) $(RADEON_SUBDIR) ${GLAMO_SUBDIR}
 
 libdrm_la_LTLIBRARIES = libdrm.la
 libdrm_ladir = $(libdir)
-- 
1.6.5

From de5ebd1d95fdd5c8175e5eab1e08d89dbfd8723a Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Tue, 14 Apr 2009 01:00:27 +0100
Subject: [PATCH 01/19] Initial libdrm_glamo bits

---
 libdrm/glamo/Makefile.am        |   52 +++++++++
 libdrm/glamo/glamo_bo.h         |  179 +++++++++++++++++++++++++++++
 libdrm/glamo/glamo_bo_gem.c     |  236 +++++++++++++++++++++++++++++++++++++++
 libdrm/glamo/glamo_bo_gem.h     |   41 +++++++
 libdrm/glamo/glamo_track.c      |  140 +++++++++++++++++++++++
 libdrm/glamo/glamo_track.h      |   64 +++++++++++
 libdrm/glamo/libdrm_glamo.pc.in |   10 ++
 shared-core/glamo_drm.h         |  138 +++++++++++++++++++++++
 10 files changed, 863 insertions(+), 1 deletions(-)
 create mode 100644 libdrm/glamo/Makefile.am
 create mode 100644 libdrm/glamo/glamo_bo.h
 create mode 100644 libdrm/glamo/glamo_bo_gem.c
 create mode 100644 libdrm/glamo/glamo_bo_gem.h
 create mode 100644 libdrm/glamo/glamo_track.c
 create mode 100644 libdrm/glamo/glamo_track.h
 create mode 100644 libdrm/glamo/libdrm_glamo.pc.in
 create mode 100644 shared-core/glamo_drm.h

diff --git a/libdrm/glamo/Makefile.am b/libdrm/glamo/Makefile.am
new file mode 100644
index 0000000..22ce784
--- /dev/null
+++ b/libdrm/glamo/Makefile.am
@@ -0,0 +1,52 @@
+# Copyright (c) 2009 Thomas Whtie <taw@bitwiz.org.uk>
+# Based on libdrm-glamo Copyright © 2008 Jérôme Glisse
+#
+# Permission is hereby granted, free of charge, to any person obtaining a
+# copy of this software and associated documentation files (the "Software"),
+# to deal in the Software without restriction, including without limitation
+# the rights to use, copy, modify, merge, publish, distribute, sublicense,
+# and/or sell copies of the Software, and to permit persons to whom the
+# Software is furnished to do so, subject to the following conditions:
+#
+# The above copyright notice and this permission notice (including the next
+# paragraph) shall be included in all copies or substantial portions of the
+# Software.
+#
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+# IN THE SOFTWARE.
+#
+# Authors:
+#    Jérôme Glisse <glisse@freedesktop.org>
+#    Thomas White <taw@bitwiz.org.uk>
+
+AM_CFLAGS = \
+	$(WARN_CFLAGS) \
+	-I$(top_srcdir)/libdrm \
+	-I$(top_srcdir)/libdrm/glamo \
+	$(PTHREADSTUBS_CFLAGS) \
+	-I$(top_srcdir)/shared-core
+
+libdrm_glamo_la_LTLIBRARIES = libdrm_glamo.la
+libdrm_glamo_ladir = $(libdir)
+libdrm_glamo_la_LDFLAGS = -version-number 1:0:0 -no-undefined
+libdrm_glamo_la_LIBADD = ../libdrm.la @PTHREADSTUBS_LIBS@
+
+libdrm_glamo_la_SOURCES = \
+	glamo_bo_gem.c \
+	glamo_track.c
+
+libdrm_glamoincludedir = ${includedir}/drm
+libdrm_glamoinclude_HEADERS = \
+	glamo_bo.h \
+	glamo_bo_gem.h \
+	glamo_track.h
+
+pkgconfigdir = @pkgconfigdir@
+pkgconfig_DATA = libdrm_glamo.pc
+
+EXTRA_DIST = libdrm_glamo.pc.in
diff --git a/libdrm/glamo/glamo_bo.h b/libdrm/glamo/glamo_bo.h
new file mode 100644
index 0000000..5c605c3
--- /dev/null
+++ b/libdrm/glamo/glamo_bo.h
@@ -0,0 +1,179 @@
+/* 
+ * Copyright © 2008 Jérôme Glisse
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS, AUTHORS
+ * AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE 
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ */
+/*
+ * Authors:
+ *      Jérôme Glisse <glisse@freedesktop.org>
+ */
+#ifndef GLAMO_BO_H
+#define GLAMO_BO_H
+
+#include <stdio.h>
+#include <stdint.h>
+#include "glamo_track.h"
+
+/* bo object */
+#define GLAMO_BO_FLAGS_MACRO_TILE  1
+#define GLAMO_BO_FLAGS_MICRO_TILE  2
+
+struct glamo_bo_manager;
+
+struct glamo_bo {
+    uint32_t                    alignment;
+    uint32_t                    handle;
+    uint32_t                    size;
+    uint32_t                    domains;
+    uint32_t                    flags;
+    unsigned                    cref;
+#ifdef GLAMO_BO_TRACK
+    struct glamo_track         *track;
+#endif
+    void                        *ptr;
+    struct glamo_bo_manager    *bom;
+    uint32_t                    space_accounted;
+};
+
+/* bo functions */
+struct glamo_bo_funcs {
+    struct glamo_bo *(*bo_open)(struct glamo_bo_manager *bom,
+                                 uint32_t handle,
+                                 uint32_t size,
+                                 uint32_t alignment,
+                                 uint32_t domains,
+                                 uint32_t flags);
+    void (*bo_ref)(struct glamo_bo *bo);
+    struct glamo_bo *(*bo_unref)(struct glamo_bo *bo);
+    int (*bo_map)(struct glamo_bo *bo, int write);
+    int (*bo_unmap)(struct glamo_bo *bo);
+    int (*bo_wait)(struct glamo_bo *bo);
+};
+
+struct glamo_bo_manager {
+    struct glamo_bo_funcs  *funcs;
+    int                     fd;
+    struct glamo_tracker   tracker;
+};
+    
+static inline void _glamo_bo_debug(struct glamo_bo *bo,
+                                    const char *op,
+                                    const char *file,
+                                    const char *func,
+                                    int line)
+{
+    fprintf(stderr, "%s %p 0x%08X 0x%08X 0x%08X [%s %s %d]\n",
+            op, bo, bo->handle, bo->size, bo->cref, file, func, line);
+}
+
+static inline struct glamo_bo *_glamo_bo_open(struct glamo_bo_manager *bom,
+                                                uint32_t handle,
+                                                uint32_t size,
+                                                uint32_t alignment,
+                                                uint32_t domains,
+                                                uint32_t flags,
+                                                const char *file,
+                                                const char *func,
+                                                int line)
+{
+    struct glamo_bo *bo;
+
+    bo = bom->funcs->bo_open(bom, handle, size, alignment, domains, flags);
+#ifdef GLAMO_BO_TRACK
+    if (bo) {
+        bo->track = glamo_tracker_add_track(&bom->tracker, bo->handle);
+        glamo_track_add_event(bo->track, file, func, "open", line);
+    }
+#endif
+    return bo;
+}
+
+static inline void _glamo_bo_ref(struct glamo_bo *bo,
+                                  const char *file,
+                                  const char *func,
+                                  int line)
+{
+    bo->cref++;
+#ifdef GLAMO_BO_TRACK
+    glamo_track_add_event(bo->track, file, func, "ref", line); 
+#endif
+    bo->bom->funcs->bo_ref(bo);
+}
+
+static inline struct glamo_bo *_glamo_bo_unref(struct glamo_bo *bo,
+                                                 const char *file,
+                                                 const char *func,
+                                                 int line)
+{
+    bo->cref--;
+#ifdef GLAMO_BO_TRACK
+    glamo_track_add_event(bo->track, file, func, "unref", line);
+    if (bo->cref <= 0) {
+        glamo_tracker_remove_track(&bo->bom->tracker, bo->track);
+        bo->track = NULL;
+    }
+#endif
+    return bo->bom->funcs->bo_unref(bo);
+}
+
+static inline int _glamo_bo_map(struct glamo_bo *bo,
+                                 int write,
+                                 const char *file,
+                                 const char *func,
+                                 int line)
+{
+    return bo->bom->funcs->bo_map(bo, write);
+}
+
+static inline int _glamo_bo_unmap(struct glamo_bo *bo,
+                                   const char *file,
+                                   const char *func,
+                                   int line)
+{
+    return bo->bom->funcs->bo_unmap(bo);
+}
+
+static inline int _glamo_bo_wait(struct glamo_bo *bo,
+                                  const char *file,
+                                  const char *func,
+                                  int line)
+{
+    return bo->bom->funcs->bo_wait(bo);
+}
+
+#define glamo_bo_open(bom, h, s, a, d, f)\
+    _glamo_bo_open(bom, h, s, a, d, f, __FILE__, __FUNCTION__, __LINE__)
+#define glamo_bo_ref(bo)\
+    _glamo_bo_ref(bo, __FILE__, __FUNCTION__, __LINE__)
+#define glamo_bo_unref(bo)\
+    _glamo_bo_unref(bo, __FILE__, __FUNCTION__, __LINE__)
+#define glamo_bo_map(bo, w)\
+    _glamo_bo_map(bo, w, __FILE__, __FUNCTION__, __LINE__)
+#define glamo_bo_unmap(bo)\
+    _glamo_bo_unmap(bo, __FILE__, __FUNCTION__, __LINE__)
+#define glamo_bo_debug(bo, opcode)\
+    _glamo_bo_debug(bo, opcode, __FILE__, __FUNCTION__, __LINE__)
+#define glamo_bo_wait(bo) \
+    _glamo_bo_wait(bo, __FILE__, __func__, __LINE__)
+
+#endif
diff --git a/libdrm/glamo/glamo_bo_gem.c b/libdrm/glamo/glamo_bo_gem.c
new file mode 100644
index 0000000..6dc5a14
--- /dev/null
+++ b/libdrm/glamo/glamo_bo_gem.c
@@ -0,0 +1,236 @@
+/*
+ * Copyright © 2009 Thomas White
+ * Copyright © 2008 Dave Airlie
+ * Copyright © 2008 Jérôme Glisse
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS, AUTHORS
+ * AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ */
+/*
+ * Authors:
+ *      Dave Airlie
+ *      Jérôme Glisse <glisse@freedesktop.org>
+ *      Thomas White <taw@bitwiz.org.uk>
+ */
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <errno.h>
+
+#include "xf86drm.h"
+#include "drm.h"
+#include "glamo_drm.h"
+#include "glamo_bo.h"
+#include "glamo_bo_gem.h"
+
+struct glamo_bo_gem {
+    struct glamo_bo   base;
+    uint32_t          name;
+    int               map_count;
+};
+
+struct bo_manager_gem {
+    struct glamo_bo_manager    base;
+};
+
+static struct glamo_bo *bo_open(struct glamo_bo_manager *bom,
+                                 uint32_t handle,
+                                 uint32_t size,
+                                 uint32_t alignment,
+                                 uint32_t domains,
+                                 uint32_t flags)
+{
+    struct glamo_bo_gem *bo;
+    int r;
+
+    printf("bo_open, size=%i\n", size);fflush(stdout);
+
+    bo = (struct glamo_bo_gem*)calloc(1, sizeof(struct glamo_bo_gem));
+    if (bo == NULL) {
+        return NULL;
+    }
+
+    bo->base.bom = bom;
+    bo->base.handle = 0;
+    bo->base.size = size;
+    bo->base.alignment = alignment;
+    bo->base.domains = domains;
+    bo->base.flags = flags;
+    bo->base.ptr = NULL;
+    bo->map_count = 0;
+    if (handle) {
+        struct drm_gem_open open_arg;
+
+        memset(&open_arg, 0, sizeof(open_arg));
+        open_arg.name = handle;
+        r = ioctl(bom->fd, DRM_IOCTL_GEM_OPEN, &open_arg);
+        if (r != 0) {
+            free(bo);
+            return NULL;
+        }
+        bo->base.handle = open_arg.handle;
+        bo->base.size = open_arg.size;
+        bo->name = handle;
+    } else {
+        struct drm_glamo_gem_create args;
+
+        args.size = size;
+        args.alignment = alignment;
+        args.initial_domain = bo->base.domains;
+        args.no_backing_store = 0;
+        args.handle = 0;
+        r = drmCommandWriteRead(bom->fd, DRM_GLAMO_GEM_CREATE,
+                                &args, sizeof(args));
+        bo->base.handle = args.handle;
+        if (r) {
+            fprintf(stderr, "Failed to allocate :\n");
+            fprintf(stderr, "   size      : %d bytes\n", size);
+            fprintf(stderr, "   alignment : %d bytes\n", alignment);
+            fprintf(stderr, "   domains   : %d\n", bo->base.domains);
+            free(bo);
+            return NULL;
+        }
+    }
+    glamo_bo_ref((struct glamo_bo*)bo);
+    return (struct glamo_bo*)bo;
+}
+
+static void bo_ref(struct glamo_bo *bo)
+{
+}
+
+static struct glamo_bo *bo_unref(struct glamo_bo *bo)
+{
+    struct glamo_bo_gem *bo_gem = (struct glamo_bo_gem*)bo;
+    struct drm_gem_close args;
+
+    if (bo == NULL) {
+        return NULL;
+    }
+    if (bo->cref) {
+        return bo;
+    }
+    if (bo_gem->map_count) {
+        munmap(bo->ptr, bo->size);
+    }
+
+    /* close object */
+    args.handle = bo->handle;
+    ioctl(bo->bom->fd, DRM_IOCTL_GEM_CLOSE, &args);
+    memset(bo_gem, 0, sizeof(struct glamo_bo_gem));
+    free(bo_gem);
+    return NULL;
+}
+
+static int bo_map(struct glamo_bo *bo, int write)
+{
+    struct glamo_bo_gem *bo_gem = (struct glamo_bo_gem*)bo;
+    struct drm_glamo_gem_mmap args;
+    int r;
+
+    if (bo_gem->map_count++ != 0) {
+        return 0;
+    }
+    bo->ptr = NULL;
+    args.handle = bo->handle;
+    args.offset = 0;
+    args.size = (uint64_t)bo->size;
+    r = drmCommandWriteRead(bo->bom->fd,
+                            DRM_GLAMO_GEM_MMAP,
+                            &args,
+                            sizeof(args));
+    if (!r) {
+        bo->ptr = (void *)(unsigned long)args.addr_ptr;
+    } else {
+        fprintf(stderr, "error mapping %p 0x%08X (error = %d)\n",
+                bo, bo->handle, r);
+    }
+    return r;
+}
+
+static int bo_unmap(struct glamo_bo *bo)
+{
+    struct glamo_bo_gem *bo_gem = (struct glamo_bo_gem*)bo;
+
+    if (--bo_gem->map_count > 0) {
+        return 0;
+    }
+    munmap(bo->ptr, bo->size);
+    bo->ptr = NULL;
+    return 0;
+}
+
+static int bo_wait(struct glamo_bo *bo)
+{
+    struct drm_glamo_gem_wait_rendering args;
+    int ret;
+
+    args.handle = bo->handle;
+    do {
+        ret = drmCommandWriteRead(bo->bom->fd, DRM_GLAMO_GEM_WAIT_RENDERING,
+                                  &args, sizeof(args));
+    } while (ret == -EAGAIN);
+    return ret;
+}
+
+static struct glamo_bo_funcs bo_gem_funcs = {
+    bo_open,
+    bo_ref,
+    bo_unref,
+    bo_map,
+    bo_unmap,
+    bo_wait
+};
+
+struct glamo_bo_manager *glamo_bo_manager_gem_ctor(int fd)
+{
+    struct bo_manager_gem *bomg;
+
+    printf("Creating a new glamo_bo_manager\n");fflush(stdout);
+
+    bomg = (struct bo_manager_gem*)calloc(1, sizeof(struct bo_manager_gem));
+    if (bomg == NULL) {
+        return NULL;
+    }
+    bomg->base.funcs = &bo_gem_funcs;
+    bomg->base.fd = fd;
+    return (struct glamo_bo_manager*)bomg;
+}
+
+void glamo_bo_manager_gem_dtor(struct glamo_bo_manager *bom)
+{
+    struct bo_manager_gem *bomg = (struct bo_manager_gem*)bom;
+
+    if (bom == NULL) {
+        return;
+    }
+    free(bomg);
+}
+
+uint32_t glamo_gem_name_bo(struct glamo_bo *bo)
+{
+    struct glamo_bo_gem *bo_gem = (struct glamo_bo_gem*)bo;
+    return bo_gem->name;
+}
diff --git a/libdrm/glamo/glamo_bo_gem.h b/libdrm/glamo/glamo_bo_gem.h
new file mode 100644
index 0000000..7230176
--- /dev/null
+++ b/libdrm/glamo/glamo_bo_gem.h
@@ -0,0 +1,41 @@
+/* 
+ * Copyright © 2008 Dave Airlie
+ * Copyright © 2008 Jérôme Glisse
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS, AUTHORS
+ * AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE 
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ */
+/*
+ * Authors:
+ *      Dave Airlie
+ *      Jérôme Glisse <glisse@freedesktop.org>
+ */
+#ifndef GLAMO_BO_GEM_H
+#define GLAMO_BO_GEM_H
+
+#include "glamo_bo.h"
+
+struct glamo_bo_manager *glamo_bo_manager_gem_ctor(int fd);
+void glamo_bo_manager_gem_dtor(struct glamo_bo_manager *bom);
+
+uint32_t glamo_gem_name_bo(struct glamo_bo *bo);
+#endif
diff --git a/libdrm/glamo/glamo_track.c b/libdrm/glamo/glamo_track.c
new file mode 100644
index 0000000..27ffe41
--- /dev/null
+++ b/libdrm/glamo/glamo_track.c
@@ -0,0 +1,140 @@
+/* 
+ * Copyright © 2008 Jérôme Glisse
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS, AUTHORS
+ * AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE 
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ */
+/*
+ * Authors:
+ *      Jérôme Glisse <glisse@freedesktop.org>
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "glamo_track.h"
+
+void glamo_track_add_event(struct glamo_track *track,
+                            const char *file,
+                            const char *func,
+                            const char *op,
+                            unsigned line)
+{
+    struct glamo_track_event *event;
+
+    if (track == NULL) {
+        return;
+    }
+    event = (void*)calloc(1,sizeof(struct glamo_track_event));
+    if (event == NULL) {
+        return;
+    }
+    event->line = line;
+    event->file = strdup(file);
+    event->func = strdup(func);
+    event->op = strdup(op);
+    if (event->file == NULL || event->func == NULL || event->op == NULL) {
+        free(event->file);
+        free(event->func);
+        free(event->op);
+        free(event);
+        return;
+    }
+    event->next = track->events;
+    track->events = event;
+}
+
+struct glamo_track *glamo_tracker_add_track(struct glamo_tracker *tracker,
+                                              unsigned key)
+{
+    struct glamo_track *track;
+
+    track = (struct glamo_track*)calloc(1, sizeof(struct glamo_track));
+    if (track) {
+        track->next = tracker->tracks.next;
+        track->prev = &tracker->tracks;
+        tracker->tracks.next = track;
+        if (track->next) {
+            track->next->prev = track;
+        }
+        track->key = key;
+        track->events = NULL;
+    }
+    return track;
+}
+
+void glamo_tracker_remove_track(struct glamo_tracker *tracker,
+                                 struct glamo_track *track)
+{
+    struct glamo_track_event *event;
+    void *tmp;
+
+    if (track == NULL) {
+        return;
+    }
+    track->prev->next = track->next;
+    if (track->next) {
+        track->next->prev = track->prev;
+    }
+    track->next = track->prev = NULL;
+    event = track->events;
+    while (event) {
+        tmp = event;
+        free(event->file);
+        free(event->func);
+        free(event->op);
+        event = event->next;
+        free(tmp);
+    }
+    track->events = NULL;
+    free(track);
+}
+
+void glamo_tracker_print(struct glamo_tracker *tracker, FILE *file)
+{
+    struct glamo_track *track;
+    struct glamo_track_event *event;
+    void *tmp;
+
+    track = tracker->tracks.next;
+    while (track) {
+        event = track->events;
+        fprintf(file, "[0x%08X] :\n", track->key);
+        while (event) {
+            tmp = event;
+            fprintf(file, "  [0x%08X:%s](%s:%s:%d)\n",
+                    track->key, event->op,  event->file,
+                    event->func, event->line);
+            free(event->file);
+            free(event->func);
+            free(event->op);
+            event->file = NULL;
+            event->func = NULL;
+            event->op = NULL;
+            event = event->next;
+            free(tmp);
+        }
+        track->events = NULL;
+        tmp = track;
+        track = track->next;
+        free(tmp);
+    }
+}
diff --git a/libdrm/glamo/glamo_track.h b/libdrm/glamo/glamo_track.h
new file mode 100644
index 0000000..fedead7
--- /dev/null
+++ b/libdrm/glamo/glamo_track.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright © 2008 Jérôme Glisse
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS, AUTHORS
+ * AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ */
+/*
+ * Authors:
+ *      Jérôme Glisse <glisse@freedesktop.org>
+ */
+#ifndef GLAMO_TRACK_H
+#define GLAMO_TRACK_H
+
+struct glamo_track_event {
+    struct glamo_track_event   *next;
+    char                        *file;
+    char                        *func;
+    char                        *op;
+    unsigned                    line;
+};
+
+struct glamo_track {
+    struct glamo_track         *next;
+    struct glamo_track         *prev;
+    unsigned                    key;
+    struct glamo_track_event   *events;
+};
+
+struct glamo_tracker {
+    struct glamo_track         tracks;
+};
+
+void glamo_track_add_event(struct glamo_track *track,
+                            const char *file,
+                            const char *func,
+                            const char *op,
+                            unsigned line);
+struct glamo_track *glamo_tracker_add_track(struct glamo_tracker *tracker,
+                                              unsigned key);
+void glamo_tracker_remove_track(struct glamo_tracker *tracker,
+                                 struct glamo_track *track);
+void glamo_tracker_print(struct glamo_tracker *tracker,
+                          FILE *file);
+
+#endif
diff --git a/libdrm/glamo/libdrm_glamo.pc.in b/libdrm/glamo/libdrm_glamo.pc.in
new file mode 100644
index 0000000..269b7a5
--- /dev/null
+++ b/libdrm/glamo/libdrm_glamo.pc.in
@@ -0,0 +1,10 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: libdrm_glamo
+Description: Userspace interface to kernel DRM services for Glamo
+Version: 1.0.1
+Libs: -L${libdir} -ldrm_glamo
+Cflags: -I${includedir} -I${includedir}/drm
diff --git a/shared-core/glamo_drm.h b/shared-core/glamo_drm.h
new file mode 100644
index 0000000..68b6547
--- /dev/null
+++ b/shared-core/glamo_drm.h
@@ -0,0 +1,138 @@
+/* glamo_drm.h -- Public header for the Glamo driver
+ *
+ * Copyright 2009 Thomas White
+ * Copyright 2000 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc., Fremont, California.
+ * Copyright 2002 Tungsten Graphics, Inc., Cedar Park, Texas.
+ * All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors:
+ *    Thomas White <taw@bitwiz.org.uk>
+ *    Kevin E. Martin <martin@valinux.com>
+ *    Gareth Hughes <gareth@valinux.com>
+ *    Keith Whitwell <keith@tungstengraphics.com>
+ */
+
+#ifndef __GLAMO_DRM_H__
+#define __GLAMO_DRM_H__
+
+#include "drm.h"
+
+/* Glamo specific ioctls */
+#define DRM_GLAMO_CMDBUF     0x01
+#define DRM_GLAMO_SWAP       0x02
+
+#define DRM_GLAMO_GEM_INFO     0x1c
+#define DRM_GLAMO_GEM_CREATE   0x1d
+#define DRM_GLAMO_GEM_MMAP     0x1e
+#define DRM_GLAMO_GEM_PIN      0x1f
+#define DRM_GLAMO_GEM_UNPIN    0x20
+#define DRM_GLAMO_GEM_PREAD    0x21
+#define DRM_GLAMO_GEM_PWRITE   0x22
+#define DRM_GLAMO_GEM_WAIT_RENDERING 0x24
+
+#define DRM_IOCTL_GLAMO_CMDBUF     DRM_IOW( DRM_COMMAND_BASE + DRM_GLAMO_CMDBUF, drm_glamo_cmd_buffer_t)
+#define DRM_IOCTL_GLAMO_SWAP       DRM_IO(  DRM_COMMAND_BASE + DRM_GLAMO_SWAP)
+
+#define DRM_IOCTL_GLAMO_GEM_INFO   DRM_IOWR(DRM_COMMAND_BASE + DRM_GLAMO_GEM_INFO, struct drm_glamo_gem_info)
+#define DRM_IOCTL_GLAMO_GEM_CREATE DRM_IOWR(DRM_COMMAND_BASE + DRM_GLAMO_GEM_CREATE, struct drm_glamo_gem_create)
+#define DRM_IOCTL_GLAMO_GEM_MMAP   DRM_IOWR(DRM_COMMAND_BASE + DRM_GLAMO_GEM_MMAP, struct drm_glamo_gem_mmap)
+#define DRM_IOCTL_GLAMO_GEM_PIN    DRM_IOWR(DRM_COMMAND_BASE + DRM_GLAMO_GEM_PIN, struct drm_glamo_gem_pin)
+#define DRM_IOCTL_GLAMO_GEM_UNPIN  DRM_IOWR(DRM_COMMAND_BASE + DRM_GLAMO_GEM_UNPIN, struct drm_glamo_gem_unpin)
+#define DRM_IOCTL_GLAMO_GEM_PREAD  DRM_IOWR(DRM_COMMAND_BASE + DRM_GLAMO_GEM_PREAD, struct drm_glamo_gem_pread)
+#define DRM_IOCTL_GLAMO_GEM_PWRITE DRM_IOWR(DRM_COMMAND_BASE + DRM_GLAMO_GEM_PWRITE, struct drm_glamo_gem_pwrite)
+#define DRM_IOCTL_GLAMO_GEM_WAIT_RENDERING DRM_IOW(DRM_COMMAND_BASE + DRM_GLAMO_GEM_WAIT_RENDERING, struct drm_glamo_gem_wait_rendering)
+
+typedef struct drm_glamo_cmd_buffer {
+	int bufsz;
+	char __user *buf;
+	int nbox;
+	struct drm_clip_rect __user *boxes;
+} drm_glamo_cmd_buffer_t;
+
+/* return to userspace start/size of gtt and vram apertures */
+struct drm_glamo_gem_info {
+	uint64_t gart_start;
+	uint64_t gart_size;
+	uint64_t vram_start;
+	uint64_t vram_size;
+	uint64_t vram_visible;
+};
+
+struct drm_glamo_gem_create {
+	uint64_t size;
+	uint64_t alignment;
+	uint32_t handle;
+	uint32_t initial_domain; // to allow VRAM to be created
+	uint32_t no_backing_store; // for VRAM objects - select whether they need backing store
+	// pretty much front/back/depth don't need it - other things do
+};
+
+struct drm_glamo_gem_mmap {
+	uint32_t handle;
+	uint32_t pad;
+	uint64_t offset;
+	uint64_t size;
+	uint64_t addr_ptr;
+};
+
+struct drm_glamo_gem_wait_rendering {
+	uint32_t handle;
+};
+
+struct drm_glamo_gem_pin {
+	uint32_t handle;
+	uint32_t pin_domain;
+	uint64_t alignment;
+	uint64_t offset;
+};
+
+struct drm_glamo_gem_unpin {
+	uint32_t handle;
+	uint32_t pad;
+};
+
+struct drm_glamo_gem_pread {
+	/** Handle for the object being read. */
+	uint32_t handle;
+	uint32_t pad;
+	/** Offset into the object to read from */
+	uint64_t offset;
+	/** Length of data to read */
+	uint64_t size;
+	/** Pointer to write the data into. */
+	uint64_t data_ptr;	/* void *, but pointers are not 32/64 compatible */
+};
+
+struct drm_glamo_gem_pwrite {
+	/** Handle for the object being written to. */
+	uint32_t handle;
+	uint32_t pad;
+	/** Offset into the object to write to */
+	uint64_t offset;
+	/** Length of data to write */
+	uint64_t size;
+	/** Pointer to read the data from. */
+	uint64_t data_ptr;	/* void *, but pointers are not 32/64 compatible */
+};
+
+#endif
-- 
1.6.5.rc2

From 5391113ed7ff13961d1201f2c95c79a8ff89ff50 Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Tue, 21 Apr 2009 01:19:54 +0100
Subject: [PATCH 02/19] Add domain #define, and install glamo_drm.h

---
 shared-core/Makefile.am |    3 ++-
 shared-core/glamo_drm.h |    2 ++
 2 files changed, 4 insertions(+), 1 deletions(-)

diff --git a/shared-core/Makefile.am b/shared-core/Makefile.am
index 5b65bc6..4d56c49 100644
--- a/shared-core/Makefile.am
+++ b/shared-core/Makefile.am
@@ -39,4 +39,5 @@ klibdrminclude_HEADERS = \
                          via_drm.h \
                          r300_reg.h \
                          via_3d_reg.h \
-			 xgi_drm.h
+			 xgi_drm.h \
+			 glamo_drm.h
diff --git a/shared-core/glamo_drm.h b/shared-core/glamo_drm.h
index 68b6547..1f128b6 100644
--- a/shared-core/glamo_drm.h
+++ b/shared-core/glamo_drm.h
@@ -37,6 +37,8 @@
 
 #include "drm.h"
 
+#define GLAMO_GEM_DOMAIN_VRAM (0x1)
+
 /* Glamo specific ioctls */
 #define DRM_GLAMO_CMDBUF     0x01
 #define DRM_GLAMO_SWAP       0x02
-- 
1.6.5.rc2

From e56c92c7d749e9f2d76a6eb1c8954ffaf3858eeb Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Mon, 27 Apr 2009 00:27:39 +0100
Subject: [PATCH 03/19] Authorship, whitespace

---
 libdrm/glamo/glamo_bo.h |   16 ++++++++++------
 1 files changed, 10 insertions(+), 6 deletions(-)

diff --git a/libdrm/glamo/glamo_bo.h b/libdrm/glamo/glamo_bo.h
index 5c605c3..47b141c 100644
--- a/libdrm/glamo/glamo_bo.h
+++ b/libdrm/glamo/glamo_bo.h
@@ -1,7 +1,10 @@
-/* 
+/*
+ * Copyright (c) 2009 Thomas White
+ *
+ * Heavily based on radeon_bo.h
  * Copyright © 2008 Jérôme Glisse
  * All Rights Reserved.
- * 
+ *
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
@@ -9,14 +12,14 @@
  * distribute, sub license, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject to
  * the following conditions:
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
  * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS, AUTHORS
  * AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE 
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  * USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
  * The above copyright notice and this permission notice (including the
@@ -26,6 +29,7 @@
 /*
  * Authors:
  *      Jérôme Glisse <glisse@freedesktop.org>
+ *	Thomas White <taw@bitwiz.org.uk>
  */
 #ifndef GLAMO_BO_H
 #define GLAMO_BO_H
@@ -75,7 +79,7 @@ struct glamo_bo_manager {
     int                     fd;
     struct glamo_tracker   tracker;
 };
-    
+
 static inline void _glamo_bo_debug(struct glamo_bo *bo,
                                     const char *op,
                                     const char *file,
@@ -115,7 +119,7 @@ static inline void _glamo_bo_ref(struct glamo_bo *bo,
 {
     bo->cref++;
 #ifdef GLAMO_BO_TRACK
-    glamo_track_add_event(bo->track, file, func, "ref", line); 
+    glamo_track_add_event(bo->track, file, func, "ref", line);
 #endif
     bo->bom->funcs->bo_ref(bo);
 }
-- 
1.6.5.rc2

From 552f3e5e02f84ec401ad34b4f2e2e28b94b2e0ed Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Mon, 27 Apr 2009 00:27:55 +0100
Subject: [PATCH 04/19] Add missing include and cast

---
 libdrm/glamo/glamo_bo.h |    3 ++-
 1 files changed, 2 insertions(+), 1 deletions(-)

diff --git a/libdrm/glamo/glamo_bo.h b/libdrm/glamo/glamo_bo.h
index 47b141c..c4a13a9 100644
--- a/libdrm/glamo/glamo_bo.h
+++ b/libdrm/glamo/glamo_bo.h
@@ -37,6 +37,7 @@
 #include <stdio.h>
 #include <stdint.h>
 #include "glamo_track.h"
+#include <drm/glamo_drm.h>
 
 /* bo object */
 #define GLAMO_BO_FLAGS_MACRO_TILE  1
@@ -87,7 +88,7 @@ static inline void _glamo_bo_debug(struct glamo_bo *bo,
                                     int line)
 {
     fprintf(stderr, "%s %p 0x%08X 0x%08X 0x%08X [%s %s %d]\n",
-            op, bo, bo->handle, bo->size, bo->cref, file, func, line);
+            op, (void *)bo, bo->handle, bo->size, bo->cref, file, func, line);
 }
 
 static inline struct glamo_bo *_glamo_bo_open(struct glamo_bo_manager *bom,
-- 
1.6.5.rc2

From 063cac228729e3dbe7824474000cb1b73c10da99 Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Wed, 6 May 2009 01:19:27 +0100
Subject: [PATCH 05/19] Update glamo_drm.h from kernel source

---
 shared-core/glamo_drm.h |   18 ++++++++----------
 1 files changed, 8 insertions(+), 10 deletions(-)

diff --git a/shared-core/glamo_drm.h b/shared-core/glamo_drm.h
index 1f128b6..1b585e4 100644
--- a/shared-core/glamo_drm.h
+++ b/shared-core/glamo_drm.h
@@ -52,8 +52,8 @@
 #define DRM_GLAMO_GEM_PWRITE   0x22
 #define DRM_GLAMO_GEM_WAIT_RENDERING 0x24
 
-#define DRM_IOCTL_GLAMO_CMDBUF     DRM_IOW( DRM_COMMAND_BASE + DRM_GLAMO_CMDBUF, drm_glamo_cmd_buffer_t)
-#define DRM_IOCTL_GLAMO_SWAP       DRM_IO(  DRM_COMMAND_BASE + DRM_GLAMO_SWAP)
+#define DRM_IOCTL_GLAMO_CMDBUF     DRM_IOW(DRM_COMMAND_BASE + DRM_GLAMO_CMDBUF, drm_glamo_cmd_buffer_t)
+#define DRM_IOCTL_GLAMO_SWAP       DRM_IO(DRM_COMMAND_BASE + DRM_GLAMO_SWAP)
 
 #define DRM_IOCTL_GLAMO_GEM_INFO   DRM_IOWR(DRM_COMMAND_BASE + DRM_GLAMO_GEM_INFO, struct drm_glamo_gem_info)
 #define DRM_IOCTL_GLAMO_GEM_CREATE DRM_IOWR(DRM_COMMAND_BASE + DRM_GLAMO_GEM_CREATE, struct drm_glamo_gem_create)
@@ -65,19 +65,18 @@
 #define DRM_IOCTL_GLAMO_GEM_WAIT_RENDERING DRM_IOW(DRM_COMMAND_BASE + DRM_GLAMO_GEM_WAIT_RENDERING, struct drm_glamo_gem_wait_rendering)
 
 typedef struct drm_glamo_cmd_buffer {
-	int bufsz;
-	char __user *buf;
+	int bufsz;		/* Size of buffer, in bytes */
+	char __user *buf;	/* Buffer of stuff to go onto the ring buffer */
+	int *obj_pos;		/* Offsets (in bytes) at which to put objs */
+	uint32_t *objs;		/* List of buffer object (handles) to use */
+	int nobjs;		/* Number of objects referenced */
 	int nbox;
 	struct drm_clip_rect __user *boxes;
 } drm_glamo_cmd_buffer_t;
 
-/* return to userspace start/size of gtt and vram apertures */
 struct drm_glamo_gem_info {
-	uint64_t gart_start;
-	uint64_t gart_size;
 	uint64_t vram_start;
 	uint64_t vram_size;
-	uint64_t vram_visible;
 };
 
 struct drm_glamo_gem_create {
@@ -85,8 +84,7 @@ struct drm_glamo_gem_create {
 	uint64_t alignment;
 	uint32_t handle;
 	uint32_t initial_domain; // to allow VRAM to be created
-	uint32_t no_backing_store; // for VRAM objects - select whether they need backing store
-	// pretty much front/back/depth don't need it - other things do
+	uint32_t no_backing_store;
 };
 
 struct drm_glamo_gem_mmap {
-- 
1.6.5.rc2

From 8f75db8696f53ef68dae8db3f86d14793bce0591 Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Sat, 9 May 2009 12:19:01 +0100
Subject: [PATCH 06/19] This include doesn't belong here

---
 libdrm/glamo/glamo_bo.h |    1 -
 1 files changed, 0 insertions(+), 1 deletions(-)

diff --git a/libdrm/glamo/glamo_bo.h b/libdrm/glamo/glamo_bo.h
index c4a13a9..dcbe00a 100644
--- a/libdrm/glamo/glamo_bo.h
+++ b/libdrm/glamo/glamo_bo.h
@@ -37,7 +37,6 @@
 #include <stdio.h>
 #include <stdint.h>
 #include "glamo_track.h"
-#include <drm/glamo_drm.h>
 
 /* bo object */
 #define GLAMO_BO_FLAGS_MACRO_TILE  1
-- 
1.6.5.rc2

From 6d985fa7e8498fc4a16ccfae2d61da37daa38d25 Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Thu, 30 Jul 2009 00:40:37 +0100
Subject: [PATCH 07/19] First part of GEM memory mapping implementation

---
 libdrm/glamo/glamo_bo.h     |    8 ++--
 libdrm/glamo/glamo_bo_gem.c |   79 +++++++++++++++++++++++++++++--------------
 shared-core/glamo_drm.h     |   13 +++----
 3 files changed, 62 insertions(+), 38 deletions(-)

diff --git a/libdrm/glamo/glamo_bo.h b/libdrm/glamo/glamo_bo.h
index dcbe00a..8ef2a18 100644
--- a/libdrm/glamo/glamo_bo.h
+++ b/libdrm/glamo/glamo_bo.h
@@ -52,11 +52,11 @@ struct glamo_bo {
     uint32_t                    flags;
     unsigned                    cref;
 #ifdef GLAMO_BO_TRACK
-    struct glamo_track         *track;
+    struct glamo_track		*track;
 #endif
-    void                        *ptr;
-    struct glamo_bo_manager    *bom;
-    uint32_t                    space_accounted;
+    struct glamo_bo_manager	*bom;
+    void			*virtual;
+    uint32_t			space_accounted;
 };
 
 /* bo functions */
diff --git a/libdrm/glamo/glamo_bo_gem.c b/libdrm/glamo/glamo_bo_gem.c
index 6dc5a14..d53720e 100644
--- a/libdrm/glamo/glamo_bo_gem.c
+++ b/libdrm/glamo/glamo_bo_gem.c
@@ -49,6 +49,7 @@ struct glamo_bo_gem {
     struct glamo_bo   base;
     uint32_t          name;
     int               map_count;
+    void	      *virtual;
 };
 
 struct bo_manager_gem {
@@ -78,8 +79,8 @@ static struct glamo_bo *bo_open(struct glamo_bo_manager *bom,
     bo->base.alignment = alignment;
     bo->base.domains = domains;
     bo->base.flags = flags;
-    bo->base.ptr = NULL;
     bo->map_count = 0;
+    bo->virtual = NULL;
     if (handle) {
         struct drm_gem_open open_arg;
 
@@ -133,7 +134,7 @@ static struct glamo_bo *bo_unref(struct glamo_bo *bo)
         return bo;
     }
     if (bo_gem->map_count) {
-        munmap(bo->ptr, bo->size);
+        munmap(bo->virtual, bo->size);
     }
 
     /* close object */
@@ -146,28 +147,54 @@ static struct glamo_bo *bo_unref(struct glamo_bo *bo)
 
 static int bo_map(struct glamo_bo *bo, int write)
 {
-    struct glamo_bo_gem *bo_gem = (struct glamo_bo_gem*)bo;
-    struct drm_glamo_gem_mmap args;
-    int r;
+	struct glamo_bo_gem *bo_gem;
+	struct glamo_bo_manager *bufmgr;
+	int ret;
 
-    if (bo_gem->map_count++ != 0) {
-        return 0;
-    }
-    bo->ptr = NULL;
-    args.handle = bo->handle;
-    args.offset = 0;
-    args.size = (uint64_t)bo->size;
-    r = drmCommandWriteRead(bo->bom->fd,
-                            DRM_GLAMO_GEM_MMAP,
-                            &args,
-                            sizeof(args));
-    if (!r) {
-        bo->ptr = (void *)(unsigned long)args.addr_ptr;
-    } else {
-        fprintf(stderr, "error mapping %p 0x%08X (error = %d)\n",
-                bo, bo->handle, r);
-    }
-    return r;
+	bo_gem = (struct glamo_bo_gem *)bo;
+	bufmgr = (struct glamo_bo_manager*)bo->bom;
+
+	/* Get a mapping of the buffer if we haven't before. */
+	if (bo_gem->virtual == NULL) {
+
+		struct drm_glamo_gem_mmap mmap_arg;
+
+		memset(&mmap_arg, 0, sizeof(mmap_arg));
+		mmap_arg.handle = bo->handle;
+
+		/* Get the fake offset back... */
+		ret = ioctl(bufmgr->fd, DRM_IOCTL_GLAMO_GEM_MMAP, &mmap_arg);
+		if (ret != 0) {
+			fprintf(stderr,
+			        "%s:%d: Error preparing BO map %d (%d): %s .\n",
+			        __FILE__, __LINE__,
+			        bo->handle, bo_gem->name,
+			        strerror(errno));
+			return ret;
+		}
+		fprintf(stderr, "offset=%8llx\n",
+		        (long long int)mmap_arg.offset);
+
+		/* and mmap it */
+		bo_gem->virtual = mmap(0, bo->size, PROT_READ | PROT_WRITE,
+		                       MAP_SHARED, bufmgr->fd,
+		                       mmap_arg.offset);
+		if (bo_gem->virtual == MAP_FAILED) {
+			fprintf(stderr,
+			        "%s:%d: Error mapping buffer %d (%d): %s .\n",
+			        __FILE__, __LINE__,
+			        bo->handle, bo_gem->name,
+			        strerror(errno));
+			return errno;
+		}
+	}
+
+	bo->virtual = bo_gem->virtual;
+
+	printf("bo_map: %d (%d) -> %p\n", bo->handle, bo_gem->name,
+	       bo_gem->virtual);
+
+	return 0;
 }
 
 static int bo_unmap(struct glamo_bo *bo)
@@ -177,8 +204,8 @@ static int bo_unmap(struct glamo_bo *bo)
     if (--bo_gem->map_count > 0) {
         return 0;
     }
-    munmap(bo->ptr, bo->size);
-    bo->ptr = NULL;
+    munmap(bo->virtual, bo->size);
+    bo->virtual = NULL;
     return 0;
 }
 
diff --git a/shared-core/glamo_drm.h b/shared-core/glamo_drm.h
index 1b585e4..c0bc0e5 100644
--- a/shared-core/glamo_drm.h
+++ b/shared-core/glamo_drm.h
@@ -65,11 +65,11 @@
 #define DRM_IOCTL_GLAMO_GEM_WAIT_RENDERING DRM_IOW(DRM_COMMAND_BASE + DRM_GLAMO_GEM_WAIT_RENDERING, struct drm_glamo_gem_wait_rendering)
 
 typedef struct drm_glamo_cmd_buffer {
-	int bufsz;		/* Size of buffer, in bytes */
+	unsigned int bufsz;	/* Size of buffer, in bytes */
 	char __user *buf;	/* Buffer of stuff to go onto the ring buffer */
-	int *obj_pos;		/* Offsets (in bytes) at which to put objs */
+	unsigned int *obj_pos;	/* Offsets (in bytes) at which to put objs */
 	uint32_t *objs;		/* List of buffer object (handles) to use */
-	int nobjs;		/* Number of objects referenced */
+	unsigned int nobjs;	/* Number of objects referenced */
 	int nbox;
 	struct drm_clip_rect __user *boxes;
 } drm_glamo_cmd_buffer_t;
@@ -88,11 +88,8 @@ struct drm_glamo_gem_create {
 };
 
 struct drm_glamo_gem_mmap {
-	uint32_t handle;
-	uint32_t pad;
-	uint64_t offset;
-	uint64_t size;
-	uint64_t addr_ptr;
+	uint32_t handle;	/* Handle goes in... */
+	uint64_t offset;	/* ...offset comes out */
 };
 
 struct drm_glamo_gem_wait_rendering {
-- 
1.6.5.rc2

From a892c23459669c5e1c280cd6779df3b79f336706 Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Fri, 31 Jul 2009 00:54:19 +0100
Subject: [PATCH 08/19] Don't forget to #include config.h

This is definitely needed, to help handle large files.
---
 libdrm/glamo/glamo_bo_gem.c |    5 +++++
 1 files changed, 5 insertions(+), 0 deletions(-)

diff --git a/libdrm/glamo/glamo_bo_gem.c b/libdrm/glamo/glamo_bo_gem.c
index d53720e..7ac01f5 100644
--- a/libdrm/glamo/glamo_bo_gem.c
+++ b/libdrm/glamo/glamo_bo_gem.c
@@ -31,6 +31,11 @@
  *      Jérôme Glisse <glisse@freedesktop.org>
  *      Thomas White <taw@bitwiz.org.uk>
  */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
 #include <stdio.h>
 #include <stdint.h>
 #include <stdlib.h>
-- 
1.6.5.rc2

From dba796b3b11c670c39242c80e3c2f6666864acf7 Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Tue, 4 Aug 2009 20:00:19 +0100
Subject: [PATCH 09/19] Set bo_gem->virtual = NULL on unmap

---
 libdrm/glamo/glamo_bo_gem.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/libdrm/glamo/glamo_bo_gem.c b/libdrm/glamo/glamo_bo_gem.c
index 7ac01f5..b5bbc18 100644
--- a/libdrm/glamo/glamo_bo_gem.c
+++ b/libdrm/glamo/glamo_bo_gem.c
@@ -211,6 +211,7 @@ static int bo_unmap(struct glamo_bo *bo)
     }
     munmap(bo->virtual, bo->size);
     bo->virtual = NULL;
+    bo_gem->virtual = NULL;
     return 0;
 }
 
-- 
1.6.5.rc2

From 9d4b317a5b434e5ef574b6cdc8f0804f1acd1c9f Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Tue, 4 Aug 2009 20:24:32 +0100
Subject: [PATCH 10/19] Single point of truth for the virtual address

---
 libdrm/glamo/glamo_bo_gem.c |   18 ++++--------------
 1 files changed, 4 insertions(+), 14 deletions(-)

diff --git a/libdrm/glamo/glamo_bo_gem.c b/libdrm/glamo/glamo_bo_gem.c
index b5bbc18..43d847d 100644
--- a/libdrm/glamo/glamo_bo_gem.c
+++ b/libdrm/glamo/glamo_bo_gem.c
@@ -54,7 +54,6 @@ struct glamo_bo_gem {
     struct glamo_bo   base;
     uint32_t          name;
     int               map_count;
-    void	      *virtual;
 };
 
 struct bo_manager_gem {
@@ -85,7 +84,7 @@ static struct glamo_bo *bo_open(struct glamo_bo_manager *bom,
     bo->base.domains = domains;
     bo->base.flags = flags;
     bo->map_count = 0;
-    bo->virtual = NULL;
+    bo->base.virtual = NULL;
     if (handle) {
         struct drm_gem_open open_arg;
 
@@ -160,7 +159,7 @@ static int bo_map(struct glamo_bo *bo, int write)
 	bufmgr = (struct glamo_bo_manager*)bo->bom;
 
 	/* Get a mapping of the buffer if we haven't before. */
-	if (bo_gem->virtual == NULL) {
+	if (bo->virtual == NULL) {
 
 		struct drm_glamo_gem_mmap mmap_arg;
 
@@ -177,14 +176,11 @@ static int bo_map(struct glamo_bo *bo, int write)
 			        strerror(errno));
 			return ret;
 		}
-		fprintf(stderr, "offset=%8llx\n",
-		        (long long int)mmap_arg.offset);
-
 		/* and mmap it */
-		bo_gem->virtual = mmap(0, bo->size, PROT_READ | PROT_WRITE,
+		bo->virtual = mmap(0, bo->size, PROT_READ | PROT_WRITE,
 		                       MAP_SHARED, bufmgr->fd,
 		                       mmap_arg.offset);
-		if (bo_gem->virtual == MAP_FAILED) {
+		if (bo->virtual == MAP_FAILED) {
 			fprintf(stderr,
 			        "%s:%d: Error mapping buffer %d (%d): %s .\n",
 			        __FILE__, __LINE__,
@@ -194,11 +190,6 @@ static int bo_map(struct glamo_bo *bo, int write)
 		}
 	}
 
-	bo->virtual = bo_gem->virtual;
-
-	printf("bo_map: %d (%d) -> %p\n", bo->handle, bo_gem->name,
-	       bo_gem->virtual);
-
 	return 0;
 }
 
@@ -211,7 +202,6 @@ static int bo_unmap(struct glamo_bo *bo)
     }
     munmap(bo->virtual, bo->size);
     bo->virtual = NULL;
-    bo_gem->virtual = NULL;
     return 0;
 }
 
-- 
1.6.5.rc2

From 81f89d780a42d1d0cca06718a1599000fec87995 Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Tue, 4 Aug 2009 20:38:39 +0100
Subject: [PATCH 11/19] Formatting and copyright notices

---
 libdrm/glamo/glamo_bo_gem.c |  268 ++++++++++++++++++++++++-------------------
 1 files changed, 152 insertions(+), 116 deletions(-)

diff --git a/libdrm/glamo/glamo_bo_gem.c b/libdrm/glamo/glamo_bo_gem.c
index 43d847d..481481b 100644
--- a/libdrm/glamo/glamo_bo_gem.c
+++ b/libdrm/glamo/glamo_bo_gem.c
@@ -1,5 +1,8 @@
 /*
  * Copyright © 2009 Thomas White
+ *
+ * Based on radeon_bo_gem.c, to which the following notice applies:
+ *
  * Copyright © 2008 Dave Airlie
  * Copyright © 2008 Jérôme Glisse
  * All Rights Reserved.
@@ -29,7 +32,43 @@
  * Authors:
  *      Dave Airlie
  *      Jérôme Glisse <glisse@freedesktop.org>
- *      Thomas White <taw@bitwiz.org.uk>
+ *
+ *
+ * Memory mapping functions are based on intel_bufmgr_gem.c, to which the
+ * following notice applies:
+ *
+ * Copyright © 2007 Red Hat Inc.
+ * Copyright © 2007 Intel Corporation
+ * Copyright 2006 Tungsten Graphics, Inc., Bismarck, ND., USA
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDERS, AUTHORS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ *
+ **************************************************************************/
+/*
+ * Authors: Thomas Hellström <thomas-at-tungstengraphics-dot-com>
+ *          Keith Whitwell <keithw-at-tungstengraphics-dot-com>
+ *	    Eric Anholt <eric@anholt.net>
+ *	    Dave Airlie <airlied@linux.ie>
  */
 
 #ifdef HAVE_CONFIG_H
@@ -51,13 +90,13 @@
 #include "glamo_bo_gem.h"
 
 struct glamo_bo_gem {
-    struct glamo_bo   base;
-    uint32_t          name;
-    int               map_count;
+	struct glamo_bo   base;
+	uint32_t          name;
+	int               map_count;
 };
 
 struct bo_manager_gem {
-    struct glamo_bo_manager    base;
+	struct glamo_bo_manager    base;
 };
 
 static struct glamo_bo *bo_open(struct glamo_bo_manager *bom,
@@ -67,59 +106,58 @@ static struct glamo_bo *bo_open(struct glamo_bo_manager *bom,
                                  uint32_t domains,
                                  uint32_t flags)
 {
-    struct glamo_bo_gem *bo;
-    int r;
-
-    printf("bo_open, size=%i\n", size);fflush(stdout);
-
-    bo = (struct glamo_bo_gem*)calloc(1, sizeof(struct glamo_bo_gem));
-    if (bo == NULL) {
-        return NULL;
-    }
-
-    bo->base.bom = bom;
-    bo->base.handle = 0;
-    bo->base.size = size;
-    bo->base.alignment = alignment;
-    bo->base.domains = domains;
-    bo->base.flags = flags;
-    bo->map_count = 0;
-    bo->base.virtual = NULL;
-    if (handle) {
-        struct drm_gem_open open_arg;
-
-        memset(&open_arg, 0, sizeof(open_arg));
-        open_arg.name = handle;
-        r = ioctl(bom->fd, DRM_IOCTL_GEM_OPEN, &open_arg);
-        if (r != 0) {
-            free(bo);
-            return NULL;
-        }
-        bo->base.handle = open_arg.handle;
-        bo->base.size = open_arg.size;
-        bo->name = handle;
-    } else {
-        struct drm_glamo_gem_create args;
-
-        args.size = size;
-        args.alignment = alignment;
-        args.initial_domain = bo->base.domains;
-        args.no_backing_store = 0;
-        args.handle = 0;
-        r = drmCommandWriteRead(bom->fd, DRM_GLAMO_GEM_CREATE,
-                                &args, sizeof(args));
-        bo->base.handle = args.handle;
-        if (r) {
-            fprintf(stderr, "Failed to allocate :\n");
-            fprintf(stderr, "   size      : %d bytes\n", size);
-            fprintf(stderr, "   alignment : %d bytes\n", alignment);
-            fprintf(stderr, "   domains   : %d\n", bo->base.domains);
-            free(bo);
-            return NULL;
-        }
-    }
-    glamo_bo_ref((struct glamo_bo*)bo);
-    return (struct glamo_bo*)bo;
+	struct glamo_bo_gem *bo;
+	int r;
+
+	printf("bo_open, size=%i\n", size);fflush(stdout);
+
+	bo = (struct glamo_bo_gem*)calloc(1, sizeof(struct glamo_bo_gem));
+	if (bo == NULL) {
+		return NULL;
+	}
+
+	bo->base.bom = bom;
+	bo->base.handle = 0;
+	bo->base.size = size;
+	bo->base.alignment = alignment;
+	bo->base.domains = domains;
+	bo->base.flags = flags;
+	bo->map_count = 0;
+	bo->base.virtual = NULL;
+	if (handle) {
+		struct drm_gem_open open_arg;
+
+		memset(&open_arg, 0, sizeof(open_arg));
+		open_arg.name = handle;
+		r = ioctl(bom->fd, DRM_IOCTL_GEM_OPEN, &open_arg);
+		if (r != 0) {
+			free(bo);
+			return NULL;
+		}
+		bo->base.handle = open_arg.handle;
+		bo->base.size = open_arg.size;
+		bo->name = handle;
+	} else {
+		struct drm_glamo_gem_create args;
+
+		args.size = size;
+		args.alignment = alignment;
+		args.initial_domain = bo->base.domains;
+		args.no_backing_store = 0;
+		args.handle = 0;
+		r = drmCommandWriteRead(bom->fd, DRM_GLAMO_GEM_CREATE,
+		                        &args, sizeof(args));
+		bo->base.handle = args.handle;
+		if (r) {
+			fprintf(stderr, "Failed to allocate :\n");
+			fprintf(stderr, "   size      : %d bytes\n", size);
+			fprintf(stderr, "   alignment : %d bytes\n", alignment);
+			free(bo);
+			return NULL;
+		}
+	}
+	glamo_bo_ref((struct glamo_bo*)bo);
+	return (struct glamo_bo*)bo;
 }
 
 static void bo_ref(struct glamo_bo *bo)
@@ -128,25 +166,25 @@ static void bo_ref(struct glamo_bo *bo)
 
 static struct glamo_bo *bo_unref(struct glamo_bo *bo)
 {
-    struct glamo_bo_gem *bo_gem = (struct glamo_bo_gem*)bo;
-    struct drm_gem_close args;
-
-    if (bo == NULL) {
-        return NULL;
-    }
-    if (bo->cref) {
-        return bo;
-    }
-    if (bo_gem->map_count) {
-        munmap(bo->virtual, bo->size);
-    }
-
-    /* close object */
-    args.handle = bo->handle;
-    ioctl(bo->bom->fd, DRM_IOCTL_GEM_CLOSE, &args);
-    memset(bo_gem, 0, sizeof(struct glamo_bo_gem));
-    free(bo_gem);
-    return NULL;
+	struct glamo_bo_gem *bo_gem = (struct glamo_bo_gem*)bo;
+	struct drm_gem_close args;
+
+	if (bo == NULL) {
+		return NULL;
+	}
+	if (bo->cref) {
+		return bo;
+	}
+	if (bo_gem->map_count) {
+		munmap(bo->virtual, bo->size);
+	}
+
+	/* close object */
+	args.handle = bo->handle;
+	ioctl(bo->bom->fd, DRM_IOCTL_GEM_CLOSE, &args);
+	memset(bo_gem, 0, sizeof(struct glamo_bo_gem));
+	free(bo_gem);
+	return NULL;
 }
 
 static int bo_map(struct glamo_bo *bo, int write)
@@ -195,65 +233,63 @@ static int bo_map(struct glamo_bo *bo, int write)
 
 static int bo_unmap(struct glamo_bo *bo)
 {
-    struct glamo_bo_gem *bo_gem = (struct glamo_bo_gem*)bo;
-
-    if (--bo_gem->map_count > 0) {
-        return 0;
-    }
-    munmap(bo->virtual, bo->size);
-    bo->virtual = NULL;
-    return 0;
+	struct glamo_bo_gem *bo_gem = (struct glamo_bo_gem*)bo;
+
+	if (--bo_gem->map_count > 0) {
+		return 0;
+	}
+	munmap(bo->virtual, bo->size);
+	bo->virtual = NULL;
+	return 0;
 }
 
 static int bo_wait(struct glamo_bo *bo)
 {
-    struct drm_glamo_gem_wait_rendering args;
-    int ret;
-
-    args.handle = bo->handle;
-    do {
-        ret = drmCommandWriteRead(bo->bom->fd, DRM_GLAMO_GEM_WAIT_RENDERING,
-                                  &args, sizeof(args));
-    } while (ret == -EAGAIN);
-    return ret;
+	struct drm_glamo_gem_wait_rendering args;
+	int ret;
+
+	args.handle = bo->handle;
+	do {
+		ret = drmCommandWriteRead(bo->bom->fd,
+		                          DRM_GLAMO_GEM_WAIT_RENDERING,
+		                          &args, sizeof(args));
+	} while (ret == -EAGAIN);
+	return ret;
 }
 
 static struct glamo_bo_funcs bo_gem_funcs = {
-    bo_open,
-    bo_ref,
-    bo_unref,
-    bo_map,
-    bo_unmap,
-    bo_wait
+	bo_open,
+	bo_ref,
+	bo_unref,
+	bo_map,
+	bo_unmap,
+	bo_wait
 };
 
 struct glamo_bo_manager *glamo_bo_manager_gem_ctor(int fd)
 {
-    struct bo_manager_gem *bomg;
+	struct bo_manager_gem *bomg;
+
+	printf("Creating a new glamo_bo_manager\n");fflush(stdout);
 
-    printf("Creating a new glamo_bo_manager\n");fflush(stdout);
+	bomg = (struct bo_manager_gem*)calloc(1, sizeof(struct bo_manager_gem));
+	if (bomg == NULL) return NULL;
 
-    bomg = (struct bo_manager_gem*)calloc(1, sizeof(struct bo_manager_gem));
-    if (bomg == NULL) {
-        return NULL;
-    }
-    bomg->base.funcs = &bo_gem_funcs;
-    bomg->base.fd = fd;
-    return (struct glamo_bo_manager*)bomg;
+	bomg->base.funcs = &bo_gem_funcs;
+	bomg->base.fd = fd;
+	return (struct glamo_bo_manager*)bomg;
 }
 
 void glamo_bo_manager_gem_dtor(struct glamo_bo_manager *bom)
 {
-    struct bo_manager_gem *bomg = (struct bo_manager_gem*)bom;
+	struct bo_manager_gem *bomg = (struct bo_manager_gem*)bom;
 
-    if (bom == NULL) {
-        return;
-    }
-    free(bomg);
+	if (bom == NULL) return;
+	free(bomg);
 }
 
 uint32_t glamo_gem_name_bo(struct glamo_bo *bo)
 {
-    struct glamo_bo_gem *bo_gem = (struct glamo_bo_gem*)bo;
-    return bo_gem->name;
+	struct glamo_bo_gem *bo_gem = (struct glamo_bo_gem*)bo;
+	return bo_gem->name;
 }
-- 
1.6.5.rc2

From 7fe5fc41e9bd3324570b0459caa4838378a14cba Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Thu, 6 Aug 2009 17:08:06 +0100
Subject: [PATCH 12/19] Remove debug

This just removes a couple of debug messages which are no longer needed.
---
 libdrm/glamo/glamo_bo_gem.c |    4 ----
 1 files changed, 0 insertions(+), 4 deletions(-)

diff --git a/libdrm/glamo/glamo_bo_gem.c b/libdrm/glamo/glamo_bo_gem.c
index 481481b..048f477 100644
--- a/libdrm/glamo/glamo_bo_gem.c
+++ b/libdrm/glamo/glamo_bo_gem.c
@@ -109,8 +109,6 @@ static struct glamo_bo *bo_open(struct glamo_bo_manager *bom,
 	struct glamo_bo_gem *bo;
 	int r;
 
-	printf("bo_open, size=%i\n", size);fflush(stdout);
-
 	bo = (struct glamo_bo_gem*)calloc(1, sizeof(struct glamo_bo_gem));
 	if (bo == NULL) {
 		return NULL;
@@ -270,8 +268,6 @@ struct glamo_bo_manager *glamo_bo_manager_gem_ctor(int fd)
 {
 	struct bo_manager_gem *bomg;
 
-	printf("Creating a new glamo_bo_manager\n");fflush(stdout);
-
 	bomg = (struct bo_manager_gem*)calloc(1, sizeof(struct bo_manager_gem));
 	if (bomg == NULL) return NULL;
 
-- 
1.6.5.rc2

From dbc35395a209bf5c750044bfbb6037474dd6b555 Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Sun, 16 Aug 2009 18:07:57 +0100
Subject: [PATCH 13/19] Map counting fixes

---
 libdrm/glamo/glamo_bo_gem.c |   11 +++++++++++
 1 files changed, 11 insertions(+), 0 deletions(-)

diff --git a/libdrm/glamo/glamo_bo_gem.c b/libdrm/glamo/glamo_bo_gem.c
index 048f477..e76f9aa 100644
--- a/libdrm/glamo/glamo_bo_gem.c
+++ b/libdrm/glamo/glamo_bo_gem.c
@@ -174,6 +174,10 @@ static struct glamo_bo *bo_unref(struct glamo_bo *bo)
 		return bo;
 	}
 	if (bo_gem->map_count) {
+		fprintf(stderr, "Map count for %p isn't zero (=%i),"
+		                " so I am unmapping it (%p, %i)\n",
+		                bo_gem, bo_gem->map_count, bo->virtual,
+		                bo->size);
 		munmap(bo->virtual, bo->size);
 	}
 
@@ -224,6 +228,7 @@ static int bo_map(struct glamo_bo *bo, int write)
 			        strerror(errno));
 			return errno;
 		}
+		bo_gem->map_count++;
 	}
 
 	return 0;
@@ -233,6 +238,12 @@ static int bo_unmap(struct glamo_bo *bo)
 {
 	struct glamo_bo_gem *bo_gem = (struct glamo_bo_gem*)bo;
 
+	if ( bo_gem->map_count == 0 ) {
+		fprintf(stderr, "Not unmapping %p, because its map count"
+		                " is already zero.\n", bo_gem);
+		return 0;
+	}
+
 	if (--bo_gem->map_count > 0) {
 		return 0;
 	}
-- 
1.6.5.rc2

From 78ba95a6a67c8f28b1bf02a43b6acf4e7052358e Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Tue, 18 Aug 2009 21:11:37 +0100
Subject: [PATCH 14/19] Initialise cref to zero

---
 libdrm/glamo/glamo_bo_gem.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/libdrm/glamo/glamo_bo_gem.c b/libdrm/glamo/glamo_bo_gem.c
index e76f9aa..eaab76f 100644
--- a/libdrm/glamo/glamo_bo_gem.c
+++ b/libdrm/glamo/glamo_bo_gem.c
@@ -120,6 +120,7 @@ static struct glamo_bo *bo_open(struct glamo_bo_manager *bom,
 	bo->base.alignment = alignment;
 	bo->base.domains = domains;
 	bo->base.flags = flags;
+	bo->base.cref = 0;
 	bo->map_count = 0;
 	bo->base.virtual = NULL;
 	if (handle) {
-- 
1.6.5.rc2

From 2ca4c4d468bcb82c17020d8f43330af95471a903 Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Tue, 18 Aug 2009 21:11:49 +0100
Subject: [PATCH 15/19] Count mappings correctly

---
 libdrm/glamo/glamo_bo_gem.c |    2 +-
 1 files changed, 1 insertions(+), 1 deletions(-)

diff --git a/libdrm/glamo/glamo_bo_gem.c b/libdrm/glamo/glamo_bo_gem.c
index eaab76f..8b2838a 100644
--- a/libdrm/glamo/glamo_bo_gem.c
+++ b/libdrm/glamo/glamo_bo_gem.c
@@ -229,8 +229,8 @@ static int bo_map(struct glamo_bo *bo, int write)
 			        strerror(errno));
 			return errno;
 		}
-		bo_gem->map_count++;
 	}
+	bo_gem->map_count++;
 
 	return 0;
 }
-- 
1.6.5.rc2

From 86b31501a524c92c0bfb8b6b2e3d434e5cebc56f Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Thu, 20 Aug 2009 17:28:17 +0100
Subject: [PATCH 16/19] Tweak to buffer wait

---
 libdrm/glamo/glamo_bo_gem.c |    1 +
 shared-core/glamo_drm.h     |    1 +
 2 files changed, 2 insertions(+), 0 deletions(-)

diff --git a/libdrm/glamo/glamo_bo_gem.c b/libdrm/glamo/glamo_bo_gem.c
index 8b2838a..5bda1c4 100644
--- a/libdrm/glamo/glamo_bo_gem.c
+++ b/libdrm/glamo/glamo_bo_gem.c
@@ -259,6 +259,7 @@ static int bo_wait(struct glamo_bo *bo)
 	int ret;
 
 	args.handle = bo->handle;
+	args.have_handle = 1;
 	do {
 		ret = drmCommandWriteRead(bo->bom->fd,
 		                          DRM_GLAMO_GEM_WAIT_RENDERING,
diff --git a/shared-core/glamo_drm.h b/shared-core/glamo_drm.h
index c0bc0e5..ecf3550 100644
--- a/shared-core/glamo_drm.h
+++ b/shared-core/glamo_drm.h
@@ -94,6 +94,7 @@ struct drm_glamo_gem_mmap {
 
 struct drm_glamo_gem_wait_rendering {
 	uint32_t handle;
+	int have_handle;
 };
 
 struct drm_glamo_gem_pin {
-- 
1.6.5.rc2

From f0d702e479859b88cfeeec9974ad21f862a8c826 Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Fri, 21 Aug 2009 12:20:39 +0100
Subject: [PATCH 17/19] Remove log message when deleting with map_count > 0

This happens all the time with the latest DDX changes.  No point filling
the log up.
---
 libdrm/glamo/glamo_bo_gem.c |    4 ----
 1 files changed, 0 insertions(+), 4 deletions(-)

diff --git a/libdrm/glamo/glamo_bo_gem.c b/libdrm/glamo/glamo_bo_gem.c
index 5bda1c4..2fe3f82 100644
--- a/libdrm/glamo/glamo_bo_gem.c
+++ b/libdrm/glamo/glamo_bo_gem.c
@@ -175,10 +175,6 @@ static struct glamo_bo *bo_unref(struct glamo_bo *bo)
 		return bo;
 	}
 	if (bo_gem->map_count) {
-		fprintf(stderr, "Map count for %p isn't zero (=%i),"
-		                " so I am unmapping it (%p, %i)\n",
-		                bo_gem, bo_gem->map_count, bo->virtual,
-		                bo->size);
 		munmap(bo->virtual, bo->size);
 	}
 
-- 
1.6.5.rc2

From 57b317a9d53329369bc2773ae353c8c460a65188 Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Fri, 18 Sep 2009 09:33:48 +0100
Subject: [PATCH 18/19] GEM buffer naming stuff

---
 libdrm/glamo/glamo_bo_gem.c |   20 +++++++++++++++++++-
 libdrm/glamo/glamo_bo_gem.h |    3 ++-
 2 files changed, 21 insertions(+), 2 deletions(-)

diff --git a/libdrm/glamo/glamo_bo_gem.c b/libdrm/glamo/glamo_bo_gem.c
index 2fe3f82..2cd95c4 100644
--- a/libdrm/glamo/glamo_bo_gem.c
+++ b/libdrm/glamo/glamo_bo_gem.c
@@ -293,8 +293,26 @@ void glamo_bo_manager_gem_dtor(struct glamo_bo_manager *bom)
 	free(bomg);
 }
 
-uint32_t glamo_gem_name_bo(struct glamo_bo *bo)
+uint32_t glamo_gem_get_name(struct glamo_bo *bo)
 {
 	struct glamo_bo_gem *bo_gem = (struct glamo_bo_gem*)bo;
 	return bo_gem->name;
 }
+
+int glamo_gem_name_buffer(struct glamo_bo *bo, uint32_t *name)
+{
+	struct drm_gem_flink flink;
+	int r;
+
+	if ( !bo ) {
+		fprintf(stderr, "No buffer object!\n");
+		return -1;
+	}
+
+	flink.handle = bo->handle;
+	r = ioctl(bo->bom->fd, DRM_IOCTL_GEM_FLINK, &flink);
+	if (r) return r;
+
+	*name = flink.name;
+	return 0;
+}
diff --git a/libdrm/glamo/glamo_bo_gem.h b/libdrm/glamo/glamo_bo_gem.h
index 7230176..dbfe3c1 100644
--- a/libdrm/glamo/glamo_bo_gem.h
+++ b/libdrm/glamo/glamo_bo_gem.h
@@ -36,6 +36,7 @@
 
 struct glamo_bo_manager *glamo_bo_manager_gem_ctor(int fd);
 void glamo_bo_manager_gem_dtor(struct glamo_bo_manager *bom);
+int glamo_gem_name_buffer(struct glamo_bo *bo, uint32_t *name);
+uint32_t glamo_gem_get_name(struct glamo_bo *bo);
 
-uint32_t glamo_gem_name_bo(struct glamo_bo *bo);
 #endif
-- 
1.6.5.rc2

From 17e67f7b527be91669a78d73830ae8d474c65c49 Mon Sep 17 00:00:00 2001
From: Thomas White <taw@bitwiz.org.uk>
Date: Fri, 18 Sep 2009 09:34:27 +0100
Subject: [PATCH 19/19] Whitespace

---
 libdrm/glamo/glamo_bo_gem.h |    8 ++++----
 1 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/libdrm/glamo/glamo_bo_gem.h b/libdrm/glamo/glamo_bo_gem.h
index dbfe3c1..2f3e19b 100644
--- a/libdrm/glamo/glamo_bo_gem.h
+++ b/libdrm/glamo/glamo_bo_gem.h
@@ -1,8 +1,8 @@
-/* 
+/*
  * Copyright © 2008 Dave Airlie
  * Copyright © 2008 Jérôme Glisse
  * All Rights Reserved.
- * 
+ *
  * Permission is hereby granted, free of charge, to any person obtaining
  * a copy of this software and associated documentation files (the
  * "Software"), to deal in the Software without restriction, including
@@ -10,14 +10,14 @@
  * distribute, sub license, and/or sell copies of the Software, and to
  * permit persons to whom the Software is furnished to do so, subject to
  * the following conditions:
- * 
+ *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
  * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  * NON-INFRINGEMENT. IN NO EVENT SHALL THE COPYRIGHT HOLDERS, AUTHORS
  * AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE 
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  * USE OR OTHER DEALINGS IN THE SOFTWARE.
  *
  * The above copyright notice and this permission notice (including the
-- 
1.6.5.rc2

