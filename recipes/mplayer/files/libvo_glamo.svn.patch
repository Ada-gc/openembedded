Index: mplayer/Makefile
===================================================================
--- mplayer.orig/Makefile	(revision 29409)
+++ mplayer/Makefile	(working copy)
@@ -646,6 +650,7 @@
 SRCS_MPLAYER-$(VIDIX_SH_VEU)        += vidix/sh_veu_vid.c
 SRCS_MPLAYER-$(VIDIX_SIS)           += vidix/sis_vid.c vidix/sis_bridge.c
 SRCS_MPLAYER-$(VIDIX_UNICHROME)     += vidix/unichrome_vid.c
+SRCS_MPLAYER-$(GLAMO)         += libvo/vo_glamo.c drivers/libglamo/hw.c drivers/libglamo/blit.c drivers/libglamo/os.c drivers/libglamo/dma.c
 SRCS_MPLAYER-$(WII)           += libvo/vo_wii.c
 SRCS_MPLAYER-$(WIN32WAVEOUT)  += libao2/ao_win32.c
 SRCS_MPLAYER-$(WINVIDIX)      += libvo/vo_winvidix.c
Index: mplayer/libvo/video_out.c
===================================================================
--- mplayer.orig/libvo/video_out.c	(revision 29409)
+++ mplayer/libvo/video_out.c	(working copy)
@@ -132,6 +132,7 @@
 extern vo_functions_t video_out_quartz;
 extern vo_functions_t video_out_pnm;
 extern vo_functions_t video_out_md5sum;
+extern vo_functions_t video_out_glamo;
 
 const vo_functions_t* const video_out_drivers[] =
 {
@@ -274,6 +275,9 @@
 #ifdef CONFIG_MD5SUM
         &video_out_md5sum,
 #endif
+#ifdef CONFIG_GLAMO
+         &video_out_glamo,
+#endif
         NULL
 };
 
Index: mplayer/libvo/vo_glamo.c
===================================================================
--- mplayer.orig/libvo/vo_glamo.c	(revision 0)
+++ mplayer/libvo/vo_glamo.c	(revision 0)
@@ -0,0 +1,585 @@
+/*
+ * VIDIX driver for SMedia Glamo chips.
+ *
+ * Copyright (C) 2008 Andrzej Zaborowski  <balrog@zabor.org>
+ * Based on mpeg.c from glamo-utils, written by Chia-I Wu <olv@openmoko.org>
+ * Based on ffmpeg code by Fabrice Bellard.
+ *
+ * This file is part of MPlayer.
+ *
+ * MPlayer is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 or (at your option)
+ * version 3 of the License.
+ *
+ * MPlayer is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with MPlayer; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <time.h>
+#include <errno.h>
+#include <endian.h>
+
+#include "drivers/libglamo/glamo.h"
+#include "drivers/libglamo/hw.h"
+#include "drivers/libglamo/dma.h"
+#include "drivers/libglamo/blit.h"
+
+#include "config.h"
+#include "video_out.h"
+#include "video_out_internal.h"
+#include "mp_msg.h"
+#include "sub.h"
+#include "libmpdemux/mpeg4_hdr.h"
+#include "subopt-helper.h"
+
+#ifdef X11_FULLSCREEN
+#include "x11_common.h"
+#endif
+
+static const vo_info_t info = {
+	.name		= "SMedia Glamo decoder driver",
+	.short_name	= "glamo",
+	.author		= "Andrzej Zaborowski <balrog@zabor.org>",
+	.comment	= "Experimental, requires root"
+};
+
+const LIBVO_EXTERN(glamo)
+
+static uint16_t device_id = 0;
+
+static int query_format(uint32_t fourcc)
+{
+	if (device_id != 0x3362)
+		return 0;
+
+	switch (fourcc) {
+	/* MPEG1 stream for our MPEG engine.  */
+	case IMGFMT_MPEG4:
+	/* Decoded frames to blit onto the framebuffer using the 2D engine
+	 * and bypassing MPEG block.  */
+	case IMGFMT_I420:
+	case IMGFMT_YUY2:
+	case IMGFMT_RGB16:	/* TODO */
+		return VFCAP_CSP_SUPPORTED | VFCAP_CSP_SUPPORTED_BY_HW |
+			VFCAP_HWSCALE_UP | VFCAP_HWSCALE_DOWN | VFCAP_FLIP;
+	}
+
+	return 0;
+}
+
+static struct blit_ctx_s {
+	struct glamo_blit_manager *blit;
+	int x;
+	int y;
+	int width;
+	int height;
+	int out_width;
+	int out_height;
+	void *image_buf;
+
+	int blit_started;
+} bctx;
+static void (*decode_fn)(mp_image_t *mpi);
+
+static int draw_image(mp_image_t *mpi)
+{
+	struct glamo_blit_image *image;
+
+	decode_fn(mpi);
+
+	image = glamo_blit_new_image(bctx.blit, bctx.image_buf,
+			bctx.width, bctx.height);
+	bctx.blit_started = 1;
+	glamo_blit_show_image(bctx.blit, image, bctx.x, bctx.y,
+			bctx.out_width, bctx.out_height);
+	glamo_blit_destroy_image(bctx.blit, image);
+
+	return 0;
+}
+
+static void flip_page(void)
+{
+}
+
+static void draw_fb(int x0, int y0, int w, int h, unsigned char *src,
+		unsigned char *srca, int stride)
+{
+	/*
+	 * TODO: draw this before the final blit so that we get rotation
+	 * right.  This will require writing to bctx.image_buf which may
+	 * have already started being blitted.
+	 */
+	uint8_t *dst = (uint8_t *) glamo_fb +
+		 2 * (bctx.x + x0) + glamo_pitch * (bctx.y + y0);
+
+	if (bctx.blit_started) {
+		glamo_blit_wait(bctx.blit);
+		bctx.blit_started = 0;
+	}
+
+	vo_draw_alpha_rgb16(w, h, src, srca, stride, dst, glamo_pitch);
+}
+
+static void draw_osd(void)
+{
+	vo_draw_text(bctx.out_width, bctx.out_height, draw_fb);
+}
+
+static int draw_slice(uint8_t *srcimg[], int stride[],
+		int w, int h, int x0, int y0)
+{
+	return 0;
+}
+
+static int draw_frame(uint8_t *src[])
+{
+	return VO_ERROR; 
+}
+
+static void check_events(void)
+{
+#if 0
+	int e = vo_check_events();
+
+	mp_msg(MSGT_VO, MSGL_INFO, "got event %x\n", e);
+#endif
+}
+
+static int get_image(mp_image_t *mpi)
+{
+	mp_msg(MSGT_VO, MSGL_INFO, "get_image called\n");
+	/* TODO: for the non-MPEG4 IMGFMTs return addresses directly
+	 * in the Glamo's mmaped memory.  For IMGFMT_MPEG4 we don't gain
+	 * anything because the vd_hwmp4 will have to copy all the data
+	 * anyway.  */
+
+	return VO_NOTIMPL;
+}
+
+static int glamo_window(mp_win_t *win)
+{
+	bctx.x = win->x;
+	bctx.y = win->y;
+	bctx.out_width = win->w;
+	bctx.out_height = win->h;
+
+	return VO_TRUE;
+}
+
+static int control(uint32_t request, void *data, ...)
+{
+	switch (request) {
+	case VOCTRL_QUERY_FORMAT:
+		return query_format(*(uint32_t *) data);
+	case VOCTRL_DRAW_IMAGE:
+		return draw_image((mp_image_t *) data);
+	case VOCTRL_GET_IMAGE:
+		return get_image(data);
+
+	/* "xover" support */
+	case VOCTRL_XOVERLAY_SUPPORT:
+	case VOCTRL_XOVERLAY_SET_COLORKEY:
+		return VO_TRUE;
+	case VOCTRL_XOVERLAY_SET_WIN:
+		return glamo_window((mp_win_t *) data);
+	}
+
+	return VO_NOTIMPL;
+}
+
+static strarg_t fb_path = { 0, NULL };
+static int mpeg_db_thr[2] = { 0, 0 };
+static int mpeg_deblock;
+static int angle = 0;
+static enum glamo_blit_rotation rotate;
+static int busywait = 0;
+
+static opt_t glamo_subopts[] = {
+	{ "deblock1", OPT_ARG_INT,  &mpeg_db_thr[0], (opt_test_f) int_pos, 0 },
+	{ "deblock2", OPT_ARG_INT,  &mpeg_db_thr[1], (opt_test_f) int_pos, 0 },
+	{ "rotate",   OPT_ARG_INT,  &angle,          (opt_test_f) int_pos, 0 },
+	{ "fb",       OPT_ARG_STR,  &fb_path,        NULL,                 0 },
+	{ "nosleep",  OPT_ARG_BOOL, &busywait,       NULL,                 0 },
+
+	{ 0, 0, 0, 0, 0 }
+};
+
+static int preinit(const char *arg)
+{
+	uint16_t dev_id, rev_id;
+	int err;
+
+	err = subopt_parse(arg, glamo_subopts);
+	if (err)
+		return err;
+
+	err = glamo_os_init(fb_path.str);
+	if (err)
+		return err;
+
+	mpeg_deblock = mpeg_db_thr[0] || mpeg_db_thr[1];
+
+	switch (angle % 360) {
+	case 0:
+		rotate = GLAMO_BLIT_ROTATION_0;
+		break;
+	case 90:
+		rotate = GLAMO_BLIT_ROTATION_90;
+		break;
+	case 180:
+		rotate = GLAMO_BLIT_ROTATION_180;
+		break;
+	case 270:
+		rotate = GLAMO_BLIT_ROTATION_270;
+		break;
+	default:
+		mp_msg(MSGT_VO, MSGL_ERR,
+				"unsupported angle: %i deg\n", angle);
+		exit(-1);
+	}
+
+	dev_id = GLAMO_IN_REG(GLAMO_REG_DEVICE_ID);
+	rev_id = GLAMO_IN_REG(GLAMO_REG_REVISION_ID);
+	glamo_os_finish();
+
+	switch (dev_id) {
+	case 0x3600:
+	case 0x3650:
+	case 0x3700:
+		device_id = 0x3362;
+		dev_id = 0x3000 | (dev_id >> 4);
+		break;
+	default:
+		return -ENODEV;
+	}
+
+	mp_msg(MSGT_VO, MSGL_INFO,
+			"Found SMedia Glamo %x, with %x core, rev A%i\n",
+			device_id, dev_id, rev_id);
+	return 0;
+}
+
+void inline st32le(void *ptr, uint32_t value)
+{
+#if __BYTE_ORDER == __LITTLE_ENDIAN
+# if 0
+	memcpy(ptr, &value, 4);
+# else
+	*(uint32_t *) ptr = value;
+# endif
+#else
+	((uint8_t *) ptr)[0] = (value >>  0) & 0xff;
+	((uint8_t *) ptr)[1] = (value >>  8) & 0xff;
+	((uint8_t *) ptr)[2] = (value >> 16) & 0xff;
+	((uint8_t *) ptr)[3] = (value >> 24) & 0xff;
+#endif
+}
+
+static void yield1(void)
+{
+	const struct timespec req = { 0, 500000 };
+
+	if (!busywait)
+		nanosleep(&req, 0);
+}
+
+static void glamo_mpeg_wait(void)
+{
+	uint16_t status;
+
+	while ((status = GLAMO_IN_REG(GLAMO_REG_MPEG_DEC_STATUS)) & 0x3000)
+		yield1();
+
+	if (status & 0x3c0)
+		mp_msg(MSGT_VO, MSGL_ERR, "status = [%s%s%s%s%s%s%s ]\n",
+				(status & 0x000f) ? " ErrorOldFrame" : "",
+				(status & 0x0030) ? " OldFrameIndex" : "",
+				(status & 0x03c0) ? " ErrorThisFrame" : "",
+				(status & 0x0c00) ? " ThisFrameIndex" : "",
+				(status & 0x1000) ? " QueueFull" : "",
+				(status & 0x2000) ? " EngineBusy" : "",
+				(status & 0xc000) ? " DebugInfo" : "");
+}
+
+static void glamo_isp_wait(void)
+{
+	uint16_t status;
+
+	while ((status = GLAMO_IN_REG(GLAMO_REG_ISP_EN1)) &
+			GLAMO_ISP_EN1_FIRE_CAP)
+		yield1();
+
+	while ((status = GLAMO_IN_REG(GLAMO_REG_ISP_STATUS)) & 1)
+		yield1();
+
+	bctx.blit_started = 0;
+}
+
+struct yuv_buffer {
+	unsigned int y;
+	unsigned int u;
+	unsigned int v;
+};
+
+struct mpeg_ctx_s {
+	int width;
+	int height;
+
+	int cycle;
+	int reg_special;
+
+	unsigned int buf_in;
+	struct yuv_buffer buf_out[2];
+	unsigned int buf_dc;
+	unsigned int buf_ac;
+
+	struct glamo_dma_manager *dma;
+} mctx;
+
+static void decode_null(mp_image_t *mpi)
+{
+	uint8_t *vram;
+
+	vram = (uint8_t *) glamo_fb + mctx.buf_out->y;
+	memcpy(vram, mpi->planes[0], mctx.width * mctx.height);
+	vram = (uint8_t *) glamo_fb + mctx.buf_out->u;
+	memcpy(vram, mpi->planes[1], (mctx.width * mctx.height) >> 2);
+	vram = (uint8_t *) glamo_fb + mctx.buf_out->v;
+	memcpy(vram, mpi->planes[2], (mctx.width * mctx.height) >> 2);
+}
+
+static void decode_mpeg(mp_image_t *mpi)
+{
+	mp_mpeg_header_t *picture = (void *) mpi->planes[1];
+	uint32_t glamo_mpeg_header;
+	uint8_t *vram;
+	int cycle = (mctx.cycle ++) & 1;
+
+	/* Wait until ready */
+	glamo_mpeg_wait();
+
+	glamo_hw_engine_reset(GLAMO_ENGINE_MPEG);
+
+	if (mctx.reg_special != picture->vol.time_bits) {
+		/* XXX: for Short Header always equals 8? */
+		mctx.reg_special = picture->vol.time_bits;
+		GLAMO_OUT_REG(GLAMO_REG_MPEG_SPECIAL,
+				(mctx.reg_special << 8) |
+				(mpeg_deblock << 3));
+	}
+
+	glamo_mpeg_header =
+		(picture->vop.start_bits << 0) |
+		(picture->vop.rounding << 3) |
+		((picture->vop.fcode ?
+		  picture->vop.fcode - 1 : 0) << 4) |
+		(picture->vop.coding_type << 7) |
+		(picture->vop.qscale << 8) |
+		(picture->vop.intra_dc_thr << 13) |
+		(cycle << 20) | ((!cycle) << 22);
+
+	/* Upload the frame.
+	 *
+	 * TODO: use CPU's DMA for this possibly,
+	 * TODO: seems that the memcpy size cannot exceed 64K.
+	 * TODO: if an error was detected in glamo_mpeg_wait(), the
+	 * next frame must be based on the previous frame instead of the
+	 * current erroneous one, as a form of recovery.  We will need
+	 * more buffers for this.
+	 */
+	vram = (uint8_t *) glamo_fb + mctx.buf_in;
+	st32le(vram, glamo_mpeg_header);
+	memcpy(vram + 4, picture->data_start, picture->data_size);
+	vram += 4 + picture->data_size;
+	/* MPEG terminating header */
+	st32le(vram, 0xb6010000);
+
+	/* Wait until ready so we can start the blit quickly */
+	if (bctx.blit_started)
+		glamo_isp_wait();
+
+	/* Decode! */
+	GLAMO_OUT_REG(GLAMO_REG_MPEG_DEC_IN_ADDRL,
+			(mctx.buf_in >> 1) & 0xffff);
+	GLAMO_OUT_REG(GLAMO_REG_MPEG_DEC_IN_ADDRH,
+			((mctx.buf_in >> 17) & 0x3f) | (cycle << 8));
+
+	bctx.image_buf = (void *) mctx.buf_out[!cycle].y;
+}
+
+#define OUT_ADDR(reg, addr)	do { 					\
+		GLAMO_OUT_REG((reg),     ((addr) >>  1) & 0xffff);	\
+		GLAMO_OUT_REG((reg) + 2, ((addr) >> 17) & 0x3f);	\
+	} while (0)
+
+static inline int binlog2(int num)
+{
+	int log;
+
+	for (log = 0; num > (1 << log); log ++);
+
+	return log;
+}
+
+static int config(uint32_t width, uint32_t height, uint32_t d_width,
+		uint32_t d_height, uint32_t flags, char *title,
+		uint32_t fourcc)
+{
+	int err;
+	int pos;
+	int pitch;
+	int num_mbs;
+
+	if (!vo_config_count) {
+		err = glamo_os_init(fb_path.str);
+		if (err)
+			return -err;
+
+		GLAMO_OUT_REG(GLAMO_REG_CLOCK_ISP, 0x0000);
+		GLAMO_OUT_REG(GLAMO_REG_CLOCK_ISP, 0x0000);
+		GLAMO_OUT_REG(GLAMO_REG_CLOCK_MPEG, 0x0000);
+		GLAMO_OUT_REG(GLAMO_REG_CLOCK_MPEG, 0x0000);
+		usleep(10000);
+		glamo_hw_engine_reset(GLAMO_ENGINE_MPEG);
+
+		glamo_hw_engine_enable(GLAMO_ENGINE_MPEG);
+		mctx.dma = glamo_dma_new(GLAMO_DMA_MODE_MMIO);
+	}
+
+	if (vo_config_count) {
+		glamo_blit_destroy(bctx.blit);
+	}
+
+	mctx.width = width;
+	mctx.height = height;
+
+	bctx.width = width;
+	bctx.height = height;
+	bctx.out_width = d_width;
+	bctx.out_height = d_height;
+	if (!(flags & VOFLAG_XOVERLAY_SUB_VO))
+		bctx.x = bctx.y = 0;
+
+	/* TODO: only use GLAMO_VRAM_MPEG for MPEGs */
+	/* Three planes for the output from the decoder and input to BES.  */
+	pos = GLAMO_VRAM_MPEG;
+	mctx.buf_out->y = pos;
+	pos += width * height;
+	mctx.buf_out->u = pos;
+	pos += (width * height) >> 2;
+	mctx.buf_out->v = pos;
+	pos += (width * height) >> 2;
+
+	bctx.image_buf = (void *) mctx.buf_out->y;
+	bctx.blit_started = 0;
+
+	switch (fourcc) {
+	case IMGFMT_MPEG4:
+		/* TODO: more checks */
+		if (((width > 640 || height > 480) &&
+					(width > 480 && height > 640)) ||
+				((width | height) & 15)) {
+			mp_msg(MSGT_VO, MSGL_ERR, "bad image size\n");
+			exit(-1);
+		}
+
+		decode_fn = decode_mpeg;
+
+		mctx.reg_special = -1;
+
+		/* Three planes for decoder output swap buffer.  */
+		mctx.buf_out[1].y = pos;
+		pos += width * height;
+		mctx.buf_out[1].u = pos;
+		pos += (width * height) >> 2;
+		mctx.buf_out[1].v = pos;
+		pos += (width * height) >> 2;
+
+		/* DC prediction buffer */
+		mctx.buf_dc = pos;
+		pos += (width >> 4) * 6;
+
+		/* AC prediction buffer */
+		mctx.buf_ac = pos;
+		pos += (width >> 4) * 4 * 12;
+
+		/* TODO: allocate deblocking framebuffers here */
+
+		/* MPEG data buffer */
+		mctx.buf_in = pos;
+
+		bctx.blit = glamo_blit_new(mctx.dma, GLAMO_BLIT_FORMAT_I420);
+
+		OUT_ADDR(GLAMO_REG_MPEG_DC_ADDRL, mctx.buf_dc);
+		OUT_ADDR(GLAMO_REG_MPEG_AC_ADDRL, mctx.buf_ac);
+
+		OUT_ADDR(GLAMO_REG_MPEG_DEC_OUT0_Y_ADDRL, mctx.buf_out[0].y);
+		OUT_ADDR(GLAMO_REG_MPEG_DEC_OUT0_U_ADDRL, mctx.buf_out[0].u);
+		OUT_ADDR(GLAMO_REG_MPEG_DEC_OUT0_V_ADDRL, mctx.buf_out[0].v);
+		OUT_ADDR(GLAMO_REG_MPEG_DEC_OUT1_Y_ADDRL, mctx.buf_out[1].y);
+		OUT_ADDR(GLAMO_REG_MPEG_DEC_OUT1_U_ADDRL, mctx.buf_out[1].u);
+		OUT_ADDR(GLAMO_REG_MPEG_DEC_OUT1_V_ADDRL, mctx.buf_out[1].v);
+
+		pitch = width;
+		GLAMO_OUT_REG(GLAMO_REG_MPEG_DEC_WIDTH,
+				(width >> 4) | ((pitch >> 1) << 7));
+
+		/* Yes, UV pitch is left shifted by 8 bits.  */
+		pitch = width >> 1;
+		GLAMO_OUT_REG(GLAMO_REG_MPEG_DEC_HEIGHT,
+				(height >> 4) | ((pitch >> 1) << 8));
+
+		num_mbs = binlog2((width >> 4) * (height >> 4)) + 1;
+		GLAMO_OUT_REG(GLAMO_REG_MPEG_SAFE_1, num_mbs << 11);
+		GLAMO_OUT_REG(GLAMO_REG_MPEG_SAFE_3, 0xf00 | (1 << 15));
+		GLAMO_OUT_REG(GLAMO_REG_MPEG_DEBLK_THRESHOLD,
+				mpeg_db_thr[0] | (mpeg_db_thr[1] << 8));
+		break;
+
+	case IMGFMT_I420:
+		decode_fn = decode_null;
+
+		bctx.blit = glamo_blit_new(mctx.dma, GLAMO_BLIT_FORMAT_I420);
+		break;
+
+	case IMGFMT_YUY2:
+		decode_fn = decode_null;
+
+		bctx.blit = glamo_blit_new(mctx.dma, GLAMO_BLIT_FORMAT_YUY2);
+		break;
+
+	default:
+		return EINVAL;
+	}
+
+	glamo_blit_rotate(bctx.blit, rotate);
+
+	return 0;
+}
+
+static void uninit(void) {
+	if (!vo_config_count)
+		return;
+
+	glamo_blit_destroy(bctx.blit);
+	glamo_dma_destroy(mctx.dma);
+
+	glamo_hw_engine_disable(GLAMO_ENGINE_MPEG);
+	glamo_os_finish();
+}
Index: mplayer/configure
===================================================================
--- mplayer.orig/configure	(revision 29409)
+++ mplayer/configure	(working copy)
@@ -408,6 +409,7 @@
   --disable-yuv4mpeg	   disable yuv4mpeg video output [enable]
   --disable-corevideo      disable CoreVideo video output [autodetect]
   --disable-quartz         disable Quartz video output [autodetect]
+  --disable-glamo        disable Glamo accelerated video output [enable]
 
 Audio output:
   --disable-alsa         disable ALSA audio output [autodetect]
@@ -701,6 +703,7 @@
 _directfb=auto
 _zr=auto
 _bl=no
+_glamo=yes
 _largefiles=yes
 #language=en
 _shm=auto
@@ -1210,6 +1213,8 @@
   --disable-zr)		_zr=no		;;
   --enable-bl)		_bl=yes		;;
   --disable-bl)		_bl=no		;;
+  --enable-glamo)	_glamo=yes	;;
+  --disable-glamo)	_glamo=no	;;
   --enable-mtrr)	_mtrr=yes	;;
   --disable-mtrr)	_mtrr=no	;;
   --enable-largefiles)	_largefiles=yes	;;
@@ -7331,6 +7338,16 @@
 fi
 echores "$_zr"
 
+echocheck "glamo"
+if test "$_glamo" = yes ; then
+  def_glamo='#define CONFIG_GLAMO 1'
+  _vomodules="glamo $_vomodules"
+else
+  def_glamo='#undef CONFIG_GLAMO'
+  _novomodules="glamo $_novomodules"
+fi
+echores "$_glamo"
+
 # mencoder requires (optional) those libs: libmp3lame
 if test "$_mencoder" != no ; then
 
@@ -8236,6 +8236,7 @@
 FAAD_INTERNAL = $_faad_internal
 FASTMEMCPY = $_fastmemcpy
 FBDEV = $_fbdev
+GLAMO = $_glamo
 FREETYPE = $_freetype
 FTP = $_ftp
 GIF = $_gif
@@ -8756,6 +8775,7 @@
 $def_gif_tvt_hack
 $def_gl
 $def_gl_win32
+$def_glamo
 $def_ivtv
 $def_jpeg
 $def_kva
Index: mplayer/DOCS/tech/libvo.txt
===================================================================
--- mplayer.orig/DOCS/tech/libvo.txt	(revision 29409)
+++ mplayer/DOCS/tech/libvo.txt	(working copy)
@@ -27,7 +27,7 @@
       VOCTRL_DRAW_IMAGE, VOCTRL_FULLSCREEN, VOCTRL_UPDATE_SCREENINFO
       should be implemented):
 	 VOCTRL_QUERY_FORMAT  -  queries if a given pixelformat is supported.
-	        It also returns various flags decsirbing the capabilities
+	        It also returns various flags describing the capabilities
 		of the driver with teh given mode. for the flags, see
 		file vfcaps.h !
 		the most important flags, every driver must properly report
Index: mplayer/etc/input.conf
===================================================================
--- mplayer.orig/etc/input.conf	(revision 29409)
+++ mplayer/etc/input.conf	(working copy)
@@ -167,3 +167,7 @@
 
 #? seek_chapter -1      # skip to previous dvd chapter
 #? seek_chapter +1      #         next
+
+# Freerunner Optimizations
+MOUSE_BTN0 vo_fullscreen
+MOUSE_BTN0_DBL q
Index: mplayer/drivers/libglamo/hw.c
===================================================================
--- mplayer.orig/drivers/libglamo/hw.c	(revision 0)
+++ mplayer/drivers/libglamo/hw.c	(revision 0)
@@ -0,0 +1,227 @@
+/*
+ * Library's hardware interface.
+ *
+ * Copyright (C) 2007 OpenMoko, Inc.
+ * Author: Chia-I Wu <olv@openmoko.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 or
+ * (at your option) version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <stdio.h>
+#include <unistd.h>
+#include "glamo.h"
+#include "hw.h"
+
+#define STATUS_ENABLED	0x1
+static int engine_status[GLAMO_ENGINE_2D + 1];
+
+void glamo_hw_engine_reset(enum glamo_engine engine)
+{
+	int reg, mask;
+
+	if (!(engine_status[engine] & STATUS_ENABLED))
+		return;
+
+	switch (engine) {
+	case GLAMO_ENGINE_MPEG:
+		reg = GLAMO_REG_CLOCK_MPEG;
+		mask = GLAMO_CLOCK_MPEG_DEC_RESET;
+		break;
+	case GLAMO_ENGINE_ISP:
+		reg = GLAMO_REG_CLOCK_ISP;
+		mask = GLAMO_CLOCK_ISP2_RESET;
+		break;
+	case GLAMO_ENGINE_CMDQ:
+		reg = GLAMO_REG_CLOCK_2D;
+		mask = GLAMO_CLOCK_2D_CMDQ_RESET;
+		break;
+	case GLAMO_ENGINE_2D:
+		reg = GLAMO_REG_CLOCK_2D;
+		mask = GLAMO_CLOCK_2D_RESET;
+		break;
+	default:
+		return;
+	}
+
+	glamo_set_bit_mask(reg, mask, 0xffff);
+	while ((GLAMO_IN_REG(reg) & mask) != mask);
+	glamo_set_bit_mask(reg, mask, 0);
+	while ((GLAMO_IN_REG(reg) & mask) != 0);
+}
+
+void glamo_hw_engine_enable(enum glamo_engine engine)
+{
+	if (engine_status[engine] & STATUS_ENABLED)
+		return;
+
+	glamo_set_bit_mask(GLAMO_REG_CLOCK_GEN5_1, GLAMO_CLOCK_GEN51_EN_DIV_MCLK, 0xffff);
+
+	switch (engine) {
+	case GLAMO_ENGINE_MPEG:
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_MPEG,
+				   GLAMO_CLOCK_MPEG_EN_X6CLK |
+				   GLAMO_CLOCK_MPEG_DG_X6CLK |
+				   GLAMO_CLOCK_MPEG_EN_X4CLK |
+				   GLAMO_CLOCK_MPEG_DG_X4CLK |
+				   GLAMO_CLOCK_MPEG_EN_X2CLK |
+				   GLAMO_CLOCK_MPEG_DG_X2CLK |
+				   GLAMO_CLOCK_MPEG_EN_X0CLK |
+				   GLAMO_CLOCK_MPEG_DG_X0CLK,
+				   0xffff & ~GLAMO_CLOCK_MPEG_DG_X0CLK);
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_MPROC,
+				   GLAMO_CLOCK_MPROC_EN_M4CLK,
+				   0xffff);
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_GEN5_1,
+				   GLAMO_CLOCK_GEN51_EN_DIV_JCLK,
+				   0xffff);
+		glamo_set_bit_mask(GLAMO_REG_HOSTBUS(2),
+				   GLAMO_HOSTBUS2_MMIO_EN_MPEG |
+				   GLAMO_HOSTBUS2_MMIO_EN_MICROP1,
+				   0xffff);
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_MPROC,
+				   GLAMO_CLOCK_MPROC_EN_KCLK,
+				   0xffff);
+		break;
+	case GLAMO_ENGINE_ISP:
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_ISP,
+				   GLAMO_CLOCK_ISP_EN_M2CLK |
+				   GLAMO_CLOCK_ISP_EN_I1CLK,
+				   0xffff);
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_GEN5_2,
+				   GLAMO_CLOCK_GEN52_EN_DIV_ICLK,
+				   0xffff);
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_GEN5_1,
+				   GLAMO_CLOCK_GEN51_EN_DIV_JCLK,
+				   0xffff);
+		glamo_set_bit_mask(GLAMO_REG_HOSTBUS(2),
+				   GLAMO_HOSTBUS2_MMIO_EN_ISP,
+				   0xffff);
+		break;
+	case GLAMO_ENGINE_CMDQ:
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_2D,
+				   GLAMO_CLOCK_2D_EN_M6CLK,
+				   0xffff);
+		glamo_set_bit_mask(GLAMO_REG_HOSTBUS(2),
+				   GLAMO_HOSTBUS2_MMIO_EN_CMDQ,
+				   0xffff);
+		break;
+	case GLAMO_ENGINE_2D:
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_2D,
+				   GLAMO_CLOCK_2D_EN_M7CLK |
+				   GLAMO_CLOCK_2D_EN_GCLK |
+				   GLAMO_CLOCK_2D_DG_M7CLK |
+				   GLAMO_CLOCK_2D_DG_GCLK,
+				   0xffff);
+		glamo_set_bit_mask(GLAMO_REG_HOSTBUS(2),
+				   GLAMO_HOSTBUS2_MMIO_EN_2D,
+				   0xffff);
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_GEN5_1,
+				   GLAMO_CLOCK_GEN51_EN_DIV_GCLK,
+				   0xffff);
+		break;
+	}
+
+	engine_status[engine] |= STATUS_ENABLED;
+}
+
+void glamo_hw_engine_disable(enum glamo_engine engine)
+{
+	if (!(engine_status[engine] & STATUS_ENABLED))
+		return;
+
+	switch (engine) {
+	case GLAMO_ENGINE_MPEG:
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_MPEG,
+				   GLAMO_CLOCK_MPEG_EN_X6CLK |
+				   GLAMO_CLOCK_MPEG_DG_X6CLK |
+				   GLAMO_CLOCK_MPEG_EN_X4CLK |
+				   GLAMO_CLOCK_MPEG_DG_X4CLK |
+				   GLAMO_CLOCK_MPEG_EN_X2CLK |
+				   GLAMO_CLOCK_MPEG_DG_X2CLK |
+				   GLAMO_CLOCK_MPEG_EN_X0CLK |
+				   GLAMO_CLOCK_MPEG_DG_X0CLK,
+				   0);
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_MPROC,
+				   GLAMO_CLOCK_MPROC_EN_M4CLK,
+				   0);
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_GEN5_1,
+				   GLAMO_CLOCK_GEN51_EN_DIV_JCLK,
+				   0);
+		glamo_set_bit_mask(GLAMO_REG_HOSTBUS(2),
+				   GLAMO_HOSTBUS2_MMIO_EN_MPEG |
+				   GLAMO_HOSTBUS2_MMIO_EN_MICROP1,
+				   0);
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_MPROC,
+				   GLAMO_CLOCK_MPROC_EN_KCLK,
+				   0);
+		break;
+	case GLAMO_ENGINE_ISP:
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_ISP,
+				   GLAMO_CLOCK_ISP_EN_M2CLK |
+				   GLAMO_CLOCK_ISP_EN_I1CLK,
+				   0);
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_GEN5_2,
+				   GLAMO_CLOCK_GEN52_EN_DIV_ICLK,
+				   0);
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_GEN5_1,
+				   GLAMO_CLOCK_GEN51_EN_DIV_JCLK,
+				   0);
+		glamo_set_bit_mask(GLAMO_REG_HOSTBUS(2),
+				   GLAMO_HOSTBUS2_MMIO_EN_ISP,
+				   0);
+		break;
+	case GLAMO_ENGINE_CMDQ:
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_2D,
+				   GLAMO_CLOCK_2D_EN_M6CLK,
+				   0);
+		glamo_set_bit_mask(GLAMO_REG_HOSTBUS(2),
+				   GLAMO_HOSTBUS2_MMIO_EN_CMDQ,
+				   0);
+		break;
+	case GLAMO_ENGINE_2D:
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_2D,
+				   GLAMO_CLOCK_2D_EN_M7CLK |
+				   GLAMO_CLOCK_2D_EN_GCLK |
+				   GLAMO_CLOCK_2D_DG_M7CLK |
+				   GLAMO_CLOCK_2D_DG_GCLK,
+				   0);
+		glamo_set_bit_mask(GLAMO_REG_HOSTBUS(2),
+				   GLAMO_HOSTBUS2_MMIO_EN_2D,
+				   0);
+		glamo_set_bit_mask(GLAMO_REG_CLOCK_GEN5_1,
+				   GLAMO_CLOCK_GEN51_EN_DIV_GCLK,
+				   0);
+		break;
+	}
+
+	/* simply commented out;  we don't want a clock manager to do things right */
+	//glamo_set_bit_mask(GLAMO_REG_CLOCK_GEN5_1, GLAMO_CLOCK_GEN51_EN_DIV_MCLK, 0);
+
+	engine_status[engine] &= ~STATUS_ENABLED;
+}
+
+void glamo_hw_dump(int reg, int len)
+{
+	int i, val;
+
+	printf("reg       val\n");
+
+	for (i = 0; i < len; i++, reg += 2)
+	{
+		val = GLAMO_IN_REG(reg);
+
+		printf("0x%06x: 0x%04x\n", reg, val);
+	}
+}
Index: mplayer/drivers/libglamo/blit.h
===================================================================
--- mplayer.orig/drivers/libglamo/blit.h	(revision 0)
+++ mplayer/drivers/libglamo/blit.h	(revision 0)
@@ -0,0 +1,72 @@
+/*
+ * Image blitting support using the 2D engine.
+ *
+ * Copyright (C) 2007 OpenMoko, Inc.
+ * Author: Chia-I Wu <olv@openmoko.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 or
+ * (at your option) version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _BLIT_H_
+#define _BLIT_H_
+
+#include "dma.h"
+
+enum glamo_blit_format {
+	GLAMO_BLIT_FORMAT_I420,
+	GLAMO_BLIT_FORMAT_YV16,
+	GLAMO_BLIT_FORMAT_YUY2,
+};
+
+enum glamo_blit_rotation {
+	GLAMO_BLIT_ROTATION_0,
+	GLAMO_BLIT_ROTATION_90,
+	GLAMO_BLIT_ROTATION_270,
+	GLAMO_BLIT_ROTATION_180,
+	GLAMO_BLIT_ROTATION_MIRROR,
+	GLAMO_BLIT_ROTATION_FLIP
+};
+
+struct glamo_blit_image {
+	enum glamo_blit_format format;
+	const unsigned char *data;
+	int width;
+	int height;
+	int num_planes; /* 1 or 3 */
+	int pitches[3];
+	int offsets[3];
+};
+
+struct glamo_blit_manager {
+	struct glamo_dma_manager *dma;
+	enum glamo_blit_format format;
+};
+
+struct glamo_blit_manager *glamo_blit_new(struct glamo_dma_manager *dma, enum glamo_blit_format format);
+void glamo_blit_destroy(struct glamo_blit_manager *blit);
+void glamo_blit_wait(struct glamo_blit_manager *blit);
+void glamo_blit_dump(struct glamo_blit_manager *blit);
+
+void glamo_blit_rotate(struct glamo_blit_manager *blit, 
+		enum glamo_blit_rotation);
+
+struct glamo_blit_image *glamo_blit_new_image(struct glamo_blit_manager *blit,
+		const unsigned char *data, int width, int height);
+void glamo_blit_destroy_image(struct glamo_blit_manager *blit, struct glamo_blit_image *image);
+void glamo_blit_show_image(struct glamo_blit_manager *blit, struct glamo_blit_image *image,
+		int x, int y, int width, int height);
+void glamo_blit_dump_image(struct glamo_blit_manager *blit, struct glamo_blit_image *image);
+
+#endif /* _BLIT_H */
Index: mplayer/drivers/libglamo/os.c
===================================================================
--- mplayer.orig/drivers/libglamo/os.c	(revision 0)
+++ mplayer/drivers/libglamo/os.c	(revision 0)
@@ -0,0 +1,132 @@
+/*
+ * Library's linux interface.
+ * Currently FIC GTA02 specific.
+ *
+ * Copyright (C) 2007 OpenMoko, Inc.
+ * Author: Chia-I Wu <olv@openmoko.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 or
+ * (at your option) version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <linux/fb.h>
+#include <errno.h>
+
+#include "hw.h"
+
+#define FB_SIZE 0x800000
+
+static int fd_mem;
+static int fd_fb;
+static struct fb_fix_screeninfo fix;
+
+volatile unsigned char *glamo_fb;
+volatile unsigned char *glamo_mmio;
+int glamo_pitch;
+
+#ifndef FB_ACCEL_GLAMO
+# define FB_ACCEL_GLAMO		50	/* SMedia Glamo                 */
+#endif
+
+int glamo_os_init(const char *fb_path)
+{
+	if (!fb_path || !*fb_path)
+		fb_path = "/dev/fb0";
+
+	fd_fb = open(fb_path, O_RDWR | O_SYNC);
+	if (fd_fb < 0)
+	{
+		printf("error opening %s: %s\n", fb_path, strerror(errno));
+		return -errno;
+	}
+
+	if (ioctl(fd_fb, FBIOGET_FSCREENINFO, &fix) < 0)
+	{
+		printf("error in FBIOGET_FSCREENINFO: %s\n", strerror(errno));
+
+		close(fd_fb);
+		return -errno;
+	}
+
+	if (fix.accel != FB_ACCEL_GLAMO) {
+		printf("No Glamo chip found or the kerne is old.\n");
+		/* TODO: Bail out, once the FB_ACCEL_GLAMO #define goes
+		 * into the kernel.  */
+	}
+
+	/* hard-coded */
+	fix.smem_len = FB_SIZE;
+	glamo_pitch = fix.line_length;
+
+	fd_mem = open("/dev/mem", O_RDWR | O_SYNC);
+	if (fd_mem < 0)
+	{
+		printf("error opening mem: %s\n", strerror(errno));
+
+		close(fd_fb);
+		return -errno;
+	}
+
+	/* TODO: use map_phys_mem and unmap_phys_mem */
+	glamo_fb = mmap(NULL, fix.smem_len, PROT_READ | PROT_WRITE,
+			MAP_SHARED, fd_mem, fix.smem_start);
+	if (glamo_fb == MAP_FAILED)
+	{
+		printf("error mmap'ping fb: %s\n", strerror(errno));
+
+		munmap((void *) glamo_fb, fix.smem_len);
+		close(fd_mem);
+		close(fd_fb);
+		return -errno;
+	}
+
+	/* TODO: use map_phys_mem and unmap_phys_mem */
+	glamo_mmio = mmap(NULL, GLAMO_MMIO_SIZE, PROT_READ | PROT_WRITE,
+			MAP_SHARED, fd_mem, GLAMO_MMIO_BASE);
+	if (glamo_mmio == MAP_FAILED)
+	{
+		printf("error mmap'ping mmio: %s\n", strerror(errno));
+
+		munmap((void *) glamo_fb, fix.smem_len);
+		close(fd_mem);
+		close(fd_fb);
+		return -errno;
+	}
+
+#if 0
+	printf("fb   0x%08lx (0x%x)\n"
+	       "mmio 0x%08x (0x%x)\n",
+	       fix.smem_start, fix.smem_len,
+	       GLAMO_MMIO_BASE, GLAMO_MMIO_SIZE);
+#endif
+	return 0;
+}
+
+void glamo_os_finish(void)
+{
+	munmap((void *) glamo_mmio, GLAMO_MMIO_SIZE);
+	munmap((void *) glamo_fb, fix.smem_len);
+
+	close(fd_fb);
+	close(fd_mem);
+}
Index: mplayer/drivers/libglamo/dma.c
===================================================================
--- mplayer.orig/drivers/libglamo/dma.c	(revision 0)
+++ mplayer/drivers/libglamo/dma.c	(revision 0)
@@ -0,0 +1,247 @@
+/*
+ * Glamo DMA engine.
+ *
+ * Copyright (C) 2007 OpenMoko, Inc.
+ * Author: Chia-I Wu <olv@openmoko.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 or
+ * (at your option) version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include "dma.h"
+#include "hw.h"
+#include "glamo.h"
+
+#define DMA_CMDQ_SIZE	(1 * 1024)
+
+static void dma_cmdq_init(struct glamo_dma_manager *dma)
+{
+	int cmdq_len;
+
+	cmdq_len = (DMA_CMDQ_SIZE >> 10) - 1;
+
+	dma->cmdq = (GLAMO_REG_TYPE *) (glamo_fb + GLAMO_VRAM_CMDQ);
+	dma->size = DMA_CMDQ_SIZE;
+	dma->r = 0;
+	dma->w = 0;
+	
+	dma->cmdq[dma->size >> 1] = 0x0;
+	dma->cmdq[(dma->size >> 1) + 1] = 0x0;
+
+	glamo_hw_engine_enable(GLAMO_ENGINE_CMDQ);
+	glamo_hw_engine_reset(GLAMO_ENGINE_CMDQ);
+
+        GLAMO_OUT_REG(GLAMO_REG_CMDQ_BASE_ADDRL,
+		      GLAMO_VRAM_CMDQ & 0xffff);
+        GLAMO_OUT_REG(GLAMO_REG_CMDQ_BASE_ADDRH,
+		      (GLAMO_VRAM_CMDQ >> 16) & 0x7f);
+        GLAMO_OUT_REG(GLAMO_REG_CMDQ_LEN, cmdq_len);
+
+        GLAMO_OUT_REG(GLAMO_REG_CMDQ_WRITE_ADDRH, 0);
+        GLAMO_OUT_REG(GLAMO_REG_CMDQ_WRITE_ADDRL, 0);
+        GLAMO_OUT_REG(GLAMO_REG_CMDQ_READ_ADDRH, 0);
+        GLAMO_OUT_REG(GLAMO_REG_CMDQ_READ_ADDRL, 0);
+        GLAMO_OUT_REG(GLAMO_REG_CMDQ_CONTROL,
+                      1 << 12 | /* turbo flip */
+		      0 << 11 | /* no triple buffer */
+                      5 << 8 | /* no interrupt */
+                      8 << 4 | /* HQ threshold */
+		      0 << 2 | /* no auto-correction */
+		      0 << 1); /* SQ mode */
+}
+
+static void dma_cmdq_flush(struct glamo_dma_manager *dma)
+{
+	GLAMO_REG_TYPE *p = (GLAMO_REG_TYPE *) dma->lbuf;
+	int ring_size = dma->size >> 1;
+	int ring_count = dma->llen >> 1;
+
+	if (ring_count == 0)
+		return;
+
+	/* write pointer can be ring_size, but not zero */
+	while (ring_count--)
+	{
+		if (dma->w >= ring_size)
+			dma->w = 0;
+
+		dma->cmdq[dma->w++] = *p++;
+
+		while (dma->r == dma->w)
+		{
+			dma->r  = GLAMO_IN_REG(GLAMO_REG_CMDQ_READ_ADDRL);
+			dma->r |= (GLAMO_IN_REG(GLAMO_REG_CMDQ_READ_ADDRH) & 0x7) << 16;
+		}
+	}
+
+	GLAMO_OUT_REG(GLAMO_REG_CMDQ_WRITE_ADDRH, (dma->w >> 15) & 0x7);
+	GLAMO_OUT_REG(GLAMO_REG_CMDQ_WRITE_ADDRL, (dma->w <<  1) & 0xffff);
+
+	dma->llen = 0;
+}
+
+static void dma_mmio_flush(struct glamo_dma_manager *dma)
+{
+	GLAMO_REG_TYPE *p = (GLAMO_REG_TYPE *) dma->lbuf;
+
+	while ((unsigned char *) p < dma->lbuf + dma->llen)
+	{
+		GLAMO_REG_TYPE reg, val;
+
+		reg = *p++;
+		val = *p++;
+
+		if (reg & (1 << 15))
+		{
+			int i, n = val;
+
+			reg &= ~(1 << 15);
+
+			for (i = 0; i < n; i++, reg += 2)
+			{
+				val = *p++;
+				//printf("burst 0x%x to 0x%x\n", val, reg);
+				GLAMO_OUT_REG(reg, val);
+			}
+
+			if (n & 1)
+				p++;
+		}
+		else
+			GLAMO_OUT_REG(reg, val);
+	}
+
+	dma->llen = 0;
+}
+
+void glamo_dma_wait(struct glamo_dma_manager *dma, enum glamo_dma_wait_type t)
+{
+	int mask, val;
+
+	switch (dma->mode)
+	{
+	case GLAMO_DMA_MODE_CMDQ:
+		switch (t)
+		{
+		case GLAMO_DMA_WAIT_CMDQ:
+			mask = 0x3;
+			val  = mask;
+			break;
+		case GLAMO_DMA_WAIT_ISP:
+			mask = 0x3 | (1 << 8);
+			val  = 0x3;
+		case GLAMO_DMA_WAIT_ALL:
+			mask = 1 << 2;
+			val  = mask;
+			break;
+		default:
+			return;
+		}
+
+		while (1)
+		{
+			int status;
+
+			status = GLAMO_IN_REG(GLAMO_REG_CMDQ_STATUS);
+			if ((status & mask) == val)
+				break;
+		}
+		break;
+	case GLAMO_DMA_MODE_MMIO:
+	default:
+		break;
+	}
+}
+
+void glamo_dma_flush(struct glamo_dma_manager *dma)
+{
+	if (dma->llen == 0)
+		return;
+
+	switch (dma->mode)
+	{
+	case GLAMO_DMA_MODE_CMDQ:
+		dma_cmdq_flush(dma);
+		break;
+	case GLAMO_DMA_MODE_MMIO:
+	default:
+		dma_mmio_flush(dma);
+		break;
+	}
+}
+
+struct glamo_dma_manager *glamo_dma_new(enum glamo_dma_mode mode)
+{
+	struct glamo_dma_manager *dma;
+
+	dma = malloc(sizeof(*dma));
+	if (!dma)
+		return NULL;
+
+	dma->mode = mode;
+	dma->lsize = DMA_CMDQ_SIZE;
+	dma->lbuf = malloc(dma->lsize);
+	dma->llen = 0;
+
+	switch (mode)
+	{
+	case GLAMO_DMA_MODE_CMDQ:
+		dma_cmdq_init(dma);
+		break;
+	case GLAMO_DMA_MODE_MMIO:
+	default:
+		break;
+	}
+
+	return dma;
+}
+
+void glamo_dma_destroy(struct glamo_dma_manager *dma)
+{
+	switch (dma->mode)
+	{
+	case GLAMO_DMA_MODE_CMDQ:
+		glamo_hw_engine_reset(GLAMO_ENGINE_CMDQ);
+		glamo_hw_engine_disable(GLAMO_ENGINE_CMDQ);
+		break;
+	case GLAMO_DMA_MODE_MMIO:
+	default:
+		break;
+	}
+
+	free(dma->lbuf);
+	free(dma);
+}
+
+void glamo_dma_dump(struct glamo_dma_manager *dma)
+{
+	int i;
+
+	switch (dma->mode)
+	{
+	case GLAMO_DMA_MODE_CMDQ:
+		glamo_hw_dump(GLAMO_REG_CMDQ_BASE_ADDRL, 10);
+		printf("w 0x%x, r 0x%x\n", dma->w << 1, dma->r << 1);
+		for (i = 0; i < 16; i++)
+			printf("0x%04x%c", dma->cmdq[i], ((i % 16) == 15) ? '\n' : ' ');
+		break;
+	case GLAMO_DMA_MODE_MMIO:
+	default:
+		break;
+	}
+}
Index: mplayer/drivers/libglamo/glamo-regs.h
===================================================================
--- mplayer.orig/drivers/libglamo/glamo-regs.h	(revision 0)
+++ mplayer/drivers/libglamo/glamo-regs.h	(revision 0)
@@ -0,0 +1,757 @@
+#ifndef _GLAMO_REGS_H
+#define _GLAMO_REGS_H
+
+/* Smedia Glamo 336x/337x driver
+ *
+ * (C) 2007 by OpenMoko, Inc.
+ * Author: Harald Welte <laforge@openmoko.org>
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+enum glamo_regster_offsets {
+	GLAMO_REGOFS_GENERIC	= 0x0000,
+	GLAMO_REGOFS_HOSTBUS	= 0x0200,
+	GLAMO_REGOFS_MEMORY	= 0x0300,
+	GLAMO_REGOFS_VIDCAP	= 0x0400,
+	GLAMO_REGOFS_ISP	= 0x0500,
+	GLAMO_REGOFS_JPEG	= 0x0800,
+	GLAMO_REGOFS_MPEG	= 0x0c00,
+	GLAMO_REGOFS_LCD	= 0x1100,
+	GLAMO_REGOFS_MMC	= 0x1400,
+	GLAMO_REGOFS_MPROC0	= 0x1500,
+	GLAMO_REGOFS_MPROC1	= 0x1580,
+	GLAMO_REGOFS_CMDQUEUE	= 0x1600,
+	GLAMO_REGOFS_RISC	= 0x1680,
+	GLAMO_REGOFS_2D		= 0x1700,
+	GLAMO_REGOFS_3D		= 0x1b00,
+};
+
+
+enum glamo_register_generic {
+	GLAMO_REG_GCONF1	= 0x0000,
+	GLAMO_REG_GCONF2	= 0x0002,
+#define	GLAMO_REG_DEVICE_ID	GLAMO_REG_GCONF2
+	GLAMO_REG_GCONF3	= 0x0004,
+#define	GLAMO_REG_REVISION_ID	GLAMO_REG_GCONF3
+	GLAMO_REG_IRQ_GEN1	= 0x0006,
+#define GLAMO_REG_IRQ_ENABLE	GLAMO_REG_IRQ_GEN1
+	GLAMO_REG_IRQ_GEN2	= 0x0008,
+#define GLAMO_REG_IRQ_SET	GLAMO_REG_IRQ_GEN2
+	GLAMO_REG_IRQ_GEN3	= 0x000a,
+#define GLAMO_REG_IRQ_CLEAR	GLAMO_REG_IRQ_GEN3
+	GLAMO_REG_IRQ_GEN4	= 0x000c,
+#define GLAMO_REG_IRQ_STATUS	GLAMO_REG_IRQ_GEN4
+	GLAMO_REG_CLOCK_HOST	= 0x0010,
+	GLAMO_REG_CLOCK_MEMORY	= 0x0012,
+	GLAMO_REG_CLOCK_LCD	= 0x0014,
+	GLAMO_REG_CLOCK_MMC	= 0x0016,
+	GLAMO_REG_CLOCK_ISP	= 0x0018,
+	GLAMO_REG_CLOCK_JPEG	= 0x001a,
+	GLAMO_REG_CLOCK_3D	= 0x001c,
+	GLAMO_REG_CLOCK_2D	= 0x001e,
+	GLAMO_REG_CLOCK_RISC1	= 0x0020,	/* 3365 only? */
+	GLAMO_REG_CLOCK_RISC2	= 0x0022,	/* 3365 only? */
+	GLAMO_REG_CLOCK_MPEG	= 0x0024,
+	GLAMO_REG_CLOCK_MPROC	= 0x0026,
+
+	GLAMO_REG_CLOCK_GEN5_1	= 0x0030,
+	GLAMO_REG_CLOCK_GEN5_2	= 0x0032,
+	GLAMO_REG_CLOCK_GEN6	= 0x0034,
+	GLAMO_REG_CLOCK_GEN7	= 0x0036,
+	GLAMO_REG_CLOCK_GEN8	= 0x0038,
+	GLAMO_REG_CLOCK_GEN9	= 0x003a,
+	GLAMO_REG_CLOCK_GEN10	= 0x003c,
+	GLAMO_REG_CLOCK_GEN11	= 0x003e,
+	GLAMO_REG_PLL_GEN1	= 0x0040,
+	GLAMO_REG_PLL_GEN2	= 0x0042,
+	GLAMO_REG_PLL_GEN3	= 0x0044,
+	GLAMO_REG_PLL_GEN4	= 0x0046,
+	GLAMO_REG_PLL_GEN5	= 0x0048,
+	GLAMO_REG_GPIO_GEN1	= 0x0050,
+	GLAMO_REG_GPIO_GEN2	= 0x0052,
+	GLAMO_REG_GPIO_GEN3	= 0x0054,
+	GLAMO_REG_GPIO_GEN4	= 0x0056,
+	GLAMO_REG_GPIO_GEN5	= 0x0058,
+	GLAMO_REG_GPIO_GEN6	= 0x005a,
+	GLAMO_REG_GPIO_GEN7	= 0x005c,
+	GLAMO_REG_GPIO_GEN8	= 0x005e,
+	GLAMO_REG_GPIO_GEN9	= 0x0060,
+	GLAMO_REG_GPIO_GEN10	= 0x0062,
+	GLAMO_REG_DFT_GEN1	= 0x0070,
+	GLAMO_REG_DFT_GEN2	= 0x0072,
+	GLAMO_REG_DFT_GEN3	= 0x0074,
+	GLAMO_REG_DFT_GEN4	= 0x0076,
+
+	GLAMO_REG_DFT_GEN5	= 0x01e0,
+	GLAMO_REG_DFT_GEN6	= 0x01f0,
+};
+
+#define GLAMO_REG_HOSTBUS(x)	(GLAMO_REGOFS_HOSTBUS-2+(x*2))
+
+#define REG_MEM(x)		(GLAMO_REGOFS_MEMORY+(x))
+#define GLAMO_REG_MEM_TIMING(x)	(GLAMO_REG_MEM_TIMING1-2+(x*2))
+
+enum glamo_register_mem {
+	GLAMO_REG_MEM_TYPE	= REG_MEM(0x00),
+	GLAMO_REG_MEM_GEN	= REG_MEM(0x02),
+	GLAMO_REG_MEM_TIMING1	= REG_MEM(0x04),
+	GLAMO_REG_MEM_TIMING2	= REG_MEM(0x06),
+	GLAMO_REG_MEM_TIMING3	= REG_MEM(0x08),
+	GLAMO_REG_MEM_TIMING4	= REG_MEM(0x0a),
+	GLAMO_REG_MEM_TIMING5	= REG_MEM(0x0c),
+	GLAMO_REG_MEM_TIMING6	= REG_MEM(0x0e),
+	GLAMO_REG_MEM_TIMING7	= REG_MEM(0x10),
+	GLAMO_REG_MEM_TIMING8	= REG_MEM(0x12),
+	GLAMO_REG_MEM_TIMING9	= REG_MEM(0x14),
+	GLAMO_REG_MEM_TIMING10	= REG_MEM(0x16),
+	GLAMO_REG_MEM_TIMING11	= REG_MEM(0x18),
+	GLAMO_REG_MEM_POWER1	= REG_MEM(0x1a),
+	GLAMO_REG_MEM_POWER2	= REG_MEM(0x1c),
+	GLAMO_REG_MEM_LCD_BUF1	= REG_MEM(0x1e),
+	GLAMO_REG_MEM_LCD_BUF2	= REG_MEM(0x20),
+	GLAMO_REG_MEM_LCD_BUF3	= REG_MEM(0x22),
+	GLAMO_REG_MEM_LCD_BUF4	= REG_MEM(0x24),
+	GLAMO_REG_MEM_BIST1	= REG_MEM(0x26),
+	GLAMO_REG_MEM_BIST2	= REG_MEM(0x28),
+	GLAMO_REG_MEM_BIST3	= REG_MEM(0x2a),
+	GLAMO_REG_MEM_BIST4	= REG_MEM(0x2c),
+	GLAMO_REG_MEM_BIST5	= REG_MEM(0x2e),
+	GLAMO_REG_MEM_MAH1	= REG_MEM(0x30),
+	GLAMO_REG_MEM_MAH2	= REG_MEM(0x32),
+	GLAMO_REG_MEM_DRAM1	= REG_MEM(0x34),
+	GLAMO_REG_MEM_DRAM2	= REG_MEM(0x36),
+	GLAMO_REG_MEM_CRC	= REG_MEM(0x38),
+};
+
+#define GLAMO_MEM_TYPE_MASK	0x03
+
+enum glamo_reg_mem_dram1 {
+	GLAMO_MEM_DRAM1_EN_SDRAM_CLK	= (1 << 11),
+	GLAMO_MEM_DRAM1_SELF_REFRESH	= (1 << 12),
+};
+
+enum glamo_reg_mem_dram2 {
+	GLAMO_MEM_DRAM2_DEEP_PWRDOWN	= (1 << 12),
+};
+
+enum glamo_irq {
+	GLAMO_IRQ_HOSTBUS	= 0x0001,
+	GLAMO_IRQ_JPEG		= 0x0002,
+	GLAMO_IRQ_MPEG		= 0x0004,
+	GLAMO_IRQ_MPROC1	= 0x0008,
+	GLAMO_IRQ_MPROC0	= 0x0010,
+	GLAMO_IRQ_CMDQUEUE	= 0x0020,
+	GLAMO_IRQ_2D		= 0x0040,
+	GLAMO_IRQ_MMC		= 0x0080,
+	GLAMO_IRQ_RISC		= 0x0100,
+};
+
+enum glamo_reg_clock_host {
+	GLAMO_CLOCK_HOST_DG_BCLK	= 0x0001,
+	GLAMO_CLOCK_HOST_DG_M0CLK	= 0x0004,
+	GLAMO_CLOCK_HOST_RESET		= 0x1000,
+};
+
+enum glamo_reg_clock_mem {
+	GLAMO_CLOCK_MEM_DG_M1CLK	= 0x0001,
+	GLAMO_CLOCK_MEM_EN_M1CLK	= 0x0002,
+	GLAMO_CLOCK_MEM_DG_MOCACLK	= 0x0004,
+	GLAMO_CLOCK_MEM_EN_MOCACLK	= 0x0008,
+	GLAMO_CLOCK_MEM_RESET		= 0x1000,
+	GLAMO_CLOCK_MOCA_RESET		= 0x2000,
+};
+
+enum glamo_reg_clock_lcd {
+	GLAMO_CLOCK_LCD_DG_DCLK		= 0x0001,
+	GLAMO_CLOCK_LCD_EN_DCLK		= 0x0002,
+	GLAMO_CLOCK_LCD_DG_DMCLK	= 0x0004,
+	GLAMO_CLOCK_LCD_EN_DMCLK	= 0x0008,
+	//
+	GLAMO_CLOCK_LCD_EN_DHCLK	= 0x0020,
+	GLAMO_CLOCK_LCD_DG_M5CLK	= 0x0040,
+	GLAMO_CLOCK_LCD_EN_M5CLK	= 0x0080,
+	GLAMO_CLOCK_LCD_RESET		= 0x1000,
+};
+
+enum glamo_reg_clock_mmc {
+	GLAMO_CLOCK_MMC_DG_TCLK		= 0x0001,
+	GLAMO_CLOCK_MMC_EN_TCLK		= 0x0002,
+	GLAMO_CLOCK_MMC_DG_M9CLK	= 0x0004,
+	GLAMO_CLOCK_MMC_EN_M9CLK	= 0x0008,
+	GLAMO_CLOCK_MMC_RESET		= 0x1000,
+};
+
+enum glamo_reg_clock_isp {
+	GLAMO_CLOCK_ISP_DG_I1CLK	= 0x0001,
+	GLAMO_CLOCK_ISP_EN_I1CLK	= 0x0002,
+	GLAMO_CLOCK_ISP_DG_CCLK		= 0x0004,
+	GLAMO_CLOCK_ISP_EN_CCLK		= 0x0008,
+	//
+	GLAMO_CLOCK_ISP_EN_SCLK		= 0x0020,
+	GLAMO_CLOCK_ISP_DG_M2CLK	= 0x0040,
+	GLAMO_CLOCK_ISP_EN_M2CLK	= 0x0080,
+	GLAMO_CLOCK_ISP_DG_M15CLK	= 0x0100,
+	GLAMO_CLOCK_ISP_EN_M15CLK	= 0x0200,
+	GLAMO_CLOCK_ISP1_RESET		= 0x1000,
+	GLAMO_CLOCK_ISP2_RESET		= 0x2000,
+};
+
+enum glamo_reg_clock_jpeg {
+	GLAMO_CLOCK_JPEG_DG_JCLK	= 0x0001,
+	GLAMO_CLOCK_JPEG_EN_JCLK	= 0x0002,
+	GLAMO_CLOCK_JPEG_DG_M3CLK	= 0x0004,
+	GLAMO_CLOCK_JPEG_EN_M3CLK	= 0x0008,
+	GLAMO_CLOCK_JPEG_RESET		= 0x1000,
+};
+
+enum glamo_reg_clock_2d {
+	GLAMO_CLOCK_2D_DG_GCLK		= 0x0001,
+	GLAMO_CLOCK_2D_EN_GCLK		= 0x0002,
+	GLAMO_CLOCK_2D_DG_M7CLK		= 0x0004,
+	GLAMO_CLOCK_2D_EN_M7CLK		= 0x0008,
+	GLAMO_CLOCK_2D_DG_M6CLK		= 0x0010,
+	GLAMO_CLOCK_2D_EN_M6CLK		= 0x0020,
+	GLAMO_CLOCK_2D_RESET		= 0x1000,
+	GLAMO_CLOCK_2D_CMDQ_RESET		= 0x2000,
+};
+
+enum glamo_reg_clock_3d {
+	GLAMO_CLOCK_3D_DG_ECLK		= 0x0001,
+	GLAMO_CLOCK_3D_EN_ECLK		= 0x0002,
+	GLAMO_CLOCK_3D_DG_RCLK		= 0x0004,
+	GLAMO_CLOCK_3D_EN_RCLK		= 0x0008,
+	GLAMO_CLOCK_3D_DG_M8CLK		= 0x0010,
+	GLAMO_CLOCK_3D_EN_M8CLK		= 0x0020,
+	GLAMO_CLOCK_3D_BACK_RESET	= 0x1000,
+	GLAMO_CLOCK_3D_FRONT_RESET	= 0x2000,
+};
+
+enum glamo_reg_clock_mpeg {
+	GLAMO_CLOCK_MPEG_DG_X0CLK	= 0x0001,
+	GLAMO_CLOCK_MPEG_EN_X0CLK	= 0x0002,
+	GLAMO_CLOCK_MPEG_DG_X1CLK	= 0x0004,
+	GLAMO_CLOCK_MPEG_EN_X1CLK	= 0x0008,
+	GLAMO_CLOCK_MPEG_DG_X2CLK	= 0x0010,
+	GLAMO_CLOCK_MPEG_EN_X2CLK	= 0x0020,
+	GLAMO_CLOCK_MPEG_DG_X3CLK	= 0x0040,
+	GLAMO_CLOCK_MPEG_EN_X3CLK	= 0x0080,
+	GLAMO_CLOCK_MPEG_DG_X4CLK	= 0x0100,
+	GLAMO_CLOCK_MPEG_EN_X4CLK	= 0x0200,
+	GLAMO_CLOCK_MPEG_DG_X6CLK	= 0x0400,
+	GLAMO_CLOCK_MPEG_EN_X6CLK	= 0x0800,
+	GLAMO_CLOCK_MPEG_ENC_RESET	= 0x1000,
+	GLAMO_CLOCK_MPEG_DEC_RESET	= 0x2000,
+};
+
+enum glamo_reg_clock_mproc {
+	GLAMO_CLOCK_MPROC_DG_I0CLK	= 0x0001,
+	GLAMO_CLOCK_MPROC_EN_I0CLK	= 0x0002,
+	GLAMO_CLOCK_MPROC_DG_X5CLK	= 0x0004,
+	GLAMO_CLOCK_MPROC_EN_X5CLK	= 0x0008,
+	//
+	GLAMO_CLOCK_MPROC_EN_KCLK	= 0x0020,
+	GLAMO_CLOCK_MPROC_DG_M4CLK	= 0x0040,
+	GLAMO_CLOCK_MPROC_EN_M4CLK	= 0x0080,
+	GLAMO_CLOCK_MPROC_DG_M10CLK	= 0x0100,
+	GLAMO_CLOCK_MPROC_EN_M10CLK	= 0x0200,
+	GLAMO_CLOCK_MPROC_RESET		= 0x1000,
+};
+
+enum glamo_reg_clock51 {
+	GLAMO_CLOCK_GEN51_EN_DIV_MCLK	= 0x0001,
+	GLAMO_CLOCK_GEN51_EN_DIV_SCLK	= 0x0002,
+	GLAMO_CLOCK_GEN51_EN_DIV_JCLK	= 0x0004,
+	GLAMO_CLOCK_GEN51_EN_DIV_DCLK	= 0x0008,
+	GLAMO_CLOCK_GEN51_EN_DIV_DMCLK	= 0x0010,
+	GLAMO_CLOCK_GEN51_EN_DIV_DHCLK	= 0x0020,
+	GLAMO_CLOCK_GEN51_EN_DIV_GCLK	= 0x0040,
+	GLAMO_CLOCK_GEN51_EN_DIV_TCLK	= 0x0080,
+	/* FIXME: higher bits */
+};
+
+enum glamo_reg_clock52 {
+	GLAMO_CLOCK_GEN52_EN_DIV_ACLK	= 0x0001,
+	GLAMO_CLOCK_GEN52_EN_DIV_AMCLK	= 0x0002,
+	GLAMO_CLOCK_GEN52_EN_DIV_OCLK	= 0x0004,
+	GLAMO_CLOCK_GEN52_EN_DIV_ZCLK	= 0x0008,
+	GLAMO_CLOCK_GEN52_EN_DIV_ICLK	= 0x0010,
+	/* FIXME: higher bits */
+};
+
+enum glamo_reg_hostbus2 {
+	GLAMO_HOSTBUS2_MMIO_EN_ISP	= 0x0001,
+	GLAMO_HOSTBUS2_MMIO_EN_JPEG	= 0x0002,
+	GLAMO_HOSTBUS2_MMIO_EN_MPEG	= 0x0004,
+	GLAMO_HOSTBUS2_MMIO_EN_LCD	= 0x0008,
+	GLAMO_HOSTBUS2_MMIO_EN_MMC	= 0x0010,
+	GLAMO_HOSTBUS2_MMIO_EN_MICROP0	= 0x0020,
+	GLAMO_HOSTBUS2_MMIO_EN_MICROP1	= 0x0040,
+	GLAMO_HOSTBUS2_MMIO_EN_CMDQ	= 0x0080,
+	GLAMO_HOSTBUS2_MMIO_EN_RISC	= 0x0100,
+	GLAMO_HOSTBUS2_MMIO_EN_2D	= 0x0200,
+	GLAMO_HOSTBUS2_MMIO_EN_3D	= 0x0400,
+};
+
+/* LCD Controller */
+
+#define REG_LCD(x)	(GLAMO_REGOFS_LCD+(x))
+enum glamo_reg_lcd {
+	GLAMO_REG_LCD_MODE1		= REG_LCD(0x00),
+	GLAMO_REG_LCD_MODE2		= REG_LCD(0x02),
+	GLAMO_REG_LCD_MODE3		= REG_LCD(0x04),
+	GLAMO_REG_LCD_WIDTH		= REG_LCD(0x06),
+	GLAMO_REG_LCD_HEIGHT		= REG_LCD(0x08),
+	GLAMO_REG_LCD_POLARITY		= REG_LCD(0x0a),
+	GLAMO_REG_LCD_A_BASE1		= REG_LCD(0x0c),
+	GLAMO_REG_LCD_A_BASE2		= REG_LCD(0x0e),
+	GLAMO_REG_LCD_B_BASE1		= REG_LCD(0x10),
+	GLAMO_REG_LCD_B_BASE2		= REG_LCD(0x12),
+	GLAMO_REG_LCD_C_BASE1		= REG_LCD(0x14),
+	GLAMO_REG_LCD_C_BASE2		= REG_LCD(0x16),
+	GLAMO_REG_LCD_PITCH		= REG_LCD(0x18),
+	/* RES */
+	GLAMO_REG_LCD_HORIZ_TOTAL	= REG_LCD(0x1c),
+	/* RES */
+	GLAMO_REG_LCD_HORIZ_RETR_START	= REG_LCD(0x20),
+	/* RES */
+	GLAMO_REG_LCD_HORIZ_RETR_END	= REG_LCD(0x24),
+	/* RES */
+	GLAMO_REG_LCD_HORIZ_DISP_START	= REG_LCD(0x28),
+	/* RES */
+	GLAMO_REG_LCD_HORIZ_DISP_END	= REG_LCD(0x2c),
+	/* RES */
+	GLAMO_REG_LCD_VERT_TOTAL	= REG_LCD(0x30),
+	/* RES */
+	GLAMO_REG_LCD_VERT_RETR_START	= REG_LCD(0x34),
+	/* RES */
+	GLAMO_REG_LCD_VERT_RETR_END	= REG_LCD(0x38),
+	/* RES */
+	GLAMO_REG_LCD_VERT_DISP_START	= REG_LCD(0x3c),
+	/* RES */
+	GLAMO_REG_LCD_VERT_DISP_END	= REG_LCD(0x40),
+	/* RES */
+	GLAMO_REG_LCD_POL		= REG_LCD(0x44),
+	GLAMO_REG_LCD_DATA_START	= REG_LCD(0x46),
+	GLAMO_REG_LCD_FRATE_CONTRO	= REG_LCD(0x48),
+	GLAMO_REG_LCD_DATA_CMD_HDR	= REG_LCD(0x4a),
+	GLAMO_REG_LCD_SP_START		= REG_LCD(0x4c),
+	GLAMO_REG_LCD_SP_END		= REG_LCD(0x4e),
+	GLAMO_REG_LCD_CURSOR_BASE1	= REG_LCD(0x50),
+	GLAMO_REG_LCD_CURSOR_BASE2	= REG_LCD(0x52),
+	GLAMO_REG_LCD_CURSOR_PITCH	= REG_LCD(0x54),
+	GLAMO_REG_LCD_CURSOR_X_SIZE	= REG_LCD(0x56),
+	GLAMO_REG_LCD_CURSOR_Y_SIZE	= REG_LCD(0x58),
+	GLAMO_REG_LCD_CURSOR_X_POS	= REG_LCD(0x5a),
+	GLAMO_REG_LCD_CURSOR_Y_POS	= REG_LCD(0x5c),
+	GLAMO_REG_LCD_CURSOR_PRESET	= REG_LCD(0x5e),
+	GLAMO_REG_LCD_CURSOR_FG_COLOR	= REG_LCD(0x60),
+	/* RES */
+	GLAMO_REG_LCD_CURSOR_BG_COLOR	= REG_LCD(0x64),
+	/* RES */
+	GLAMO_REG_LCD_CURSOR_DST_COLOR	= REG_LCD(0x68),
+	/* RES */
+	GLAMO_REG_LCD_STATUS1		= REG_LCD(0x80),
+	GLAMO_REG_LCD_STATUS2		= REG_LCD(0x82),
+	GLAMO_REG_LCD_STATUS3		= REG_LCD(0x84),
+	GLAMO_REG_LCD_STATUS4		= REG_LCD(0x86),
+	/* RES */
+	GLAMO_REG_LCD_COMMAND1		= REG_LCD(0xa0),
+	GLAMO_REG_LCD_COMMAND2		= REG_LCD(0xa2),
+	/* RES */
+	GLAMO_REG_LCD_WFORM_DELAY1	= REG_LCD(0xb0),
+	GLAMO_REG_LCD_WFORM_DELAY2	= REG_LCD(0xb2),
+	/* RES */
+	GLAMO_REG_LCD_GAMMA_CORR	= REG_LCD(0x100),
+	/* RES */
+	GLAMO_REG_LCD_GAMMA_R_ENTRY01	= REG_LCD(0x110),
+	GLAMO_REG_LCD_GAMMA_R_ENTRY23	= REG_LCD(0x112),
+	GLAMO_REG_LCD_GAMMA_R_ENTRY45	= REG_LCD(0x114),
+	GLAMO_REG_LCD_GAMMA_R_ENTRY67	= REG_LCD(0x116),
+	GLAMO_REG_LCD_GAMMA_R_ENTRY8	= REG_LCD(0x118),
+	/* RES */
+	GLAMO_REG_LCD_GAMMA_G_ENTRY01	= REG_LCD(0x130),
+	GLAMO_REG_LCD_GAMMA_G_ENTRY23	= REG_LCD(0x132),
+	GLAMO_REG_LCD_GAMMA_G_ENTRY45	= REG_LCD(0x134),
+	GLAMO_REG_LCD_GAMMA_G_ENTRY67	= REG_LCD(0x136),
+	GLAMO_REG_LCD_GAMMA_G_ENTRY8	= REG_LCD(0x138),
+	/* RES */
+	GLAMO_REG_LCD_GAMMA_B_ENTRY01	= REG_LCD(0x150),
+	GLAMO_REG_LCD_GAMMA_B_ENTRY23	= REG_LCD(0x152),
+	GLAMO_REG_LCD_GAMMA_B_ENTRY45	= REG_LCD(0x154),
+	GLAMO_REG_LCD_GAMMA_B_ENTRY67	= REG_LCD(0x156),
+	GLAMO_REG_LCD_GAMMA_B_ENTRY8	= REG_LCD(0x158),
+	/* RES */
+	GLAMO_REG_LCD_SRAM_DRIVING1	= REG_LCD(0x160),
+	GLAMO_REG_LCD_SRAM_DRIVING2	= REG_LCD(0x162),
+	GLAMO_REG_LCD_SRAM_DRIVING3	= REG_LCD(0x164),
+};
+
+enum glamo_reg_lcd_mode1 {
+	GLAMO_LCD_MODE1_PWRSAVE		= 0x0001,
+	GLAMO_LCD_MODE1_PARTIAL_PRT	= 0x0002,
+	GLAMO_LCD_MODE1_HWFLIP		= 0x0004,
+	GLAMO_LCD_MODE1_LCD2		= 0x0008,
+	/* RES */
+	GLAMO_LCD_MODE1_PARTIAL_MODE	= 0x0020,
+	GLAMO_LCD_MODE1_CURSOR_DSTCOLOR	= 0x0040,
+	GLAMO_LCD_MODE1_PARTIAL_ENABLE	= 0x0080,
+	GLAMO_LCD_MODE1_TVCLK_IN_ENABLE	= 0x0100,
+	GLAMO_LCD_MODE1_HSYNC_HIGH_ACT	= 0x0200,
+	GLAMO_LCD_MODE1_VSYNC_HIGH_ACT	= 0x0400,
+	GLAMO_LCD_MODE1_HSYNC_FLIP	= 0x0800,
+	GLAMO_LCD_MODE1_GAMMA_COR_EN	= 0x1000,
+	GLAMO_LCD_MODE1_DITHER_EN	= 0x2000,
+	GLAMO_LCD_MODE1_CURSOR_EN	= 0x4000,
+	GLAMO_LCD_MODE1_ROTATE_EN	= 0x8000,
+};
+
+enum glamo_reg_lcd_mode2 {
+	GLAMO_LCD_MODE2_CRC_CHECK_EN	= 0x0001,
+	GLAMO_LCD_MODE2_DCMD_PER_LINE	= 0x0002,
+	GLAMO_LCD_MODE2_NOUSE_BDEF	= 0x0004,
+	GLAMO_LCD_MODE2_OUT_POS_MODE	= 0x0008,
+	GLAMO_LCD_MODE2_FRATE_CTRL_EN	= 0x0010,
+	GLAMO_LCD_MODE2_SINGLE_BUFFER	= 0x0020,
+	GLAMO_LCD_MODE2_SER_LSB_TO_MSB	= 0x0040,
+	/* FIXME */
+};
+
+enum glamo_reg_lcd_mode3 {
+	/* LCD color source data format */
+	GLAMO_LCD_SRC_RGB565		= 0x0000,
+	GLAMO_LCD_SRC_ARGB1555		= 0x4000,
+	GLAMO_LCD_SRC_ARGB4444		= 0x8000,
+	/* interface type */
+	GLAMO_LCD_MODE3_LCD		= 0x1000,
+	GLAMO_LCD_MODE3_RGB		= 0x0800,
+	GLAMO_LCD_MODE3_CPU		= 0x0000,
+	/* mode */
+	GLAMO_LCD_MODE3_RGB332		= 0x0000,
+	GLAMO_LCD_MODE3_RGB444		= 0x0100,
+	GLAMO_LCD_MODE3_RGB565		= 0x0200,
+	GLAMO_LCD_MODE3_RGB666		= 0x0300,
+	/* depth */
+	GLAMO_LCD_MODE3_6BITS		= 0x0000,
+	GLAMO_LCD_MODE3_8BITS		= 0x0010,
+	GLAMO_LCD_MODE3_9BITS		= 0x0020,
+	GLAMO_LCD_MODE3_16BITS		= 0x0030,
+	GLAMO_LCD_MODE3_18BITS		= 0x0040,
+};
+
+enum glamo_lcd_rot_mode {
+	GLAMO_LCD_ROT_MODE_0		= 0x0000,
+	GLAMO_LCD_ROT_MODE_180		= 0x2000,
+	GLAMO_LCD_ROT_MODE_MIRROR	= 0x4000,
+	GLAMO_LCD_ROT_MODE_FLIP		= 0x6000,
+	GLAMO_LCD_ROT_MODE_90		= 0x8000,
+	GLAMO_LCD_ROT_MODE_270		= 0xa000,
+};
+#define GLAMO_LCD_ROT_MODE_MASK		0xe000
+
+enum glamo_lcd_cmd_type {
+	GLAMO_LCD_CMD_TYPE_DISP		= 0x0000,
+	GLAMO_LCD_CMD_TYPE_PARALLEL	= 0x4000,
+	GLAMO_LCD_CMD_TYPE_SERIAL	= 0x8000,
+	GLAMO_LCD_CMD_TYPE_SERIAL_DIRECT= 0xc000,
+};
+#define GLAMO_LCD_CMD_TYPE_MASK		0xc000
+
+enum glamo_lcd_cmds {
+	GLAMO_LCD_CMD_DATA_DISP_FIRE	= 0x00,
+	GLAMO_LCD_CMD_DATA_DISP_SYNC	= 0x01,		/* RGB only */
+	/* switch to command mode, no display */
+	GLAMO_LCD_CMD_DATA_FIRE_NO_DISP	= 0x02,
+	/* display until VSYNC, switch to command */
+	GLAMO_LCD_CMD_DATA_FIRE_VSYNC	= 0x11,
+	/* display until HSYNC, switch to command */
+	GLAMO_LCD_CMD_DATA_FIRE_HSYNC	= 0x12,
+	/* display until VSYNC, 1 black frame, VSYNC, switch to command */
+	GLAMO_LCD_CMD_DATA_FIRE_VSYNC_B	= 0x13,
+	/* don't care about display and switch to command */
+	GLAMO_LCD_CMD_DATA_FIRE_FREE	= 0x14,		/* RGB only */
+	/* don't care about display, keep data display but disable data,
+	 * and switch to command */
+	GLAMO_LCD_CMD_DATA_FIRE_FREE_D	= 0x15,		/* RGB only */
+};
+
+enum glamo_core_revisions {
+	GLAMO_CORE_REV_A0		= 0x0000,
+	GLAMO_CORE_REV_A1		= 0x0001,
+	GLAMO_CORE_REV_A2		= 0x0002,
+	GLAMO_CORE_REV_A3		= 0x0003,
+};
+
+#define REG_ISP(x)		(GLAMO_REGOFS_ISP+(x))
+
+enum glamo_register_isp {
+	GLAMO_REG_ISP_EN1		= REG_ISP(0x00),
+	GLAMO_REG_ISP_EN2		= REG_ISP(0x02),
+	GLAMO_REG_ISP_EN3		= REG_ISP(0x04),
+	GLAMO_REG_ISP_EN4		= REG_ISP(0x06),
+	GLAMO_REG_ISP_CAP_0_ADDRL	= REG_ISP(0x08),
+	GLAMO_REG_ISP_CAP_0_ADDRH	= REG_ISP(0x0a),
+	GLAMO_REG_ISP_CAP_1_ADDRL	= REG_ISP(0x0c),
+	GLAMO_REG_ISP_CAP_1_ADDRH	= REG_ISP(0x0e),
+	GLAMO_REG_ISP_DEC_Y_ADDRL	= REG_ISP(0x10),
+	GLAMO_REG_ISP_DEC_Y_ADDRH	= REG_ISP(0x12),
+	GLAMO_REG_ISP_DEC_U_ADDRL	= REG_ISP(0x14),
+	GLAMO_REG_ISP_DEC_U_ADDRH	= REG_ISP(0x16),
+	GLAMO_REG_ISP_DEC_V_ADDRL	= REG_ISP(0x18),
+	GLAMO_REG_ISP_DEC_V_ADDRH	= REG_ISP(0x1a),
+	GLAMO_REG_ISP_CAP_SEG_HEIGHT	= REG_ISP(0x1c),
+	GLAMO_REG_ISP_CAP_PITCH		= REG_ISP(0x1e),
+	GLAMO_REG_ISP_CAP_HEIGHT	= REG_ISP(0x20),
+	GLAMO_REG_ISP_CAP_WIDTH		= REG_ISP(0x22),
+	GLAMO_REG_ISP_DEC_PITCH_Y	= REG_ISP(0x24),
+	GLAMO_REG_ISP_DEC_PITCH_UV	= REG_ISP(0x26),
+	GLAMO_REG_ISP_DEC_HEIGHT	= REG_ISP(0x28),
+	GLAMO_REG_ISP_DEC_WIDTH		= REG_ISP(0x2a),
+	GLAMO_REG_ISP_ONFLY_MODE1	= REG_ISP(0x2c),
+	GLAMO_REG_ISP_ONFLY_MODE2	= REG_ISP(0x2e),
+	GLAMO_REG_ISP_ONFLY_MODE3	= REG_ISP(0x30),
+	GLAMO_REG_ISP_ONFLY_MODE4	= REG_ISP(0x32),
+	GLAMO_REG_ISP_ONFLY_MODE5	= REG_ISP(0x34),
+	//
+	GLAMO_REG_ISP_YUV2RGB_11	= REG_ISP(0x50),
+	GLAMO_REG_ISP_YUV2RGB_21	= REG_ISP(0x52),
+	GLAMO_REG_ISP_YUV2RGB_32	= REG_ISP(0x54),
+	GLAMO_REG_ISP_YUV2RGB_33	= REG_ISP(0x56),
+	GLAMO_REG_ISP_YUV2RGB_RG	= REG_ISP(0x58),
+	GLAMO_REG_ISP_YUV2RGB_B		= REG_ISP(0x5a),
+	//
+	GLAMO_REG_ISP_PORT1_SCALEH	= REG_ISP(0x76),
+	GLAMO_REG_ISP_PORT1_SCALEV	= REG_ISP(0x78),
+	GLAMO_REG_ISP_PORT2_SCALEH	= REG_ISP(0x7a),
+	GLAMO_REG_ISP_PORT2_SCALEV	= REG_ISP(0x7c),
+	GLAMO_REG_ISP_DEC_SCALEH	= REG_ISP(0x7e),
+	GLAMO_REG_ISP_DEC_SCALEV	= REG_ISP(0x80),
+	GLAMO_REG_ISP_TURBO		= REG_ISP(0x82),
+	GLAMO_REG_ISP_PORT1_CAP_EN	= REG_ISP(0x84),
+	GLAMO_REG_ISP_PORT1_CAP_0_ADDRL	= REG_ISP(0x86),
+	GLAMO_REG_ISP_PORT1_CAP_0_ADDRH	= REG_ISP(0x88),
+	GLAMO_REG_ISP_PORT1_CAP_1_ADDRL	= REG_ISP(0x8a),
+	GLAMO_REG_ISP_PORT1_CAP_1_ADDRH	= REG_ISP(0x8c),
+	GLAMO_REG_ISP_PORT1_CAP_WIDTH	= REG_ISP(0x8e),
+	GLAMO_REG_ISP_PORT1_CAP_HEIGHT	= REG_ISP(0x90),
+	GLAMO_REG_ISP_PORT1_CAP_PITCH	= REG_ISP(0x92),
+	GLAMO_REG_ISP_PORT1_CAP_CLIP_L	= REG_ISP(0x94),
+	GLAMO_REG_ISP_PORT1_CAP_CLIP_R	= REG_ISP(0x96),
+	GLAMO_REG_ISP_PORT1_CAP_CLIP_T	= REG_ISP(0x98),
+	GLAMO_REG_ISP_PORT1_CAP_CLIP_B	= REG_ISP(0x9a),
+	GLAMO_REG_ISP_PORT1_DEC_EN	= REG_ISP(0x9c),
+	GLAMO_REG_ISP_PORT1_DEC_0_ADDRL	= REG_ISP(0x9e),
+	GLAMO_REG_ISP_PORT1_DEC_0_ADDRH	= REG_ISP(0xa0),
+	GLAMO_REG_ISP_PORT1_DEC_1_ADDRL	= REG_ISP(0xa2),
+	GLAMO_REG_ISP_PORT1_DEC_1_ADDRH	= REG_ISP(0xa4),
+	GLAMO_REG_ISP_PORT1_DEC_WIDTH	= REG_ISP(0xa6),
+	GLAMO_REG_ISP_PORT1_DEC_HEIGHT	= REG_ISP(0xa8),
+	GLAMO_REG_ISP_PORT1_DEC_PITCH	= REG_ISP(0xaa),
+	GLAMO_REG_ISP_PORT1_DEC_CLIP_L	= REG_ISP(0xac),
+	GLAMO_REG_ISP_PORT1_DEC_CLIP_R	= REG_ISP(0xae),
+	GLAMO_REG_ISP_PORT1_DEC_CLIP_T	= REG_ISP(0xb0),
+	GLAMO_REG_ISP_PORT1_DEC_CLIP_B	= REG_ISP(0xb2),
+	GLAMO_REG_ISP_PORT2_EN		= REG_ISP(0xb4),
+	GLAMO_REG_ISP_PORT2_0_Y_ADDRL	= REG_ISP(0xb6),
+	GLAMO_REG_ISP_PORT2_0_Y_ADDRH	= REG_ISP(0xb8),
+	GLAMO_REG_ISP_PORT2_0_U_ADDRL	= REG_ISP(0xba),
+	GLAMO_REG_ISP_PORT2_0_U_ADDRH	= REG_ISP(0xbc),
+	GLAMO_REG_ISP_PORT2_0_V_ADDRL	= REG_ISP(0xbe),
+	GLAMO_REG_ISP_PORT2_0_V_ADDRH	= REG_ISP(0xc0),
+	GLAMO_REG_ISP_PORT2_1_Y_ADDRL	= REG_ISP(0xc2),
+	GLAMO_REG_ISP_PORT2_1_Y_ADDRH	= REG_ISP(0xc4),
+	GLAMO_REG_ISP_PORT2_1_U_ADDRL	= REG_ISP(0xc6),
+	GLAMO_REG_ISP_PORT2_1_U_ADDRH	= REG_ISP(0xc8),
+	GLAMO_REG_ISP_PORT2_1_V_ADDRL	= REG_ISP(0xca),
+	GLAMO_REG_ISP_PORT2_1_V_ADDRH	= REG_ISP(0xcc),
+	GLAMO_REG_ISP_PORT2_2_Y_ADDRL	= REG_ISP(0xce),
+	GLAMO_REG_ISP_PORT2_2_Y_ADDRH	= REG_ISP(0xd0),
+	GLAMO_REG_ISP_PORT2_2_U_ADDRL	= REG_ISP(0xd2),
+	GLAMO_REG_ISP_PORT2_2_U_ADDRH	= REG_ISP(0xd4),
+	GLAMO_REG_ISP_PORT2_2_V_ADDRL	= REG_ISP(0xd6),
+	GLAMO_REG_ISP_PORT2_2_V_ADDRH	= REG_ISP(0xd8),
+	GLAMO_REG_ISP_PORT2_WIDTH	= REG_ISP(0xda),
+	GLAMO_REG_ISP_PORT2_HEIGHT	= REG_ISP(0xdc),
+	GLAMO_REG_ISP_PORT2_Y_PITCH	= REG_ISP(0xde),
+	GLAMO_REG_ISP_PORT2_UV_PITCH	= REG_ISP(0xe0),
+	//
+	GLAMO_REG_ISP_RGB2YUV_11_12	= REG_ISP(0xf6),
+	GLAMO_REG_ISP_RGB2YUV_13_21	= REG_ISP(0xf8),
+	GLAMO_REG_ISP_RGB2YUV_22_23	= REG_ISP(0xfa),
+	GLAMO_REG_ISP_RGB2YUV_31_32	= REG_ISP(0xfc),
+	GLAMO_REG_ISP_RGB2YUV_33	= REG_ISP(0xfe),
+	//
+	GLAMO_REG_ISP_PORT1_SCALEH_MATRIX	= REG_ISP(0x10c),
+	GLAMO_REG_ISP_PORT1_SCALEV_MATRIX	= REG_ISP(0x120),
+	GLAMO_REG_ISP_PORT2_SCALEH_MATRIX	= REG_ISP(0x134),
+	GLAMO_REG_ISP_PORT2_SCALEV_MATRIX	= REG_ISP(0x148),
+	GLAMO_REG_ISP_DEC_SCALEH_MATRIX		= REG_ISP(0x15c),
+	GLAMO_REG_ISP_DEC_SCALEV_MATRIX		= REG_ISP(0x170),
+	GLAMO_REG_ISP_STATUS			= REG_ISP(0x184),
+};
+
+enum glamo_reg_isp_en1 {
+	GLAMO_ISP_EN1_FIRE_ISP		= 0x0001,
+	GLAMO_ISP_EN1_FIRE_CAP		= 0x0002,
+	GLAMO_ISP_EN1_VIDEO_CONF	= 0x0004,
+	GLAMO_ISP_EN1_BAYER_SRC		= 0x0008,
+	//
+	GLAMO_ISP_EN1_YUV_PACK		= 0x0040,
+	GLAMO_ISP_EN1_PLANE_MODE	= 0x0080,
+	GLAMO_ISP_EN1_YUV_INPUT		= 0x0100,
+	GLAMO_ISP_EN1_YUV420		= 0x0200,
+	//
+};
+
+enum glamo_reg_isp_en3 {
+	//
+	GLAMO_ISP_EN3_SCALE_IMPROVE	= 0x0040,
+	GLAMO_ISP_EN3_PLANE_MODE	= 0x0080,
+	GLAMO_ISP_EN3_YUV_INPUT		= 0x0100,
+	GLAMO_ISP_EN3_YUV420		= 0x0200,
+	//
+};
+
+enum glamo_isp_rot_mode {
+	GLAMO_ISP_ROT_MODE_0		= 0x0000,
+	GLAMO_ISP_ROT_MODE_90		= 0x0400,
+	GLAMO_ISP_ROT_MODE_270		= 0x0800,
+	GLAMO_ISP_ROT_MODE_180		= 0x0c00,
+	GLAMO_ISP_ROT_MODE_MIRROR	= 0x1000,
+	GLAMO_ISP_ROT_MODE_FLIP		= 0x1400,
+};
+#define GLAMO_ISP_ROT_MODE_MASK		0x1c00
+
+enum glamo_reg_isp_port1_en {
+	GLAMO_ISP_PORT1_EN_OUTPUT	= 0x0001,
+//	GLAMO_ISP_PORT1_EN_SCALE	= 0x0002,
+	GLAMO_ISP_PORT1_EN_CLIP		= 0x0004,
+	GLAMO_ISP_PORT1_EN_CLIP_OUT	= 0x0008,
+	GLAMO_ISP_PORT1_EN_DUAL_BUF	= 0x0010,
+};
+
+enum glamo_reg_isp_port2_en {
+	GLAMO_ISP_PORT2_EN_OUTPUT	= 0x0001,
+	GLAMO_ISP_PORT2_EN_SCALE	= 0x0002,
+	GLAMO_ISP_PORT2_EN_JPEG		= 0x0010,
+	GLAMO_ISP_PORT2_EN_MPEG		= 0x0020,
+	GLAMO_ISP_PORT2_EN_ENCODE	= 0x0040,
+	GLAMO_ISP_PORT2_EN_DECODE	= 0x0080,
+};
+
+#define REG_MPEG(x)		(GLAMO_REGOFS_MPEG+(x))
+
+enum glamo_register_mpeg {
+	//
+	GLAMO_REG_MPEG_DC_ADDRL		= REG_MPEG(0x3c),
+	GLAMO_REG_MPEG_DC_ADDRH		= REG_MPEG(0x3e),
+	GLAMO_REG_MPEG_AC_ADDRL		= REG_MPEG(0x40),
+	GLAMO_REG_MPEG_AC_ADDRH		= REG_MPEG(0x42),
+	//
+	GLAMO_REG_MPEG_SAFE_1		= REG_MPEG(0x60),
+	GLAMO_REG_MPEG_SAFE_2		= REG_MPEG(0x62),
+	GLAMO_REG_MPEG_SAFE_3		= REG_MPEG(0x64),
+	//
+	GLAMO_REG_MPEG_DEC_OUT0_Y_ADDRL	= REG_MPEG(0x6e),
+	GLAMO_REG_MPEG_DEC_OUT0_Y_ADDRH	= REG_MPEG(0x70),
+	GLAMO_REG_MPEG_DEC_OUT0_U_ADDRL	= REG_MPEG(0x72),
+	GLAMO_REG_MPEG_DEC_OUT0_U_ADDRH	= REG_MPEG(0x74),
+	GLAMO_REG_MPEG_DEC_OUT0_V_ADDRL	= REG_MPEG(0x76),
+	GLAMO_REG_MPEG_DEC_OUT0_V_ADDRH	= REG_MPEG(0x78),
+	GLAMO_REG_MPEG_DEC_OUT1_Y_ADDRL	= REG_MPEG(0x7a),
+	GLAMO_REG_MPEG_DEC_OUT1_Y_ADDRH	= REG_MPEG(0x7c),
+	GLAMO_REG_MPEG_DEC_OUT1_U_ADDRL	= REG_MPEG(0x7e),
+	GLAMO_REG_MPEG_DEC_OUT1_U_ADDRH	= REG_MPEG(0x80),
+	GLAMO_REG_MPEG_DEC_OUT1_V_ADDRL	= REG_MPEG(0x82),
+	GLAMO_REG_MPEG_DEC_OUT1_V_ADDRH	= REG_MPEG(0x84),
+	GLAMO_REG_MPEG_DEC_OUT2_Y_ADDRL	= REG_MPEG(0x86),
+	GLAMO_REG_MPEG_DEC_OUT2_Y_ADDRH	= REG_MPEG(0x88),
+	GLAMO_REG_MPEG_DEC_OUT2_U_ADDRL	= REG_MPEG(0x8a),
+	GLAMO_REG_MPEG_DEC_OUT2_U_ADDRH	= REG_MPEG(0x8c),
+	GLAMO_REG_MPEG_DEC_OUT2_V_ADDRL	= REG_MPEG(0x8e),
+	GLAMO_REG_MPEG_DEC_OUT2_V_ADDRH	= REG_MPEG(0x90),
+	GLAMO_REG_MPEG_DEC_WIDTH	= REG_MPEG(0x92),
+	GLAMO_REG_MPEG_DEC_HEIGHT	= REG_MPEG(0x94),
+	GLAMO_REG_MPEG_SPECIAL		= REG_MPEG(0x96),
+	GLAMO_REG_MPEG_DEC_IN_ADDRL	= REG_MPEG(0x98),
+	GLAMO_REG_MPEG_DEC_IN_ADDRH	= REG_MPEG(0x9a),
+	//
+	GLAMO_REG_MPEG_DEBLK_THRESHOLD	= REG_MPEG(0xc0),
+	//
+	GLAMO_REG_MPEG_DEC_STATUS	= REG_MPEG(0xc8),
+	GLAMO_REG_MPEG_DEC_RB0		= REG_MPEG(0xca),
+	GLAMO_REG_MPEG_DEC_RB1		= REG_MPEG(0xcc),
+};
+
+#define REG_CMDQ(x)		(GLAMO_REGOFS_CMDQUEUE+(x))
+
+enum glamo_register_cq {
+	GLAMO_REG_CMDQ_BASE_ADDRL		= REG_CMDQ(0x00),
+	GLAMO_REG_CMDQ_BASE_ADDRH		= REG_CMDQ(0x02),
+	GLAMO_REG_CMDQ_LEN		= REG_CMDQ(0x04),
+	GLAMO_REG_CMDQ_WRITE_ADDRL	= REG_CMDQ(0x06),
+	GLAMO_REG_CMDQ_WRITE_ADDRH	= REG_CMDQ(0x08),
+	GLAMO_REG_CMDQ_FLIP		= REG_CMDQ(0x0a),
+	GLAMO_REG_CMDQ_CONTROL		= REG_CMDQ(0x0c),
+	GLAMO_REG_CMDQ_READ_ADDRL		= REG_CMDQ(0x0e),
+	GLAMO_REG_CMDQ_READ_ADDRH		= REG_CMDQ(0x10),
+	GLAMO_REG_CMDQ_STATUS		= REG_CMDQ(0x12),
+};
+
+#define REG_2D(x)		(GLAMO_REGOFS_2D+(x))
+
+enum glamo_register_2d {
+	GLAMO_REG_2D_SRC_ADDRL		= REG_2D(0x00),
+	GLAMO_REG_2D_SRC_ADDRH		= REG_2D(0x02),
+	GLAMO_REG_2D_SRC_PITCH		= REG_2D(0x04),
+	GLAMO_REG_2D_SRC_X		= REG_2D(0x06),
+	GLAMO_REG_2D_SRC_Y		= REG_2D(0x08),
+	GLAMO_REG_2D_DST_X		= REG_2D(0x0a),
+	GLAMO_REG_2D_DST_Y		= REG_2D(0x0c),
+	GLAMO_REG_2D_DST_ADDRL		= REG_2D(0x0e),
+	GLAMO_REG_2D_DST_ADDRH		= REG_2D(0x10),
+	GLAMO_REG_2D_DST_PITCH		= REG_2D(0x12),
+	GLAMO_REG_2D_DST_HEIGHT		= REG_2D(0x14),
+	GLAMO_REG_2D_RECT_WIDTH		= REG_2D(0x16),
+	GLAMO_REG_2D_RECT_HEIGHT	= REG_2D(0x18),
+	GLAMO_REG_2D_PAT_ADDRL		= REG_2D(0x1a),
+	GLAMO_REG_2D_PAT_ADDRH		= REG_2D(0x1c),
+	GLAMO_REG_2D_PAT_FG		= REG_2D(0x1e),
+	GLAMO_REG_2D_PAT_BG		= REG_2D(0x20),
+	GLAMO_REG_2D_SRC_FG		= REG_2D(0x22),
+	GLAMO_REG_2D_SRC_BG		= REG_2D(0x24),
+	GLAMO_REG_2D_MASK1		= REG_2D(0x26),
+	GLAMO_REG_2D_MASK2		= REG_2D(0x28),
+	GLAMO_REG_2D_MASK3		= REG_2D(0x2a),
+	GLAMO_REG_2D_MASK4		= REG_2D(0x2c),
+	GLAMO_REG_2D_ROT_X		= REG_2D(0x2e),
+	GLAMO_REG_2D_ROT_Y		= REG_2D(0x30),
+	GLAMO_REG_2D_LEFT_CLIP		= REG_2D(0x32),
+	GLAMO_REG_2D_TOP_CLIP		= REG_2D(0x34),
+	GLAMO_REG_2D_RIGHT_CLIP		= REG_2D(0x36),
+	GLAMO_REG_2D_BOTTOM_CLIP	= REG_2D(0x38),
+	GLAMO_REG_2D_COMMAND1		= REG_2D(0x3A),
+	GLAMO_REG_2D_COMMAND2		= REG_2D(0x3C),
+	GLAMO_REG_2D_COMMAND3		= REG_2D(0x3E),
+	GLAMO_REG_2D_SAFE		= REG_2D(0x40),
+	GLAMO_REG_2D_STATUS		= REG_2D(0x42),
+	GLAMO_REG_2D_ID1		= REG_2D(0x44),
+	GLAMO_REG_2D_ID2		= REG_2D(0x46),
+	GLAMO_REG_2D_ID3		= REG_2D(0x48),
+};
+
+#endif /* _GLAMO_REGS_H */
Index: mplayer/drivers/libglamo/hw.h
===================================================================
--- mplayer.orig/drivers/libglamo/hw.h	(revision 0)
+++ mplayer/drivers/libglamo/hw.h	(revision 0)
@@ -0,0 +1,51 @@
+/*
+ * Library's hardware interface.
+ *
+ * Copyright (C) 2007 OpenMoko, Inc.
+ * Author: Chia-I Wu <olv@openmoko.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 or
+ * (at your option) version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _HW_H_
+#define _HW_H_
+
+#include "glamo-regs.h"
+
+#define GLAMO_MMIO_BASE 0x8000000
+#define GLAMO_MMIO_SIZE 0x2400
+
+#define GLAMO_VRAM_FB	0x000000
+#define GLAMO_VRAM_CMDQ	0x100000
+#define GLAMO_VRAM_ISP	0x200000
+#define GLAMO_VRAM_MPEG	0x300000
+#define GLAMO_VRAM_2D	0x400000
+
+enum glamo_engine {
+	GLAMO_ENGINE_MPEG,
+	GLAMO_ENGINE_ISP,
+	GLAMO_ENGINE_CMDQ,
+	GLAMO_ENGINE_2D, /* should be last one */
+};
+
+typedef unsigned short GLAMO_REG_TYPE;
+
+void glamo_hw_dump(int reg, int len);
+
+void glamo_hw_engine_reset(enum glamo_engine engine);
+void glamo_hw_engine_enable(enum glamo_engine engine);
+void glamo_hw_engine_disable(enum glamo_engine engine);
+
+#endif /* _HW_H */
Index: mplayer/drivers/libglamo/glamo.h
===================================================================
--- mplayer.orig/drivers/libglamo/glamo.h	(revision 0)
+++ mplayer/drivers/libglamo/glamo.h	(revision 0)
@@ -0,0 +1,48 @@
+/*
+ * Glamo chip access library (for graphics).
+ *
+ * Copyright (C) 2007 OpenMoko, Inc.
+ * Author: Chia-I Wu <olv@openmoko.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 or
+ * (at your option) version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _GLAMO_H_
+#define _GLAMO_H_
+
+#define GLAMO_OUT_REG(reg, val) (*((volatile unsigned short *) ((glamo_mmio) + (reg))) = (val))
+#define GLAMO_IN_REG(reg) (*((volatile unsigned short *) ((glamo_mmio) + (reg))))
+
+extern volatile unsigned char *glamo_fb;
+extern volatile unsigned char *glamo_mmio;
+extern int glamo_pitch;
+
+extern int mydiv(int n, int d);
+extern int myrem(int n, int d);
+
+inline static void glamo_set_bit_mask(int reg, int mask, int val)
+{
+	int old;
+
+	old = GLAMO_IN_REG(reg);
+	old &= ~mask;
+	old |= val & mask;
+	GLAMO_OUT_REG(reg, old);
+}
+
+int glamo_os_init(const char *fb_path);
+void glamo_os_finish(void);
+
+#endif /* _GLAMO_H_ */
Index: mplayer/drivers/libglamo/dma.h
===================================================================
--- mplayer.orig/drivers/libglamo/dma.h	(revision 0)
+++ mplayer/drivers/libglamo/dma.h	(revision 0)
@@ -0,0 +1,96 @@
+/*
+ * Glamo DMA engine.
+ *
+ * Copyright (C) 2007 OpenMoko, Inc.
+ * Author: Chia-I Wu <olv@openmoko.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 or
+ * (at your option) version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef _DMA_H_
+#define _DMA_H_
+
+#include <stdlib.h> /* for exit() */
+#include "hw.h"
+
+#define GLAMO_REG_WIDTH sizeof(GLAMO_REG_TYPE)
+
+/*
+ * some engines only support MMIO mode; while
+ * some engines only support CMDQ mode
+ */
+enum glamo_dma_mode {
+	GLAMO_DMA_MODE_MMIO,
+	GLAMO_DMA_MODE_CMDQ,
+};
+
+enum glamo_dma_wait_type {
+	GLAMO_DMA_WAIT_CMDQ,
+	GLAMO_DMA_WAIT_ISP,
+	GLAMO_DMA_WAIT_ALL,
+};
+
+struct glamo_dma_manager {
+	enum glamo_dma_mode mode;
+
+	unsigned char *lbuf;
+	int lsize;
+	int llen;
+
+	volatile GLAMO_REG_TYPE *cmdq;
+	int size;
+	int r;
+	int w;
+};
+
+struct glamo_dma_manager *glamo_dma_new(enum glamo_dma_mode t);
+void glamo_dma_destroy(struct glamo_dma_manager *dma);
+void glamo_dma_flush(struct glamo_dma_manager *dma);
+void glamo_dma_wait(struct glamo_dma_manager *dma, enum glamo_dma_wait_type t);
+void glamo_dma_dump(struct glamo_dma_manager *dma);
+
+#define GLAMO_DMA_VARS	\
+	GLAMO_REG_TYPE *__p; int __count, __total
+
+#define GLAMO_DMA_BEGIN(dma, n)						\
+	do {								\
+		if (dma->llen + n * GLAMO_REG_WIDTH > dma->lsize)	\
+			glamo_dma_flush(dma);				\
+		__p = (GLAMO_REG_TYPE *) (dma->lbuf + dma->llen);	\
+		__count = 0; __total = n;				\
+	} while (0)
+
+#define GLAMO_DMA_OUT(dma, v1, v2)	\
+	do {				\
+		__p[__count++] = v1;	\
+		__p[__count++] = v2;	\
+	} while (0)
+
+#define GLAMO_DMA_END(dma)						\
+	do {								\
+		if (__count != __total)					\
+		{							\
+			fprintf(stderr, "count != total (%d != %d) "	\
+					"at %s:%d\n", __count, __total,	\
+					__FILE__, __LINE__);		\
+			exit(1);					\
+		}							\
+		dma->llen += __count * GLAMO_REG_WIDTH;			\
+	} while (0)
+
+#define GLAMO_DMA_BURST(dma, reg, n)		\
+	GLAMO_DMA_OUT(dma, (1 << 15) | reg, n)
+
+#endif /* _DMA_H */
Index: mplayer/drivers/libglamo/blit.c
===================================================================
--- mplayer.orig/drivers/libglamo/blit.c	(revision 0)
+++ mplayer/drivers/libglamo/blit.c	(revision 0)
@@ -0,0 +1,464 @@
+/*
+ * Image blitting support using the 2D engine.
+ *
+ * Copyright (C) 2007 OpenMoko, Inc.
+ * Author: Chia-I Wu <olv@openmoko.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 or
+ * (at your option) version 3 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include "glamo.h"
+#include "hw.h"
+#include "dma.h"
+#include "blit.h"
+
+int mydiv(int n, int d)
+{
+	int q;
+
+	for (q = 0; n >= d; n -= d)
+		q ++;
+
+	return q;
+}
+
+int myrem(int n, int d)
+{
+	for (; n >= d; n -= d);
+
+	return n;
+}
+
+static void blit_set_onfly_regs(struct glamo_dma_manager *dma)
+{
+	struct {
+		int src_block_x;
+		int src_block_y;
+		int src_block_w;
+		int src_block_h;
+		int jpeg_out_y;
+		int jpeg_out_x;
+		int fifo_full_cnt;
+		int in_length;
+		int fifo_data_cnt;
+		int in_height;
+	} onfly;
+	GLAMO_DMA_VARS;
+
+	onfly.src_block_y = 32;
+	onfly.src_block_x = 32;
+	onfly.src_block_w = 36;
+	onfly.src_block_h = 35;
+	onfly.jpeg_out_y = 32;
+	onfly.jpeg_out_x = 32;
+	onfly.fifo_full_cnt = onfly.src_block_w * 2 + 2;
+	onfly.in_length = onfly.jpeg_out_x + 3;
+	onfly.fifo_data_cnt = (onfly.src_block_w * onfly.src_block_h) >> 1;
+	onfly.in_height = onfly.jpeg_out_y + 2;
+
+	GLAMO_DMA_BEGIN(dma, 10);
+	GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_ONFLY_MODE1, onfly.src_block_y << 10 | onfly.src_block_x << 2);
+	GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_ONFLY_MODE2, onfly.src_block_h << 8 | onfly.src_block_w);
+	GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_ONFLY_MODE3, onfly.jpeg_out_y << 8 | onfly.jpeg_out_x);
+	GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_ONFLY_MODE4, onfly.fifo_full_cnt << 8 | onfly.in_length);
+	GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_ONFLY_MODE5, onfly.fifo_data_cnt << 6 | onfly.in_height);
+
+	/* Smedia suggests these values */
+	//GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_ONFLY_MODE1, 0x8080);
+	//GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_ONFLY_MODE2, 0x2526);
+	//GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_ONFLY_MODE3, 0x2020);
+	//GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_ONFLY_MODE4, 0x5023);
+	//GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_ONFLY_MODE5, 0xafe2);
+
+	/* another set of values they suggest */
+	//GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_ONFLY_MODE1, 0x8080);
+	//GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_ONFLY_MODE2, 0x2324);
+	//GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_ONFLY_MODE3, 0x2020);
+	//GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_ONFLY_MODE4, 0x4a23);
+	//GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_ONFLY_MODE5, 0x9da2);
+
+	GLAMO_DMA_END(dma);
+}
+
+static void blit_set_weight_regs(struct glamo_dma_manager *dma)
+{
+	int left = 1 << 14;
+	GLAMO_DMA_VARS;
+
+	/* nearest */
+
+	GLAMO_DMA_BEGIN(dma, 12);
+	GLAMO_DMA_BURST(dma, GLAMO_REG_ISP_DEC_SCALEH_MATRIX, 10);
+	GLAMO_DMA_OUT(dma, left, 0);
+	GLAMO_DMA_OUT(dma, left, 0);
+	GLAMO_DMA_OUT(dma, left, 0);
+	GLAMO_DMA_OUT(dma, left, 0);
+	GLAMO_DMA_OUT(dma, left, 0);
+	GLAMO_DMA_END(dma);
+
+	GLAMO_DMA_BEGIN(dma, 12);
+	GLAMO_DMA_BURST(dma, GLAMO_REG_ISP_DEC_SCALEV_MATRIX, 10);
+	GLAMO_DMA_OUT(dma, left, 0);
+	GLAMO_DMA_OUT(dma, left, 0);
+	GLAMO_DMA_OUT(dma, left, 0);
+	GLAMO_DMA_OUT(dma, left, 0);
+	GLAMO_DMA_OUT(dma, left, 0);
+	GLAMO_DMA_END(dma);
+}
+
+struct glamo_blit_manager *glamo_blit_new(struct glamo_dma_manager *dma,
+		enum glamo_blit_format format)
+{
+	struct glamo_blit_manager *blit;
+	int en3;
+	GLAMO_DMA_VARS;
+
+	blit = malloc(sizeof(*blit));
+	if (!blit)
+		return NULL;
+
+	blit->dma = dma;
+	blit->format = format;
+
+	glamo_hw_engine_enable(GLAMO_ENGINE_ISP);
+	glamo_hw_engine_reset(GLAMO_ENGINE_ISP);
+
+	switch (blit->format)
+	{
+	case GLAMO_BLIT_FORMAT_I420:
+		en3 = GLAMO_ISP_EN3_PLANE_MODE |
+		      GLAMO_ISP_EN3_YUV_INPUT |
+		      GLAMO_ISP_EN3_YUV420;
+		break;
+	case GLAMO_BLIT_FORMAT_YV16:
+		en3 = GLAMO_ISP_EN3_PLANE_MODE |
+		      GLAMO_ISP_EN3_YUV_INPUT;
+		break;
+	case GLAMO_BLIT_FORMAT_YUY2:
+		en3 = GLAMO_ISP_EN3_YUV_INPUT;
+		break;
+	default:
+		return NULL;
+	}
+	en3 |= GLAMO_ISP_EN3_SCALE_IMPROVE;
+
+	GLAMO_DMA_BEGIN(dma, 18);
+
+	/*
+	 * In 8.8 fixed point,
+	 *
+	 *  R = Y + 1.402 (Cr-128)
+	 *    = Y + 0x0167 Cr - 0xb3
+	 *
+	 *  G = Y - 0.34414 (Cb-128) - 0.71414 (Cr-128)
+	 *    = Y - 0x0058 Cb - 0x00b6 Cr + 0x89
+	 *
+	 *  B = Y + 1.772 (Cb-128)
+	 *    = Y + 0x01c5 Cb - 0xe2
+	 */
+	GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_YUV2RGB_11, 0x0167);
+	GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_YUV2RGB_21, 0x01c5);
+	GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_YUV2RGB_32, 0x00b6);
+	GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_YUV2RGB_33, 0x0058);
+	GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_YUV2RGB_RG, 0xb3 << 8 | 0x89);
+	GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_YUV2RGB_B, 0xe2);
+
+	GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_EN3, en3);
+
+	GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_PORT1_DEC_EN, GLAMO_ISP_PORT1_EN_OUTPUT);
+	GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_PORT2_EN, GLAMO_ISP_PORT2_EN_DECODE);
+
+	GLAMO_DMA_END(dma);
+
+	blit_set_onfly_regs(dma);
+	blit_set_weight_regs(dma);
+
+	return blit;
+}
+
+void glamo_blit_rotate(struct glamo_blit_manager *blit, 
+		enum glamo_blit_rotation rot)
+{
+	int en4;
+	GLAMO_DMA_VARS;
+
+	switch (rot)
+	{
+	case GLAMO_BLIT_ROTATION_0:
+		en4 = GLAMO_ISP_ROT_MODE_0;
+		break;
+	case GLAMO_BLIT_ROTATION_90:
+		en4 = GLAMO_ISP_ROT_MODE_90;
+		break;
+	case GLAMO_BLIT_ROTATION_270:
+		en4 = GLAMO_ISP_ROT_MODE_270;
+		break;
+	case GLAMO_BLIT_ROTATION_180:
+		en4 = GLAMO_ISP_ROT_MODE_180;
+		break;
+	case GLAMO_BLIT_ROTATION_MIRROR:
+		en4 = GLAMO_ISP_ROT_MODE_MIRROR;
+		break;
+	case GLAMO_BLIT_ROTATION_FLIP:
+		en4 = GLAMO_ISP_ROT_MODE_FLIP;
+		break;
+	default:
+		return;
+	}
+
+	GLAMO_DMA_BEGIN(blit->dma, 2);
+	GLAMO_DMA_OUT(blit->dma, GLAMO_REG_ISP_EN4, en4);
+	GLAMO_DMA_END(blit->dma);
+}
+
+void glamo_blit_destroy(struct glamo_blit_manager *blit)
+{
+	glamo_hw_engine_reset(GLAMO_ENGINE_ISP);
+	glamo_hw_engine_disable(GLAMO_ENGINE_ISP);
+
+	free(blit);
+}
+
+void glamo_blit_wait(struct glamo_blit_manager *blit)
+{
+	while (1)
+	{
+		int val = GLAMO_IN_REG(GLAMO_REG_ISP_STATUS);
+		if (val & 0x1)
+		{
+			usleep(1 * 1000);
+
+			continue;
+		}
+
+		break;
+	}
+}
+
+void glamo_blit_dump(struct glamo_blit_manager *blit)
+{
+	glamo_hw_dump(GLAMO_REG_ISP_EN1, ((GLAMO_REG_ISP_STATUS - GLAMO_REG_ISP_EN1) >> 1) + 1);
+}
+
+struct glamo_blit_image *glamo_blit_new_image(struct glamo_blit_manager *blit,
+		const unsigned char *data, int width, int height)
+{
+	struct glamo_blit_image *image;
+
+	switch (blit->format)
+	{
+	case GLAMO_BLIT_FORMAT_I420:
+		if (width & 1 || height & 1)
+			return NULL;
+		break;
+	case GLAMO_BLIT_FORMAT_YV16:
+		if (width & 1 || height & 1)
+			return NULL;
+		break;
+	case GLAMO_BLIT_FORMAT_YUY2:
+		break;
+	}
+
+	image = malloc(sizeof(*image));
+	if (!image)
+		return NULL;
+
+	image->format = blit->format;
+	image->data = data;
+	image->width = width;
+	image->height = height;
+
+	switch (image->format)
+	{
+	case GLAMO_BLIT_FORMAT_I420:
+		image->num_planes = 3;
+
+		image->pitches[0] = width;
+		image->offsets[0] = 0;
+
+		image->pitches[1] = width >> 1;
+		image->offsets[1] = image->offsets[0] + image->pitches[0] * image->height;
+
+		image->pitches[2] = width >> 1;
+		image->offsets[2] = image->offsets[1] + ((image->pitches[1] * image->height) >> 1);
+		break;
+	case GLAMO_BLIT_FORMAT_YV16:
+		image->num_planes = 3;
+
+		image->pitches[0] = width;
+		image->offsets[0] = 0;
+
+		image->pitches[1] = width >> 1;
+		image->offsets[1] = image->offsets[0] + image->pitches[0] * image->height;
+
+		image->pitches[2] = width >> 1;
+		image->offsets[2] = image->offsets[1] + image->pitches[1] * image->height;
+		break;
+	case GLAMO_BLIT_FORMAT_YUY2:
+		image->num_planes = 1;
+		image->pitches[0] = width * 2;
+		image->offsets[0] = 0;
+		break;
+	}
+
+	return image;
+}
+
+void glamo_blit_destroy_image(struct glamo_blit_manager *blit, struct glamo_blit_image *image)
+{
+	free(image);
+}
+
+void glamo_blit_dump_image(struct glamo_blit_manager *blit, struct glamo_blit_image *image)
+{
+	int i;
+
+	printf("dumping image\n"
+	       "format 0x%x\n"
+	       "data 0x%x\n"
+	       "width %d\n"
+	       "height %d\n"
+	       "num_planes %d\n",
+	       image->format,
+	       (unsigned int) image->data,
+	       image->width,
+	       image->height,
+	       image->num_planes);
+
+	for (i = 0; i < image->num_planes; i++)
+	{
+		printf("pitches[%d] %d\n"
+		       "offsets[%d] %d\n",
+		       i, image->pitches[i],
+		       i, image->offsets[i]);
+	}
+}
+
+static void blit_image_regs(struct glamo_dma_manager *dma, struct glamo_blit_image *image)
+{
+	unsigned int offset;
+	GLAMO_DMA_VARS;
+
+	switch (image->format)
+	{
+	case GLAMO_BLIT_FORMAT_I420:
+	case GLAMO_BLIT_FORMAT_YV16:
+		GLAMO_DMA_BEGIN(dma, 20);
+
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_DEC_PITCH_Y, image->pitches[0]);
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_DEC_PITCH_UV, image->pitches[1]);
+
+		offset = (unsigned int) image->data + image->offsets[0];
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_DEC_Y_ADDRL, offset & 0xffff);
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_DEC_Y_ADDRH, (offset >> 16) & 0x7f);
+
+		offset = (unsigned int) image->data + image->offsets[1];
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_DEC_U_ADDRL, offset & 0xffff);
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_DEC_U_ADDRH, (offset >> 16) & 0x7f);
+
+		offset = (unsigned int) image->data + image->offsets[2];
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_DEC_V_ADDRL, offset & 0xffff);
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_DEC_V_ADDRH, (offset >> 16) & 0x7f);
+
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_DEC_HEIGHT, image->height);
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_DEC_WIDTH, image->width);
+
+		GLAMO_DMA_END(dma);
+		break;
+	case GLAMO_BLIT_FORMAT_YUY2:
+		GLAMO_DMA_BEGIN(dma, 10);
+
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_CAP_PITCH, image->pitches[0]);
+
+		offset = (unsigned int) image->data + image->offsets[0];
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_CAP_0_ADDRL, offset & 0xffff);
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_CAP_0_ADDRH, (offset >> 16) & 0x7f);
+
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_CAP_HEIGHT, image->height);
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_CAP_WIDTH, image->width);
+
+		GLAMO_DMA_END(dma);
+		break;
+	}
+}
+
+static void blit_port_regs(struct glamo_dma_manager *dma, struct glamo_blit_image *image,
+		int x, int y, int width, int height)
+{
+	unsigned int offset, scale;
+	GLAMO_DMA_VARS;
+
+	offset = y * glamo_pitch + x * 2;
+
+	switch (image->format)
+	{
+	case GLAMO_BLIT_FORMAT_I420:
+	case GLAMO_BLIT_FORMAT_YV16:
+		GLAMO_DMA_BEGIN(dma, 14);
+
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_PORT1_DEC_PITCH, glamo_pitch);
+
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_PORT1_DEC_0_ADDRL, offset & 0xffff);
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_PORT1_DEC_0_ADDRH, (offset >> 16) & 0x7f);
+
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_PORT1_DEC_WIDTH, width);
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_PORT1_DEC_HEIGHT, height);
+
+		scale = mydiv((image->width << 11), width);
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_DEC_SCALEH, scale);
+
+		scale = mydiv((image->height << 11), height);
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_DEC_SCALEV, scale);
+
+		GLAMO_DMA_END(dma);
+		break;
+	case GLAMO_BLIT_FORMAT_YUY2:
+		GLAMO_DMA_BEGIN(dma, 14);
+
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_PORT1_CAP_PITCH, glamo_pitch);
+
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_PORT1_CAP_0_ADDRL, offset & 0xffff);
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_PORT1_CAP_0_ADDRH, (offset >> 16) & 0x7f);
+
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_PORT1_CAP_WIDTH, width);
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_PORT1_CAP_HEIGHT, height);
+
+		scale = mydiv((image->width << 11), width);
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_DEC_SCALEH, scale);
+
+		scale = mydiv((image->height << 11), height);
+		GLAMO_DMA_OUT(dma, GLAMO_REG_ISP_DEC_SCALEV, scale);
+
+		GLAMO_DMA_END(dma);
+		break;
+	}
+}
+
+void glamo_blit_show_image(struct glamo_blit_manager *blit, struct glamo_blit_image *image,
+		int x, int y, int width, int height)
+{
+	blit_image_regs(blit->dma, image);
+	blit_port_regs(blit->dma, image, x, y, width, height);
+
+	glamo_dma_flush(blit->dma);
+	glamo_dma_wait(blit->dma, GLAMO_DMA_WAIT_CMDQ);
+
+	glamo_set_bit_mask(GLAMO_REG_ISP_EN1, GLAMO_ISP_EN1_FIRE_ISP, 0xffff);
+	glamo_set_bit_mask(GLAMO_REG_ISP_EN1, GLAMO_ISP_EN1_FIRE_ISP, 0);
+}
