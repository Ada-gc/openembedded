diff -uNr linux-2.6.5-orig/arch/arm/Kconfig linux-2.6.5/arch/arm/Kconfig
--- linux-2.6.5-orig/arch/arm/Kconfig	2004-06-14 20:31:51.000000000 +0100
+++ linux-2.6.5/arch/arm/Kconfig	2004-06-14 20:33:06.000000000 +0100
@@ -500,7 +500,7 @@
 
 config LEDS
 	bool "Timer and CPU usage LEDs"
-	depends on ARCH_NETWINDER || ARCH_EBSA110 || ARCH_EBSA285 || ARCH_FTVPCI || ARCH_SHARK || ARCH_CO285 || ARCH_SA1100 || ARCH_LUBBOCK || ARCH_PXA_IDP || MACH_POODLE || ARCH_INTEGRATOR || ARCH_CDB89712 || ARCH_P720T
+	depends on ARCH_NETWINDER || ARCH_EBSA110 || ARCH_EBSA285 || ARCH_FTVPCI || ARCH_SHARK || ARCH_CO285 || ARCH_SA1100 || ARCH_LUBBOCK || ARCH_PXA_IDP || MACH_POODLE || MACH_HUSKY || ARCH_INTEGRATOR || ARCH_CDB89712 || ARCH_P720T
 	help
 	  If you say Y here, the LEDs on your machine will be used
 	  to provide useful information about your current system status.
@@ -513,8 +513,8 @@
 	  system, but the driver will do nothing.
 
 config LEDS_TIMER
-	bool "Timer LED" if LEDS && (ARCH_NETWINDER || ARCH_EBSA285 || ARCH_SHARK || ARCH_CO285 || ARCH_SA1100 || ARCH_LUBBOCK || ARCH_PXA_IDP || MACH_POODLE || ARCH_INTEGRATOR || ARCH_P720T)
-	depends on ARCH_NETWINDER || ARCH_EBSA110 || ARCH_EBSA285 || ARCH_FTVPCI || ARCH_SHARK || ARCH_CO285 || ARCH_SA1100 || ARCH_LUBBOCK || ARCH_PXA_IDP || MACH_POODLE || ARCH_INTEGRATOR || ARCH_CDB89712 || ARCH_P720T
+	bool "Timer LED" if LEDS && (ARCH_NETWINDER || ARCH_EBSA285 || ARCH_SHARK || ARCH_CO285 || ARCH_SA1100 || ARCH_LUBBOCK || ARCH_PXA_IDP || MACH_POODLE || MACH_HUSKY || ARCH_INTEGRATOR || ARCH_P720T)
+	depends on ARCH_NETWINDER || ARCH_EBSA110 || ARCH_EBSA285 || ARCH_FTVPCI || ARCH_SHARK || ARCH_CO285 || ARCH_SA1100 || ARCH_LUBBOCK || ARCH_PXA_IDP || MACH_POODLE || MACH_HUSKY || ARCH_INTEGRATOR || ARCH_CDB89712 || ARCH_P720T
 	default y if ARCH_EBSA110
 	help
 	  If you say Y here, one of the system LEDs (the green one on the
@@ -529,7 +529,7 @@
 
 config LEDS_CPU
 	bool "CPU usage LED"
-	depends on LEDS && (ARCH_NETWINDER || ARCH_EBSA285 || ARCH_SHARK || ARCH_CO285 || ARCH_SA1100 || ARCH_LUBBOCK || ARCH_PXA_IDP || MACH_POODLE || ARCH_INTEGRATOR || ARCH_P720T)
+	depends on LEDS && (ARCH_NETWINDER || ARCH_EBSA285 || ARCH_SHARK || ARCH_CO285 || ARCH_SA1100 || ARCH_LUBBOCK || ARCH_PXA_IDP || MACH_POODLE || MACH_HUSKY || ARCH_INTEGRATOR || ARCH_P720T)
 	help
 	  If you say Y here, the red LED will be used to give a good real
 	  time indication of CPU usage, by lighting whenever the idle task
diff -uNr linux-2.6.5-orig/arch/arm/Makefile linux-2.6.5/arch/arm/Makefile
--- linux-2.6.5-orig/arch/arm/Makefile	2004-06-14 20:31:51.000000000 +0100
+++ linux-2.6.5/arch/arm/Makefile	2004-06-14 20:33:06.000000000 +0100
@@ -54,8 +54,8 @@
 tune-$(CONFIG_CPU_V6)		:=-mtune=strongarm
 
 # Need -Uarm for gcc < 3.x
-CFLAGS		+=-mapcs-32 $(arch-y) $(tune-y) -mshort-load-bytes -msoft-float -Wa,-mno-fpu -Uarm
-AFLAGS		+=-mapcs-32 $(arch-y) $(tune-y) -msoft-float -Wa,-mno-fpu
+CFLAGS		+=-mapcs-32 $(arch-y) $(tune-y) -malignment-traps -msoft-float
+AFLAGS		+=-mapcs-32 $(arch-y) $(tune-y) -msoft-float
 
 #Default value
 DATAADDR	:= .
diff -uNr linux-2.6.5-orig/arch/arm/boot/compressed/Makefile linux-2.6.5/arch/arm/boot/compressed/Makefile
--- linux-2.6.5-orig/arch/arm/boot/compressed/Makefile	2004-06-14 20:31:52.000000000 +0100
+++ linux-2.6.5/arch/arm/boot/compressed/Makefile	2004-06-14 20:33:06.000000000 +0100
@@ -55,14 +55,18 @@
 OBJS		+= head-xscale.o
 endif
 
+ifeq ($(CONFIG_DEBUG_ICEDCC),y)
+OBJS            += ice-dcc.o
+endif
+
 SEDFLAGS	= s/TEXT_START/$(ZTEXTADDR)/;s/LOAD_ADDR/$(ZRELADDR)/;s/BSS_START/$(ZBSSADDR)/
 
 targets       := vmlinux vmlinux.lds piggy piggy.gz piggy.o \
                  font.o head.o $(OBJS)
 EXTRA_CFLAGS  := -fpic
-EXTRA_AFLAGS  := -traditional
+EXTRA_AFLAGS  :=
 
-LDFLAGS_vmlinux := -p -X \
+LDFLAGS_vmlinux := -p --no-undefined -X \
 	$(shell $(CC) $(CFLAGS) --print-libgcc-file-name) -T
 
 $(obj)/vmlinux: $(obj)/vmlinux.lds $(obj)/$(HEAD) $(obj)/piggy.o \
diff -uNr linux-2.6.5-orig/arch/arm/boot/compressed/head-xscale.S linux-2.6.5/arch/arm/boot/compressed/head-xscale.S
--- linux-2.6.5-orig/arch/arm/boot/compressed/head-xscale.S	2004-06-14 20:31:52.000000000 +0100
+++ linux-2.6.5/arch/arm/boot/compressed/head-xscale.S	2004-06-14 20:33:06.000000000 +0100
@@ -52,6 +52,18 @@
 		mov	r7, #MACH_TYPE_POODLE
 #endif
 
+#ifdef CONFIG_MACH_CORGI
+@		mov	r7, #MACH_TYPE_CORGI
+		mov	r7, #0xa7
+		add 	r7, r7, #0x100
+#endif
+
+#ifdef CONFIG_MACH_HUSKY
+@		mov	r7, #MACH_TYPE_HUSKY
+		mov	r7, #0xde
+		add 	r7, r7, #0x100
+#endif
+
 #ifdef CONFIG_ARCH_IQ80310
 		/*
 		 * Crank the CPU up to 733MHz
diff -uNr linux-2.6.5-orig/arch/arm/boot/compressed/head.S linux-2.6.5/arch/arm/boot/compressed/head.S
--- linux-2.6.5-orig/arch/arm/boot/compressed/head.S	2004-06-14 20:31:53.000000000 +0100
+++ linux-2.6.5/arch/arm/boot/compressed/head.S	2004-06-14 20:33:06.000000000 +0100
@@ -10,6 +10,8 @@
 #include <linux/config.h>
 #include <linux/linkage.h>
 
+#define DEBUG 1
+
 /*
  * Debugging stuff
  *
@@ -25,6 +27,12 @@
 		.macro	writeb, rb
 		str	\rb, [r3, #0x160]
 		.endm
+#elif defined(CONFIG_DEBUG_ICEDCC)
+		.macro	loadsp, rb
+		.endm
+		.macro writeb, rb
+		mcr	p14, 0, \rb, c0, c1, 0
+		.endm
 #elif defined(CONFIG_FOOTBRIDGE)
 		.macro	loadsp,	rb
 		mov	\rb, #0x7c000000
@@ -67,6 +75,19 @@
 		.macro	writeb, rb
 		str	\rb, [r3, #0x14]	@ UTDR
 		.endm
+#elif defined(CONFIG_ARCH_IXP4XX)
+		.macro	loadsp, rb
+		mov	\rb, #0xc8000000
+		.endm
+		.macro	writeb, rb
+		str	\rb, [r3, #0]
+#elif defined(CONFIG_ARCH_LH7A40X)
+		.macro	loadsp, rb
+		ldr	\rb, =0x80000700	@ UART2 UARTBASE
+		.endm
+		.macro	writeb, rb
+		strb	\rb, [r3, #0]
+		.endm
 #else
 #error no serial architecture defined
 #endif
@@ -332,11 +353,19 @@
 		mov	r8, r0, lsr #18
 		mov	r8, r8, lsl #18		@ start of RAM
 		add	r9, r8, #0x10000000	@ a reasonable RAM size
-		mov	r1, #0x12
+@#ifdef CONFIG_CPU_XSCALE
+		mov	r1, #0x02
+@#else
+@		mov	r1, #0x12
+@#endif
 		orr	r1, r1, #3 << 10
 		add	r2, r3, #16384
 1:		cmp	r1, r8			@ if virt > start of RAM
-		orrhs	r1, r1, #0x0c		@ set cacheable, bufferable
+@#ifdef CONFIG_XSCALE_CACHE_ERRATA
+		orrhs	r1, r1, #0x08           @ set cacheable, not bufferable
+@#else
+@		orrhs	r1, r1, #0x0c		@ set cacheable, bufferable
+@#endif
 		cmp	r1, r9			@ if virt > end of RAM
 		bichs	r1, r1, #0x0c		@ clear cacheable, bufferable
 		str	r1, [r0], #4		@ 1:1 mapping
diff -uNr linux-2.6.5-orig/arch/arm/boot/compressed/vmlinux.lds.in linux-2.6.5/arch/arm/boot/compressed/vmlinux.lds.in
--- linux-2.6.5-orig/arch/arm/boot/compressed/vmlinux.lds.in	2004-06-14 20:31:53.000000000 +0100
+++ linux-2.6.5/arch/arm/boot/compressed/vmlinux.lds.in	2004-06-14 20:33:06.000000000 +0100
@@ -47,7 +47,7 @@
   .bss			: { *(.bss) }
   _end = .;
 
-  .stack (NOLOAD)	: { *(.stack) }
+  .stack 	: { *(.stack) }
 
   .stab 0		: { *(.stab) }
   .stabstr 0		: { *(.stabstr) }
diff -uNr linux-2.6.5-orig/arch/arm/mach-pxa/Kconfig linux-2.6.5/arch/arm/mach-pxa/Kconfig
--- linux-2.6.5-orig/arch/arm/mach-pxa/Kconfig	2004-06-14 20:31:53.000000000 +0100
+++ linux-2.6.5/arch/arm/mach-pxa/Kconfig	2004-06-14 20:33:06.000000000 +0100
@@ -13,10 +13,23 @@
 	bool "SHARP Poodle"
 	depends on ARCH_PXA
 
+config MACH_CORGI
+	bool "SHARP Corgi (SL-C700)"
+	depends on ARCH_PXA 
+
+config MACH_SHEPHERD
+	bool "SHARP Shepherd (SL-C750)"
+	depends on ARCH_PXA 
+
+config MACH_HUSKY
+	bool "SHARP Husky (SL-C760)"
+	depends on ARCH_PXA 
+
 config SHARP_LOCOMO
 	bool "SHARP LoCoMo support"
 	default Y
-	depends MACH_POODLE
+	depends MACH_POODLE || MACH_CORGI || MACH_HUSKY
+
 
 endmenu
 
diff -uNr linux-2.6.5-orig/arch/arm/mach-pxa/Makefile linux-2.6.5/arch/arm/mach-pxa/Makefile
--- linux-2.6.5-orig/arch/arm/mach-pxa/Makefile	2004-06-14 20:31:54.000000000 +0100
+++ linux-2.6.5/arch/arm/mach-pxa/Makefile	2004-06-14 20:33:06.000000000 +0100
@@ -9,12 +9,18 @@
 obj-$(CONFIG_ARCH_LUBBOCK)	+= lubbock.o
 obj-$(CONFIG_ARCH_PXA_IDP)	+= idp.o
 obj-$(CONFIG_MACH_POODLE)	+= poodle.o
+obj-$(CONFIG_MACH_CORGI)	+= corgi.o
+obj-$(CONFIG_MACH_SHEPHERD)	+= corgi.o
+obj-$(CONFIG_MACH_HUSKY)	+= corgi.o
 
 # Support for blinky lights
 led-y := leds.o
 led-$(CONFIG_ARCH_LUBBOCK)	+= leds-lubbock.o
 led-$(CONFIG_ARCH_PXA_IDP)	+= leds-idp.o
 led-$(CONFIG_MACH_POODLE)	+= leds-poodle.o
+led-$(CONFIG_MACH_CORGI)	+= leds-corgi.o
+led-$(CONFIG_MACH_SHEPHERD)	+= leds-corgi.o
+led-$(CONFIG_MACH_HUSKY)	+= leds-corgi.o
 
 obj-$(CONFIG_LEDS) += $(led-y)
 
diff -uNr linux-2.6.5-orig/arch/arm/mach-pxa/corgi.c linux-2.6.5/arch/arm/mach-pxa/corgi.c
--- linux-2.6.5-orig/arch/arm/mach-pxa/corgi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5/arch/arm/mach-pxa/corgi.c	2004-06-14 20:33:19.000000000 +0100
@@ -0,0 +1,178 @@
+/*
+ * linux/arch/arm/mach-pxa/corgi.c
+ *
+ *  Support for the SHARP Corgi Board.
+ *  
+ *  Copyright:	Lineo Japan Inc.
+ *
+ * Based on:
+ *  linux/arch/arm/mach-pxa/lubbock.c
+ *
+ *  Support for the Intel DBPXA250 Development Platform.
+ *  
+ *  Author:	Nicolas Pitre
+ *  Created:	Jun 15, 2001
+ *  Copyright:	MontaVista Software Inc.
+ *  
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ * Change Log
+ *  12-Dec-2002 Sharp Corporation for Corgi
+ *  01-Apr-2003 Sharp for Shepherd
+ *
+ *  Mar 10, 2004: Lots of changes to port to 2.6 by John Lenz
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/major.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+
+#include <asm/setup.h>
+#include <asm/memory.h>
+#include <asm/mach-types.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/irq.h>
+#include <asm/arch/corgi.h>
+
+#include "generic.h"
+
+static void __init scoop_init(void)
+{
+
+#define	CORGI_SCP_INIT_DATA(adr,dat)	(((adr)<<16)|(dat))
+#define	CORGI_SCP_INIT_DATA_END	((unsigned long)-1)
+	static const unsigned long scp_init[] =
+	{
+		CORGI_SCP_INIT_DATA(CORGI_SCP_MCR,0x0140),  // 00
+		CORGI_SCP_INIT_DATA(CORGI_SCP_MCR,0x0100),
+		CORGI_SCP_INIT_DATA(CORGI_SCP_CDR,0x0000),  // 04
+		CORGI_SCP_INIT_DATA(CORGI_SCP_CPR,0x0000),  // 0C
+		CORGI_SCP_INIT_DATA(CORGI_SCP_CCR,0x0000),  // 10
+		CORGI_SCP_INIT_DATA(CORGI_SCP_IMR,0x0000),  // 18
+		CORGI_SCP_INIT_DATA(CORGI_SCP_IRM,0x00FF),  // 14
+		CORGI_SCP_INIT_DATA(CORGI_SCP_ISR,0x0000),  // 1C
+		CORGI_SCP_INIT_DATA(CORGI_SCP_IRM,0x0000),
+		CORGI_SCP_INIT_DATA(CORGI_SCP_GPCR,CORGI_SCP_IO_DIR),  // 20
+		CORGI_SCP_INIT_DATA(CORGI_SCP_GPWR,CORGI_SCP_IO_OUT),  // 24
+		CORGI_SCP_INIT_DATA_END
+	};
+	int	i;
+	for(i=0; scp_init[i] != CORGI_SCP_INIT_DATA_END; i++)
+	{
+		int	adr = scp_init[i] >> 16;
+		CORGI_SCP_REG(adr) = scp_init[i] & 0xFFFF;
+	}
+}
+
+static void __init corgi_init_irq(void)
+{
+	pxa_init_irq();
+
+	/* setup extra corgi irqs */
+
+	/* i2c initialize */
+	//i2c_init(); RPP Fixme!
+
+	/* scoop initialize */
+	scoop_init();
+
+	/* initialize SSP & CS */
+	/*pxa_ssp_init();*/
+}
+
+#if 0
+static void __init
+fixup_corgi(struct machine_desc *desc, struct param_struct *params,
+		char **cmdline, struct meminfo *mi)
+{
+#if defined(CONFIG_MACH_SHEPHERD) || defined(CONFIG_MACH_HUSKY)
+	SET_BANK (0, 0xa0000000, 64*1024*1024);
+#else
+	SET_BANK (0, 0xa0000000, 32*1024*1024);
+#endif
+	mi->nr_banks      = 1;
+#if defined(CONFIG_BLK_DEV_INITRD)
+	setup_ramdisk (1, 0, 0, 8192);
+	setup_initrd (__phys_to_virt(0xa1000000), 4*1024*1024);
+	ROOT_DEV = MKDEV(RAMDISK_MAJOR,0);
+#elif defined(CONFIG_MTD)
+	ROOT_DEV = MKDEV(31, 0);	/* /dev/mtdblock0 */
+#endif
+
+#ifdef CONFIG_SHARPSL_BOOTLDR_PARAMS
+	if (params->u1.s.page_size != PAGE_SIZE) {
+	    params->u1.s.page_size = PAGE_SIZE;
+	    params->u1.s.nr_pages = 32 * 1024 * 1024 / PAGE_SIZE;
+	    params->u1.s.ramdisk_size = 0;
+	    params->u1.s.flags = FLAG_READONLY | FLAG_RDLOAD | FLAG_RDPROMPT;
+	    params->u1.s.rootdev = ROOT_DEV;
+	    params->u1.s.initrd_start = 0;
+	    params->u1.s.initrd_size = 0;
+	    params->u1.s.rd_start = 0;
+	    params->u1.s.system_rev = 0;
+	    params->u1.s.system_serial_low = 0;
+	    params->u1.s.system_serial_high = 0;
+	    strcpy(params->commandline, CONFIG_CMDLINE);
+	}
+#endif
+}
+#endif
+
+static struct map_desc corgi_io_desc[] __initdata = {
+ /* virtual     physical    length      */
+  { 0xf1000000, 0x08000000, 0x01000000, MT_DEVICE }, /* LCDC (readable for Qt driver) */
+  { 0xf2000000, 0x10800000, 0x00001000, MT_DEVICE }, /* SCOOP */
+  { 0xf2100000, 0x0C000000, 0x00001000, MT_DEVICE }, /* Nand Flash */
+  { 0xef000000, 0x00000000, 0x00800000, MT_DEVICE }, /* Boot Flash */
+};
+
+static void __init corgi_map_io(void)
+{
+	pxa_map_io();
+	iotable_init(corgi_io_desc,ARRAY_SIZE(corgi_io_desc));
+
+#if 0
+	/* This enables the BTUART */
+	CKEN |= CKEN7_BTUART;
+	set_GPIO_mode(GPIO42_BTRXD_MD);
+	set_GPIO_mode(GPIO43_BTTXD_MD);
+	set_GPIO_mode(GPIO44_BTCTS_MD);
+	set_GPIO_mode(GPIO45_BTRTS_MD);
+#endif
+
+	/* setup sleep mode values */
+	PWER  = 0x00000002;
+	PFER  = 0x00000000;
+	PRER  = 0x00000002;
+	PGSR0 = 0x0158C000;
+	PGSR1 = 0x00FF0080;
+	PGSR2 = 0x0001C004;
+	PCFR |= PCFR_OPDE;
+}
+
+#if defined(CONFIG_MACH_SHEPHERD)
+MACHINE_START(SHEPHERD, "SHARP Shepherd")
+#elseif defined(CONFIG_MACH_HUSKY)
+MACHINE_START(HUSKY, "SHARP Husky")
+#else
+MACHINE_START(CORGI, "SHARP Corgi")
+#endif
+	BOOT_MEM(0xa0000000, 0x40000000, io_p2v(0x40000000))
+#ifdef CONFIG_SHARPSL_BOOTLDR_PARAMS
+	BOOT_PARAMS(0xa0000100)
+#endif
+/*	FIXUP(fixup_corgi)*/
+	MAPIO(corgi_map_io)
+	INITIRQ(corgi_init_irq)
+MACHINE_END
diff -uNr linux-2.6.5-orig/arch/arm/mach-pxa/leds-corgi.c linux-2.6.5/arch/arm/mach-pxa/leds-corgi.c
--- linux-2.6.5-orig/arch/arm/mach-pxa/leds-corgi.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5/arch/arm/mach-pxa/leds-corgi.c	2004-06-14 20:33:19.000000000 +0100
@@ -0,0 +1,135 @@
+/*
+ * linux/arch/arm/mach-pxa/leds-corgi.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Copied from arch/arm/mach-sa1100/leds-collie.c
+ * ChangeLog:
+ * 	- John Lenz <4/27/04> - added support for new locomo device model
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/device.h>
+
+#include <asm/hardware.h>
+#include <asm/hardware/locomo.h>
+#include <asm/leds.h>
+#include <asm/system.h>
+
+#include "leds.h"
+
+#define LED_STATE_ENABLED	1
+#define LED_STATE_CLAIMED	2
+
+static struct locomo_dev *locomo_dev = NULL;
+static unsigned int led_state;
+static unsigned int hw_led0_state = 0;
+static unsigned int hw_led1_state = 0;
+
+#define	LED_ONOFF_MASK (LOCOMO_LPT_TOFL|LOCOMO_LPT_TOFH)
+#define	LED_OFF(REG) ((REG)|=LOCOMO_LPT_TOFL)
+#define	LED_ON(REG) ((REG)=((REG)&~LED_ONOFF_MASK)|LOCOMO_LPT_TOFH)
+#define LED_FLIP(REG)	((REG)^=LED_ONOFF_MASK)
+
+void corgi_leds_event(led_event_t evt)
+{
+        unsigned long flags;
+
+	local_irq_save(flags);
+
+        switch (evt) {
+        case led_start:
+                led_state = LED_STATE_ENABLED;
+		LED_ON(hw_led0_state);
+		LED_ON(hw_led1_state);
+                break;
+
+        case led_stop:
+                led_state &= ~LED_STATE_ENABLED;
+                break;
+
+        case led_claim:
+                led_state |= LED_STATE_CLAIMED;
+		LED_ON(hw_led0_state);
+		LED_ON(hw_led1_state);
+                break;
+
+        case led_release:
+                led_state &= ~LED_STATE_CLAIMED;
+		LED_ON(hw_led0_state);
+		LED_ON(hw_led1_state);
+                break;
+
+#ifdef CONFIG_LEDS_TIMER
+        case led_timer:
+                if (!(led_state & LED_STATE_CLAIMED)) {
+			LED_FLIP(hw_led0_state);
+		}
+                break;
+#endif
+
+#ifdef CONFIG_LEDS_CPU
+        case led_idle_start:
+		/* LED off when system is idle */
+                if (!(led_state & LED_STATE_CLAIMED))
+			LED_OFF(hw_led1_state);
+                break;
+
+        case led_idle_end:
+                if (!(led_state & LED_STATE_CLAIMED))
+			LED_ON(hw_led1_state);
+                break;
+#endif
+
+	default:
+		break;
+        }
+
+	
+        if  (locomo_dev && led_state & LED_STATE_ENABLED) {
+		locomo_writel(hw_led0_state, locomo_dev->mapbase + LOCOMO_LPT0);
+		locomo_writel(hw_led1_state, locomo_dev->mapbase + LOCOMO_LPT1);
+        }
+
+	local_irq_restore(flags);
+}
+
+static int corgiled_probe(struct locomo_dev *dev) {
+	/* set up the initial led states, since due to the init order,
+	 * corgi_leds_event(led_start) might have been called before this */
+        /*if  (led_state & LED_STATE_ENABLED) {
+		//LCM_LPT0 = hw_led0_state;
+		locomo_writel(hw_led0_state, dev->mapbase + LOCOMO_LPT0);
+		//LCM_LPT1 = hw_led1_state;
+		locomo_writel(hw_led1_state, dev->mapbase + LOCOMO_LPT1);
+        }*/
+	locomo_dev = dev;
+	return 0;
+}
+
+static int corgiled_remove(struct locomo_dev *dev) {
+	locomo_dev = NULL;
+	return 0;
+}
+
+static struct locomo_driver corgiled_driver = {
+	.drv = {
+		.name = "locomoled"
+	},
+	.devid	= LOCOMO_DEVID_LED,
+	.probe	= corgiled_probe,
+	.remove	= corgiled_remove,
+};
+
+static int __init corgiled_init(void) {
+	return locomo_driver_register(&corgiled_driver);
+}
+
+device_initcall(corgiled_init);
+
+MODULE_AUTHOR("John Lenz <jelenz@wisc.edu>");
+MODULE_DESCRIPTION("LoCoMo Corgi LED driver");
+MODULE_LICENSE("GPL");
diff -uNr linux-2.6.5-orig/arch/arm/mach-pxa/leds.c linux-2.6.5/arch/arm/mach-pxa/leds.c
--- linux-2.6.5-orig/arch/arm/mach-pxa/leds.c	2004-06-14 20:31:54.000000000 +0100
+++ linux-2.6.5/arch/arm/mach-pxa/leds.c	2004-06-14 20:33:06.000000000 +0100
@@ -24,7 +24,8 @@
 		leds_event = idp_leds_event;
 	if (machine_is_poodle())
 		leds_event = poodle_leds_event;
-
+	if (machine_is_corgi())
+		leds_event = corgi_leds_event;
 	leds_event(led_start);
 	return 0;
 }
diff -uNr linux-2.6.5-orig/arch/arm/mach-pxa/leds.h linux-2.6.5/arch/arm/mach-pxa/leds.h
--- linux-2.6.5-orig/arch/arm/mach-pxa/leds.h	2004-06-14 20:31:54.000000000 +0100
+++ linux-2.6.5/arch/arm/mach-pxa/leds.h	2004-06-14 20:33:06.000000000 +0100
@@ -10,3 +10,4 @@
 extern void lubbock_leds_event(led_event_t evt);
 extern void idp_leds_event(led_event_t evt);
 extern void poodle_leds_event(led_event_t evt);
+extern void corgi_leds_event(led_event_t evt);
diff -uNr linux-2.6.5-orig/arch/arm/tools/mach-types linux-2.6.5/arch/arm/tools/mach-types
--- linux-2.6.5-orig/arch/arm/tools/mach-types	2004-06-14 20:31:55.000000000 +0100
+++ linux-2.6.5/arch/arm/tools/mach-types	2004-06-14 20:33:06.000000000 +0100
@@ -485,3 +485,4 @@
 vr1000			MACH_VR1000		VR1000			475
 deisterpxa		MACH_DEISTERPXA		DEISTERPXA		476
 bcm1160			MACH_BCM1160		BCM1160			477
+husky			MACH_HUSKY		HUSKY			478
\ No newline at end of file
diff -uNr linux-2.6.5-orig/drivers/serial/8250.c linux-2.6.5/drivers/serial/8250.c
--- linux-2.6.5-orig/drivers/serial/8250.c	2004-06-14 20:31:55.000000000 +0100
+++ linux-2.6.5/drivers/serial/8250.c	2004-06-14 20:33:06.000000000 +0100
@@ -169,7 +169,8 @@
 	{ "ST16654",	64,	UART_CLEAR_FIFO | UART_USE_FIFO | UART_STARTECH },
 	{ "XR16850",	128,	UART_CLEAR_FIFO | UART_USE_FIFO | UART_STARTECH },
 	{ "RSA",	2048,	UART_CLEAR_FIFO | UART_USE_FIFO },
-	{ "NS16550A",	16,	UART_CLEAR_FIFO | UART_USE_FIFO | UART_NATSEMI }
+	{ "NS16550A",	16,	UART_CLEAR_FIFO | UART_USE_FIFO | UART_NATSEMI },
+	{ "XScale",	32,	UART_CLEAR_FIFO | UART_USE_FIFO  },
 };
 
 static _INLINE_ unsigned int serial_in(struct uart_8250_port *up, int offset)
@@ -1499,6 +1500,8 @@
 	up->ier &= ~UART_IER_MSI;
 	if (UART_ENABLE_MS(&up->port, termios->c_cflag))
 		up->ier |= UART_IER_MSI;
+	if (up->port.type == PORT_XSCALE)
+		up->ier |= UART_IER_UUE | UART_IER_RTOIE;
 
 	serial_out(up, UART_IER, up->ier);
 
@@ -1930,7 +1933,11 @@
 	 *	First save the UER then disable the interrupts
 	 */
 	ier = serial_in(up, UART_IER);
-	serial_out(up, UART_IER, 0);
+
+	if (up->port.type == PORT_XSCALE)
+		serial_out(up, UART_IER, UART_IER_UUE);
+	else
+		serial_out(up, UART_IER, 0);
 
 	/*
 	 *	Now, do each character
diff -uNr linux-2.6.5-orig/include/asm-arm/arch-pxa/corgi.h linux-2.6.5/include/asm-arm/arch-pxa/corgi.h
--- linux-2.6.5-orig/include/asm-arm/arch-pxa/corgi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.5/include/asm-arm/arch-pxa/corgi.h	2004-06-14 20:33:19.000000000 +0100
@@ -0,0 +1,219 @@
+/*
+ * linux/include/asm-arm/arch-pxa/corgi.h
+ * 
+ * (C) Copyright 2001 Lineo Japan, Inc.
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ *
+ * Based on:
+ *
+ * linux/include/asm-arm/arch-sa1100/collie.h
+ * 
+ * This file contains the hardware specific definitions for Collie
+ *
+ * (C) Copyright 2001 Lineo Japan, Inc.
+ * 
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ * 
+ * ChangeLog:
+ *   04-06-2001 Lineo Japan, Inc.
+ *   04-16-2001 SHARP Corporation
+ *
+ *   Mar 10, 2004: Updates to 2.6 by John Lenz
+ */
+#ifndef __ASM_ARCH_CORGI_H
+#define __ASM_ARCH_CORGI_H  1
+
+/*
+ * LCDC internal I/O mappings
+ *
+ * We have the following mapping:
+ *      phys            virt
+ *      08000000        f1000000
+ */
+
+
+
+/*
+ * SCOOP internal I/O mappings
+ *
+ * We have the following mapping:
+ *      phys            virt
+ *      10800000        f2000000
+ */
+
+
+#define CF_BUF_CTRL_BASE 0xF2000000
+
+#define	CORGI_SCP_REG(adr) (*(volatile unsigned short*)(CF_BUF_CTRL_BASE+(adr)))
+
+#define	CORGI_SCP_MCR  0x00
+#define	CORGI_SCP_CDR  0x04
+#define	CORGI_SCP_CSR  0x08
+#define	CORGI_SCP_CPR  0x0C
+#define	CORGI_SCP_CCR  0x10
+#define	CORGI_SCP_IRR  0x14
+#define	CORGI_SCP_IRM  0x14
+#define	CORGI_SCP_IMR  0x18
+#define	CORGI_SCP_ISR  0x1C
+#define	CORGI_SCP_GPCR 0x20
+#define	CORGI_SCP_GPWR 0x24
+#define	CORGI_SCP_GPRR 0x28
+#define	CORGI_SCP_REG_MCR	CORGI_SCP_REG(CORGI_SCP_MCR)
+#define	CORGI_SCP_REG_CDR	CORGI_SCP_REG(CORGI_SCP_CDR)
+#define	CORGI_SCP_REG_CSR	CORGI_SCP_REG(CORGI_SCP_CSR)
+#define	CORGI_SCP_REG_CPR	CORGI_SCP_REG(CORGI_SCP_CPR)
+#define	CORGI_SCP_REG_CCR	CORGI_SCP_REG(CORGI_SCP_CCR)
+#define	CORGI_SCP_REG_IRR	CORGI_SCP_REG(CORGI_SCP_IRR)
+#define	CORGI_SCP_REG_IRM	CORGI_SCP_REG(CORGI_SCP_IRM)
+#define	CORGI_SCP_REG_IMR	CORGI_SCP_REG(CORGI_SCP_IMR)
+#define	CORGI_SCP_REG_ISR	CORGI_SCP_REG(CORGI_SCP_ISR)
+#define	CORGI_SCP_REG_GPCR	CORGI_SCP_REG(CORGI_SCP_GPCR)
+#define	CORGI_SCP_REG_GPWR	CORGI_SCP_REG(CORGI_SCP_GPWR)
+#define	CORGI_SCP_REG_GPRR	CORGI_SCP_REG(CORGI_SCP_GPRR)
+
+#define CORGI_SCP_GPCR_PA22	( 1 << 12 )
+#define CORGI_SCP_GPCR_PA21	( 1 << 11 )
+#define CORGI_SCP_GPCR_PA20	( 1 << 10 )
+#define CORGI_SCP_GPCR_PA19	( 1 << 9 )
+#define CORGI_SCP_GPCR_PA18	( 1 << 8 )
+#define CORGI_SCP_GPCR_PA17	( 1 << 7 )
+#define CORGI_SCP_GPCR_PA16	( 1 << 6 )
+#define CORGI_SCP_GPCR_PA15	( 1 << 5 )
+#define CORGI_SCP_GPCR_PA14	( 1 << 4 )
+#define CORGI_SCP_GPCR_PA13	( 1 << 3 )
+#define CORGI_SCP_GPCR_PA12	( 1 << 2 )
+#define CORGI_SCP_GPCR_PA11	( 1 << 1 )
+
+
+/*
+ * GPIOs
+ */
+#define CORGI_SCP_LED_GREEN		CORGI_SCP_GPCR_PA11
+#define CORGI_SCP_SWA			CORGI_SCP_GPCR_PA12
+#define CORGI_SCP_SWB			CORGI_SCP_GPCR_PA13
+#define CORGI_SCP_MUTE_L		CORGI_SCP_GPCR_PA14
+#define CORGI_SCP_MUTE_R		CORGI_SCP_GPCR_PA15
+#define CORGI_SCP_AKIN_PULLUP		CORGI_SCP_GPCR_PA16
+#define CORGI_SCP_APM_ON		CORGI_SCP_GPCR_PA17
+#define CORGI_SCP_BACKLIGHT_CONT	CORGI_SCP_GPCR_PA18
+#define CORGI_SCP_MIC_BIAS		CORGI_SCP_GPCR_PA19
+
+
+#define CORGI_SCP_IO_DIR	( CORGI_SCP_LED_GREEN | CORGI_SCP_MUTE_L | CORGI_SCP_MUTE_R | \
+				  CORGI_SCP_AKIN_PULLUP | CORGI_SCP_APM_ON | CORGI_SCP_BACKLIGHT_CONT | \
+				  CORGI_SCP_MIC_BIAS )
+#define CORGI_SCP_IO_OUT	( CORGI_SCP_MUTE_L | CORGI_SCP_MUTE_R )
+#define CORGI_GPIO_CO		16
+
+
+/*
+ * Flash Memory mappings
+ *
+ * We have the following mapping:
+ *                      phys            virt
+ *      boot ROM        00000000        ef000000
+ *      NAND Flash      0C000000	f2100000
+ */
+#define NAND_FLASH_REG_BASE 0xf2100000
+#define CORGI_CPLD_REG(ofst) (*(volatile unsigned char*)(NAND_FLASH_REG_BASE+(ofst)))
+
+/* register offset */
+#define CORGI_ECCLPLB		0x00	/* line parity 7 - 0 bit */
+#define CORGI_ECCLPUB		0x04	/* line parity 15 - 8 bit */
+#define CORGI_ECCCP		0x08	/* column parity 5 - 0 bit */
+#define CORGI_ECCCNTR		0x0C	/* ECC byte counter */
+#define CORGI_ECCCLRR		0x10	/* cleare ECC */
+#define CORGI_FLASHIO		0x14	/* Flash I/O */
+#define CORGI_FLASHCTL		0x18	/* Flash Control */
+
+/* Flash control bit */
+#define CORGI_FLRYBY		(1 << 5)
+#define CORGI_FLCE1		(1 << 4)
+#define CORGI_FLWP		(1 << 3)
+#define CORGI_FLALE		(1 << 2)
+#define CORGI_FLCLE		(1 << 1)
+#define CORGI_FLCE0		(1 << 0)
+
+
+
+
+/*
+CORGI_ * LED
+ */
+#define CORGI_GPIO_LED_ORANGE		(13)
+//#define CORGI_SCP_LED_GREEN		CORGI_SCP_GPCR_PA11
+
+
+/*
+ * GPIOs
+ */
+/* PXA GPIOs */
+#define CORGI_GPIO_KEY_INT		(0)	/* key interrupt */
+#define CORGI_GPIO_AC_IN		(1)
+#define CORGI_GPIO_TP_INT		(5)	/* Touch Panel interrupt */
+#define CORGI_GPIO_WAKEUP		(3)
+#define CORGI_GPIO_IR_ON		(22)
+#define CORGI_GPIO_AK_INT		(4)	// Remote Controller
+#define CORGI_GPIO_HP_IN		GPIO_AK_INT
+#define CORGI_GPIO_CF_IRQ		(17)
+//#define CORGI_GPIO_CF_PRDY		(17)
+#define CORGI_GPIO_LED_ORANGE		(13)
+#define CORGI_GPIO_CF_CD		(14)
+#define CORGI_GPIO_SD_PWR		(33)
+#define CORGI_GPIO_nSD_CLK		(6)
+#define CORGI_GPIO_nSD_WP		(7)
+#define CORGI_GPIO_nSD_INT		(10)
+#define CORGI_GPIO_nSD_DETECT		(9)
+#define CORGI_GPIO_MAIN_BAT_LOW		(11)
+#define CORGI_GPIO_BAT_COVER		(11)
+#define CORGI_GPIO_ADC_TEMP_ON		(21)
+#define CORGI_GPIO_CHRG_ON		(38)
+#define CORGI_GPIO_CHRG_FULL		(16)
+#define CORGI_GPIO_USB_PULLUP		(45)
+#define CORGI_GPIO_HSYNC		(44)
+
+/* KeyBoard */
+#define CORGI_KEY_STROBE_NUM		(12)
+#define CORGI_KEY_SENSE_NUM		(8)
+#define CORGI_GPIO_ALL_STROBE_BIT	(0x00003ffc)
+#define CORGI_GPIO_HIGH_SENSE_BIT	(0xfc000000)
+#define CORGI_GPIO_HIGH_SENSE_RSHIFT	(26)
+#define CORGI_GPIO_LOW_SENSE_BIT	(0x00000003)
+#define CORGI_GPIO_LOW_SENSE_LSHIFT	(6)
+#define CORGI_GPIO_STROBE_BIT(a)	GPIO_bit(66+(a))
+#define CORGI_GPIO_SENSE_BIT(a)		GPIO_bit(58+(a))
+#define CORGI_GAFR_ALL_STROBE_BIT	(0x0ffffff0)
+#define CORGI_GAFR_HIGH_SENSE_BIT	(0xfff00000)
+#define CORGI_GAFR_LOW_SENSE_BIT	(0x0000000f)
+#define CORGI_GPIO_KEY_SENSE(a)		(58+(a))
+
+
+/*
+ * Interrupts
+ */
+/* PXA GPIOs */
+#define CORGI_IRQ_GPIO_KEY_INT		IRQ_GPIO(0)
+#define CORGI_IRQ_GPIO_AC_IN		IRQ_GPIO(1)
+#define CORGI_IRQ_GPIO_AK_INT		IRQ_GPIO(4)
+#define CORGI_IRQ_GPIO_HP_IN		IRQ_GPIO_AK_INT
+#define CORGI_IRQ_GPIO_TP_INT		IRQ_GPIO(5)
+#define CORGI_IRQ_GPIO_WAKEUP		IRQ_GPIO(3)
+#define CORGI_IRQ_GPIO_CO		IRQ_GPIO(16)
+#define CORGI_IRQ_GPIO_CF_IRQ		IRQ_GPIO(17)
+#define CORGI_IRQ_GPIO_CF_CD		IRQ_GPIO(14)
+#define CORGI_IRQ_GPIO_nSD_INT		IRQ_GPIO(10)
+#define CORGI_IRQ_GPIO_nSD_DETECT	IRQ_GPIO(9)
+#define CORGI_IRQ_GPIO_MAIN_BAT_LOW	IRQ_GPIO(11)
+#define CORGI_IRQ_GPIO_KEY_SENSE(a)	IRQ_GPIO(58+(a))
+
+
+// CS
+#define CORGI_CS_MAX1111	1
+#define CORGI_CS_ADS7846	2
+#define CORGI_CS_LZ9JG18	3
+
+#endif /* __ASM_ARCH_CORGI_H  */
+
diff -uNr linux-2.6.5-orig/include/asm-arm/thread_info.h linux-2.6.5/include/asm-arm/thread_info.h
--- linux-2.6.5-orig/include/asm-arm/thread_info.h	2004-06-14 20:31:55.000000000 +0100
+++ linux-2.6.5/include/asm-arm/thread_info.h	2004-06-14 20:33:06.000000000 +0100
@@ -108,8 +108,8 @@
 #define TI_CPU		20
 #define TI_CPU_DOMAIN	24
 #define TI_CPU_SAVE	28
-#define TI_USED_MATH	76
-#define TI_FPSTATE	(TI_USED_MATH+16)
+#define TI_USED_CP	76
+#define TI_FPSTATE	(TI_USED_CP+16)
 
 #endif
 
diff -uNr linux-2.6.5-orig/include/linux/serial_core.h linux-2.6.5/include/linux/serial_core.h
--- linux-2.6.5-orig/include/linux/serial_core.h	2004-06-14 20:31:56.000000000 +0100
+++ linux-2.6.5/include/linux/serial_core.h	2004-06-14 20:33:06.000000000 +0100
@@ -38,7 +38,8 @@
 #define PORT_16850	12
 #define PORT_RSA	13
 #define PORT_NS16550A	14
-#define PORT_MAX_8250	14	/* max port ID */
+#define PORT_XSCALE	15
+#define PORT_MAX_8250	15	/* max port ID */
 
 /*
  * ARM specific type numbers.  These are not currently guaranteed
diff -uNr linux-2.6.5-orig/include/linux/serial_reg.h linux-2.6.5/include/linux/serial_reg.h
--- linux-2.6.5-orig/include/linux/serial_reg.h	2004-06-14 20:31:56.000000000 +0100
+++ linux-2.6.5/include/linux/serial_reg.h	2004-06-14 20:33:06.000000000 +0100
@@ -141,7 +141,7 @@
 #define UART_MSR_ANY_DELTA 0x0F	/* Any of the delta bits! */
 
 /*
- * The Intel PXA2xx chip defines those bits
+ * The Intel XScale on-chip UARTs define these bits
  */
 #define UART_IER_DMAE	0x80	/* DMA Requests Enable */
 #define UART_IER_UUE	0x40	/* UART Unit Enable */
diff -uNr linux-2.6.5-orig/arch/arm/boot/Makefile linux-2.6.5/arch/arm/boot/Makefile
--- linux-2.6.5-orig/arch/arm/boot/Makefile	2004-04-04 04:36:18.000000000 +0100
+++ linux-2.6.5/arch/arm/boot/Makefile	2004-06-14 21:36:21.000000000 +0100
@@ -69,6 +69,8 @@
 ZBSSADDR	:= ALIGN(4)
 endif
 
+OBJCOPYFLAGS_zImage := --pad-to `(arm-linux-readelf -l arch/arm/boot/compressed/vmlinux | grep LOAD | awk '{ print $$6 }')`
+
 export	ZTEXTADDR ZBSSADDR ZRELADDR INITRD_PHYS PARAMS_PHYS
 
 targets := Image zImage bootpImage
