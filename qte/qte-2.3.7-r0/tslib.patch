
#
# Patch managed by http://www.mn-logistik.de/unsupported/pxa250/patcher
#

--- qt-2.3.7/src/kernel/qwsmouse_qws.cpp~tslib
+++ qt-2.3.7/src/kernel/qwsmouse_qws.cpp
@@ -7,6 +7,10 @@
 **
 ** Copyright (C) 1992-2000 Trolltech AS.  All rights reserved.
 **
+** Portions Copyright (C) 2003 Texas Instruments, Inc.
+** 	Rights to said portions for use under the GPL and QPL licenses
+**	are hereby granted to Trolltech AS.
+**
 ** This file is part of the kernel module of the Qt GUI Toolkit.
 **
 ** This file may be distributed and/or modified under the terms of the
@@ -59,6 +63,9 @@
 #ifdef QT_QWS_CASSIOPEIA
 #include <linux/tpanel.h>
 #endif
+#if QWS_TSLIB
+#include <tslib.h>
+#endif
 
 #if defined(QT_QWS_IPAQ)
 #define QT_QWS_IPAQ_RAW
@@ -1093,6 +1100,137 @@
     return sent;
 }
 
+class QTSLibHandler : public QWSMouseHandler
+{
+    Q_OBJECT
+public:
+    QTSLibHandler();
+    ~QTSLibHandler();
+
+    virtual void clearCalibration();
+    virtual void calibrate( QWSPointerCalibrationData * );
+    // Not Used -> virtual void getCalibration( QWSPointerCalibrationData * );
+
+private:
+    void openTs();
+    void closeTs();
+    bool raw;
+#ifdef QWS_TSLIB
+    struct tsdev *ts;
+#endif
+    
+private slots:
+    void readMouseData();
+};
+	
+QTSLibHandler::QTSLibHandler()
+    : raw(false)
+{
+    openTs();
+}
+
+QTSLibHandler::~QTSLibHandler()
+{
+    closeTs();
+}
+
+void QTSLibHandler::openTs()
+{
+#ifdef QWS_TSLIB
+    char *tsdevice;
+
+    if( ( tsdevice = getenv( "TSLIB_TSDEVICE" ) ) != NULL ) {
+	ts = ts_open( tsdevice, 1 );
+    } else {
+	ts = ts_open( "/dev/ts", 1 );
+    }
+
+    if (!ts) {
+	qWarning( "Cannot open touchscreen (%s)", strerror( errno ) );
+	return;
+    }
+
+    if (ts_config( ts )) {
+	qWarning( "Cannot configure touchscreen (%s)", strerror( errno ) );
+	return;
+    }
+
+    QSocketNotifier *mouseNotifier;
+    mouseNotifier = new QSocketNotifier( ts_fd(ts), QSocketNotifier::Read,
+					 this );
+    connect( mouseNotifier, SIGNAL( activated( int ) ), this, SLOT( readMouseData() ) );
+#endif
+}
+
+void QTSLibHandler::closeTs()
+{
+#ifdef QWS_TSLIB
+    if (ts)
+        ts_close(ts);
+#endif
+}
+
+void QTSLibHandler::clearCalibration()
+{
+    raw = true;
+}
+
+void QTSLibHandler::calibrate( QWSPointerCalibrationData *cd )
+{
+    QPoint dev_tl = cd->devPoints[ QWSPointerCalibrationData::TopLeft ];
+    QPoint dev_br = cd->devPoints[ QWSPointerCalibrationData::BottomRight ];
+    QPoint screen_tl = cd->screenPoints[ QWSPointerCalibrationData::TopLeft ];
+    QPoint screen_br = cd->screenPoints[ QWSPointerCalibrationData::BottomRight ];
+    int a, b, c, d, e, f, s;
+
+    s = 1 << 16;
+
+    a = s * (screen_tl.x() - screen_br.x() ) / (dev_tl.x() - dev_br.x());
+    b = 0;
+    c = s * screen_tl.x() - a * dev_tl.x();
+
+    d = 0;
+    e = s * (screen_tl.y() - screen_br.y() ) / (dev_tl.y() - dev_br.y());
+    f = s * screen_tl.y() - e * dev_tl.y();
+
+    QString calFile = "/etc/pointercal";
+#ifndef QT_NO_TEXTSTREAM
+    QFile file( calFile );
+    if ( file.open( IO_WriteOnly ) ) {
+	QTextStream t( &file );
+	t << a << " " << b << " " << c << " ";
+	t << d << " " << e << " " << f << " " << s;
+       file.flush(); closeTs();
+       openTs();
+    } else
+#endif
+    {
+	qDebug( "Could not save calibration: %s", calFile.latin1() );
+    }
+    raw = false;
+}
+
+void QTSLibHandler::readMouseData()
+{
+#ifdef QWS_TSLIB
+    if(!qt_screen)
+	return;
+
+    struct ts_sample sample;
+    int ret;
+    if (raw) {
+	if ((ret = ts_read_raw(ts, &sample, 1)) < 0)
+	    return;
+    } else {
+	if ((ret = ts_read(ts, &sample, 1)) < 0)
+	    return;
+    }
+
+    QPoint pos( sample.x, sample.y );
+    emit mouseChanged( pos, sample.pressure != 0 ? 1 : 0 );
+#endif
+}
+
 /*
  * Handler for /dev/tpanel Linux kernel driver
  */
@@ -1689,12 +1827,14 @@
 	    break;
 
 	case TPanel:
-#if defined(QWS_CUSTOMTOUCHPANEL)
-	    handler = new QCustomTPanelHandlerPrivate(mouseProtocol,mouseDev);
+#if defined(QWS_TSLIB)
+	    handler = new QTSLibHandler( );
+#elif defined(QWS_CUSTOMTOUCHPANEL)
+	    handler = new QCustomTPanelHandlerPrivate( mouseProtocol, mouseDev );
 #elif defined(QT_QWS_YOPY)
-	    handler = new QYopyTPanelHandlerPrivate(mouseProtocol,mouseDev);
+	    handler = new QYopyTPanelHandlerPrivate( mouseProtocol, mouseDev );
 #elif defined(QT_QWS_IPAQ) || defined(QT_QWS_SL5XXX)
-	    handler = new QTPanelHandlerPrivate(mouseProtocol,mouseDev);
+	    handler = new QTPanelHandlerPrivate( mouseProtocol, mouseDev );
 #elif defined(QT_QWS_CASSIOPEIA)
 	    handler = new QVrTPanelHandlerPrivate( mouseProtocol, mouseDev );
 #endif
--- qt-2.3.7/configure~tslib
+++ qt-2.3.7/configure
@@ -399,6 +399,9 @@
    -kde)
        KDE=yes
 	;;
+   -tslib)
+       TSLIB=yes
+	;;
    -no-g++-exceptions)
 	GPLUSPLUS_EXCEPTIONS=no
 	;;
@@ -1255,6 +1258,9 @@
 			 set to point to a KDE 2 installation.
                          See http://www.kde.org
 
+    -tslib ............. Use the TSLib (touchscreen access library) mouse handler
+                         by default, instead of the normal device default.
+
     -no-g++-exceptions . Disable exceptions on platforms using the GNU C++
 			 compiler by using the -fno-exceptions flag.
 
@@ -1314,6 +1320,13 @@
 [ "x$SM" = "xno" ] && QT_CXX="${QT_CXX} -DQT_NO_SM_SUPPORT"
 [ "x$XFT" = "xyes" ] && QT_CXX="${QT_CXX} -DQT_XFT"
 [ "x$XFT" = "xno" ] && QT_CXX="${QT_CXX} -DQT_NO_XKB"
+
+if [ "x$TSLIB" = "xyes" ]
+then
+   QT_CXX="${QT_CXX} -DQWS_TSLIB"
+   QT_LIBS="${QT_LIBS} -lts"
+fi
+
 if [ "x$THREAD" = "xyes" ]
 then
    cat >src-mt.mk <<EOF
