Index: linux-2.6.20.7/arch/arm/mach-pxa/ezx-mci.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.20.7/arch/arm/mach-pxa/ezx-mci.c	2007-04-20 01:10:13.000000000 -0300
@@ -0,0 +1,159 @@
+/*
+ *  linux/arch/arm/mach-ezx/a780.c
+ *
+ *  Support for the Motorola Ezx A780 Development Platform.
+ *
+ *  Author:	Zhuang Xiaofan
+ *  Created:	Nov 25, 2003
+ *  Copyright:	Motorola Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/mmc/host.h>
+#include <linux/irq.h>
+#include <asm/irq.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/ezx-pcap.h>
+#include <asm/arch/mmc.h>
+#include <asm/arch/hardware.h>
+
+extern int ezx_pcap_mmcsd_power(int);
+extern void ezx_pcap_mmcsd_voltage(u_int32_t);
+
+static struct pxamci_platform_data ezx_mci_platform_data;
+
+static int ezx_mci_init(struct device *dev,
+                        irqreturn_t (*ezx_detect_int)(int, void *),
+                        void *data)
+{
+        int err;
+        printk("%s entered\n", __FUNCTION__);
+
+        /* Setup GPIO for PXA27x MMC/SD controller */
+        pxa_gpio_mode(GPIO32_MMCCLK_MD);
+        pxa_gpio_mode(GPIO112_MMCCMD_MD);
+        pxa_gpio_mode(GPIO92_MMCDAT0_MD);
+        pxa_gpio_mode(GPIO109_MMCDAT1_MD);
+        pxa_gpio_mode(GPIO110_MMCDAT2_MD);
+        pxa_gpio_mode(GPIO111_MMCDAT3_MD);
+
+        ezx_pcap_mmcsd_power(1);
+
+        ezx_mci_platform_data.detect_delay = msecs_to_jiffies(250);
+
+        err = request_irq(0x49, ezx_detect_int, SA_INTERRUPT,
+                          "MMC card detect", data);
+        if (err) {
+                printk(KERN_ERR "ezx_mci_detect: MMC/SD: can't request "
+                      "MMC card detect IRQ\n");
+                return -1;
+        }
+
+        set_irq_type(0x0b, IRQT_BOTHEDGE);
+
+        return 0;
+}
+
+static int ezx_mci_get_ro(struct device *dev)
+{
+        printk("%s entered\n", __FUNCTION__);
+#if defined(CONFIG_PXA_EZX_E680)
+        /* this is only e680, i guess */
+        // return GPIO_is_high(96+4);
+        return (GPLR3 & 0x800);
+#else
+        return 0;
+#endif
+}
+
+#if defined(CONFIG_PXA_EZX_A780)
+static u_int8_t mmc_voltage[] = {
+	[MMC_VDD_160] = 5,
+	[MMC_VDD_170] = 5,
+	[MMC_VDD_180] = 6,
+	[MMC_VDD_190] = 6,
+	[MMC_VDD_200] = 7,
+	[MMC_VDD_210] = 7,
+	[MMC_VDD_220] = 8,
+	[MMC_VDD_230] = 8,
+	[MMC_VDD_240] = 9,
+	[MMC_VDD_250] = 9,
+	[MMC_VDD_260] = 10,
+	[MMC_VDD_270] = 10,
+	[MMC_VDD_280] = 11,
+	[MMC_VDD_290] = 11,
+	[MMC_VDD_300] = 12,
+	[MMC_VDD_310] = 12,
+	[MMC_VDD_320] = 13,
+	[MMC_VDD_330] = 13,
+	[MMC_VDD_340] = 14,
+	[MMC_VDD_350] = 14,
+	[MMC_VDD_360] = 15,
+};
+#elif defined(CONFIG_PXA_EZX_E680)
+static u_int8_t mmc_voltage[] = {
+	[MMC_VDD_160] = 3,
+	[MMC_VDD_170] = 3,
+	[MMC_VDD_180] = 3,
+	[MMC_VDD_190] = 3,
+	[MMC_VDD_200] = 3,
+	[MMC_VDD_210] = 3,
+	[MMC_VDD_220] = 3,
+	[MMC_VDD_230] = 3,
+	[MMC_VDD_240] = 3,
+	[MMC_VDD_250] = 3,
+	[MMC_VDD_260] = 3,
+	[MMC_VDD_270] = 3,
+	[MMC_VDD_280] = 3,
+	[MMC_VDD_290] = 3,
+	[MMC_VDD_300] = 3,
+	[MMC_VDD_310] = 3,
+	[MMC_VDD_320] = 3,
+	[MMC_VDD_330] = 3,
+	[MMC_VDD_340] = 3,
+	[MMC_VDD_350] = 3,
+	[MMC_VDD_360] = 3,
+};
+#endif
+
+static void ezx_mci_setpower(struct device *dev, unsigned int vdd)
+{
+        printk("%s(vdd=%u) entered\n", __FUNCTION__, vdd);
+        if (vdd <= MMC_VDD_360)
+                ezx_pcap_mmcsd_voltage(mmc_voltage[vdd]);
+
+        ezx_pcap_mmcsd_power(1);
+}
+
+static void ezx_mci_exit(struct device *dev, void *data)
+{
+        printk("%s entered\n", __FUNCTION__);
+        ezx_pcap_mmcsd_power(0);
+        free_irq(0x49, data);
+}
+
+static struct pxamci_platform_data ezx_mci_platform_data = {
+#if defined(CONFIG_PXA_EZX_E680)
+        .ocr_mask       = MMC_VDD_27_28,
+#elif defined(CONFIG_PXA_EZX_A780)
+        .ocr_mask       = MMC_VDD_160_165|MMC_VDD_18_19|MMC_VDD_20_21
+                          |MMC_VDD_22_23|MMC_VDD_24_25|MMC_VDD_26_27
+                          |MMC_VDD_28_29|MMC_VDD_30_31|MMC_VDD_32_33
+                          |MMC_VDD_34_35|MMC_VDD_35_36,
+#endif
+        .init           = ezx_mci_init,
+        .get_ro         = ezx_mci_get_ro,
+        .setpower       = ezx_mci_setpower,
+        .exit           = ezx_mci_exit,
+};
+
+int __init __ezx_mci_init (void)
+{
+	pxa_set_mci_info(&ezx_mci_platform_data);
+	return 0;
+}
+
+arch_initcall(__ezx_mci_init);
Index: linux-2.6.20.7/arch/arm/mach-pxa/Makefile
===================================================================
--- linux-2.6.20.7.orig/arch/arm/mach-pxa/Makefile	2007-04-21 02:56:16.000000000 -0300
+++ linux-2.6.20.7/arch/arm/mach-pxa/Makefile	2007-04-21 03:00:03.000000000 -0300
@@ -18,7 +18,7 @@
 obj-$(CONFIG_MACH_AKITA)	+= akita-ioexp.o
 obj-$(CONFIG_MACH_POODLE)	+= poodle.o corgi_ssp.o
 obj-$(CONFIG_MACH_TOSA)         += tosa.o
-obj-$(CONFIG_PXA_EZX)		+= ezx.o ezx_lcd.o ezx_ssp.o ezx-pcap.o
+obj-$(CONFIG_PXA_EZX)		+= ezx.o ezx_lcd.o ezx_ssp.o ezx-pcap.o ezx-mci.o
 
 # Support for blinky lights
 led-y := leds.o
