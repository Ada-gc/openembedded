 drivers/ide/pci/aec62xx.c |   51 +++++++++++++++++++++++++++++++++++++++++++---
 drivers/ide/setup-pci.c   |   12 +++++++++-
 2 files changed, 59 insertions(+), 4 deletions(-)

--- linux-nas100d.orig/drivers/ide/pci/aec62xx.c	2005-11-12 15:38:03.000000000 +0100
+++ linux-nas100d/drivers/ide/pci/aec62xx.c	2005-11-13 01:45:26.000000000 +0100
@@ -145,6 +145,15 @@ static int aec6210_tune_chipset (ide_dri
 	unsigned long flags;
 
 	local_irq_save(flags);
+
+#ifdef CONFIG_MACH_NAS100D
+	printk(KERN_INFO "aec62xx: nas100d tuning\n");
+	pci_write_config_byte(hwif->pci_dev, PCI_LATENCY_TIMER, 0x90);
+	/* Enable burst mode & force 2 ports enable  */
+	pci_read_config_byte(hwif->pci_dev, 0x4a, &tmp0);
+	pci_write_config_byte(hwif->pci_dev, 0x4a, tmp0 | 0x80);
+#endif
+
 	/* 0x40|(2*drive->dn): Active, 0x41|(2*drive->dn): Recovery */
 	pci_read_config_word(dev, 0x40|(2*drive->dn), &d_conf);
 	tmp0 = pci_bus_clock_list(speed, BUSCLOCK(dev));
@@ -263,7 +272,7 @@ static int aec62xx_irq_timeout (ide_driv
 		case PCI_DEVICE_ID_ARTOP_ATP865:
 		case PCI_DEVICE_ID_ARTOP_ATP865R:
 			printk(" AEC62XX time out ");
-#if 0
+#ifdef CONFIG_MACH_NAS100D
 			{
 				int i = 0;
 				u8 reg49h = 0;
@@ -277,7 +286,7 @@ static int aec62xx_irq_timeout (ide_driv
 		default:
 			break;
 	}
-#if 0
+#ifdef CONFIG_MACH_NAS100D
 	{
 		ide_hwif_t *hwif	= HWIF(drive);
 		struct pci_dev *dev	= hwif->pci_dev;
@@ -299,6 +308,14 @@ static unsigned int __devinit init_chips
 {
 	int bus_speed = system_bus_clock();
 
+#ifdef CONFIG_MACH_NAS100D
+	/* enable both ports */
+	byte tmp;
+	printk(KERN_INFO "%s: nas100d ports enable\n", name);
+	pci_read_config_byte(dev, 0x4a, &tmp);
+	pci_write_config_byte(dev, 0x4a, tmp | 0x06);
+#endif
+
 	if (dev->resource[PCI_ROM_RESOURCE].start) {
 		pci_write_config_dword(dev, PCI_ROM_ADDRESS, dev->resource[PCI_ROM_RESOURCE].start | PCI_ROM_ADDRESS_ENABLE);
 		printk(KERN_INFO "%s: ROM enabled at 0x%08lx\n", name, dev->resource[PCI_ROM_RESOURCE].start);
@@ -312,12 +329,35 @@ static unsigned int __devinit init_chips
 	return dev->irq;
 }
 
+#ifdef CONFIG_MACH_NAS100D
+static void nas100d_insw (unsigned long port, u16 *addr, u32 count)
+{
+	while (count--)
+		*addr++ = __cpu_to_le16(inw(port));
+}
+
+static void nas100d_outw (u16 val, unsigned long port)
+{
+	u32 n, byte_enables, data;
+	n = port % 4;
+	byte_enables = (0xf & ~(BIT(n) | BIT(n+1))) << IXP4XX_PCI_NP_CBE_BESL;
+	data = val << (8*n);
+	ixp4xx_pci_write(port, byte_enables | NP_CMD_IOWRITE, __le16_to_cpu(data));
+}
+#endif
+
 static void __devinit init_hwif_aec62xx(ide_hwif_t *hwif)
 {
 	hwif->autodma = 0;
 	hwif->tuneproc = &aec62xx_tune_drive;
 	hwif->speedproc = &aec62xx_tune_chipset;
 
+#ifdef CONFIG_MACH_NAS100D
+	printk(KERN_INFO "aec62xx: enabling nas100d iops\n");
+	hwif->OUTW = nas100d_outw;
+	hwif->INSW = nas100d_insw;
+#endif
+
 	if (hwif->pci_dev->device == PCI_DEVICE_ID_ARTOP_ATP850UF) {
 		hwif->serialized = hwif->channel;
 		hwif->no_dsc = 1;
@@ -360,7 +400,7 @@ static void __devinit init_dma_aec62xx(i
 	} else {
 		u8 ata66	= 0;
 		pci_read_config_byte(hwif->pci_dev, 0x49, &ata66);
-	        if (!(hwif->udma_four))
+		if (!(hwif->udma_four))
 			hwif->udma_four = (ata66&(hwif->channel?0x02:0x01))?0:1;
 	}
 
@@ -427,6 +467,9 @@ static ide_pci_device_t aec62xx_chipsets
 		.init_dma	= init_dma_aec62xx,
 		.channels	= 2,
 		.autodma	= AUTODMA,
+#ifdef CONFIG_MACH_NAS100D
+		.enablebits	= {{0x4a,0x02,0x02}, {0x4a,0x04,0x04}},
+#endif
 		.bootable	= OFF_BOARD,
 	},{	/* 4 */
 		.name		= "AEC6X80R",
@@ -454,6 +497,8 @@ static int __devinit aec62xx_init_one(st
 {
 	ide_pci_device_t *d = &aec62xx_chipsets[id->driver_data];
 
+	printk(KERN_INFO "aec62xx: using config %lx\n", id->driver_data);
+
 	return d->init_setup(dev, d);
 }
 
--- linux-nas100d.orig/drivers/ide/setup-pci.c	2005-11-12 15:38:03.000000000 +0100
+++ linux-nas100d/drivers/ide/setup-pci.c	2005-11-13 01:36:30.000000000 +0100
@@ -602,10 +602,20 @@ void ide_pci_setup_ports(struct pci_dev 
 		if ((d->flags & IDEPCI_FLAG_FORCE_PDC) &&
 		    (secondpdc++==1) && (port==1))
 			goto controller_ok;
-			
+
 		if (e->reg && (pci_read_config_byte(dev, e->reg, &tmp) ||
 		    (tmp & e->mask) != e->val))
+#ifdef CONFIG_MACH_NAS100D
+		{
+			pci_write_config_byte(dev, e->reg, tmp & ~0x01);
+#endif
 			continue;	/* port not enabled */
+#ifdef CONFIG_MACH_NAS100D
+		}
+		else
+			pci_write_config_byte(dev, e->reg, tmp & ~0x01);
+#endif
+
 controller_ok:
 
 		if (d->channels	<= port)
