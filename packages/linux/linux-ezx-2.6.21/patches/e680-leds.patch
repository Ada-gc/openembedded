
#
# Patch managed by http://www.mn-logistik.de/unsupported/pxa250/patcher
#

Index: linux-2.6.21/drivers/leds/Kconfig
===================================================================
--- linux-2.6.21.orig/drivers/leds/Kconfig	2007-06-08 18:39:04.000000000 +0200
+++ linux-2.6.21/drivers/leds/Kconfig	2007-06-08 18:39:12.000000000 +0200
@@ -111,6 +111,13 @@
 	  This option enables support for the LEDs on the
 	  Motorola A780 GSM Phone.
 
+config LEDS_E680
+	tristate "LED Support for the Motorola E680(i) GSM Phone"
+	depends LEDS_CLASS && PXA_EZX_E680
+	help
+	  This options enables support for the LEDs on the
+	  Motorola E680(i) GSM Phone.
+
 config LEDS_TRIGGER_TIMER
 	tristate "LED Timer Trigger"
 	depends on LEDS_TRIGGERS
Index: linux-2.6.21/drivers/leds/Makefile
===================================================================
--- linux-2.6.21.orig/drivers/leds/Makefile	2007-06-08 18:39:04.000000000 +0200
+++ linux-2.6.21/drivers/leds/Makefile	2007-06-08 18:39:12.000000000 +0200
@@ -17,6 +17,7 @@
 obj-$(CONFIG_LEDS_H1940)		+= leds-h1940.o
 obj-$(CONFIG_LEDS_COBALT)		+= leds-cobalt.o
 obj-$(CONFIG_LEDS_A780)		+= leds-a780.o
+obj-$(CONFIG_LEDS_E680)		+= leds-e680.o
 
 # LED Triggers
 obj-$(CONFIG_LEDS_TRIGGER_TIMER)	+= ledtrig-timer.o
Index: linux-2.6.21/drivers/leds/leds-e680.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/drivers/leds/leds-e680.c	2007-06-08 18:39:12.000000000 +0200
@@ -0,0 +1,309 @@
+/*
+ * EZX Platform LED Driver for the Motorola E680(i) GSM Phone
+ *
+ * Copyright 2006 Vanille-Media
+ *
+ * Author: Michael Lauer <mickey@Vanille.de>
+ *
+ * Based on the Motorola 2.4 leds-e680.c and leds-corgi.c by Richard Purdie
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <asm/mach-types.h>
+#include <asm/arch/hardware.h>
+#include <asm/arch/pxa-regs.h>
+#include <asm/arch/ezx-pcap.h>
+
+//FIXME move defines to a common header file
+#define IND_CNTL_R_BUL     46
+#define IND_CNTL_G_BUL     47
+#define SSP_PCAP_LED_MASK  0x000fffe0
+#define SSP_PCAP_LED_SHIFT 5
+#define GPIO_TC_MM_EN      99
+
+extern int ezx_pcap_read(u_int8_t, u_int32_t *);
+extern int ezx_pcap_write(u_int8_t, u_int32_t);
+
+static enum led_brightness old_red;
+static enum led_brightness old_green;
+static enum led_brightness old_blue;
+
+typedef struct {
+	unsigned char ind_GPIO_red;    /*Indicator Red control GPIO 46: 0 active, 1 disactive*/
+	unsigned char ind_GPIO_green;  /*Indicator Green control GPIO 47: 0 active, 1 disactive*/
+	unsigned char pcap_LEDR_en;    /*pcap LEDR_EN bit value: 1 =Red LED(&Green) sink circuit enabled*/
+	unsigned char pcap_LEDG_en;    /*pcap LEDG_EN bit value:1 =Green(->Blue)LED sink circuit enabled*/
+	unsigned char pcap_LEDR_CTRL; /* 4bits Sets the timing for the red(&Green) LED sink circuit*/
+	unsigned char pcap_LEDG_CTRL; /* 4bits Sets the timing for the GREEN (->Blue) LED sink circuit*/
+	unsigned char pcap_LEDR_I;   /* 2 bits 00 3mA,01 4mA, 10 5mA, 11 9mA, sets the pulsed current level for LEDR*/
+	unsigned char pcap_LEDG_I;   /* 2 bits 00 3mA,01 4mA, 10 5mA, 11 9mA, sets the pulsed current level for LEDG*/
+	unsigned char pcap_SKIP_on;  /*1=The ON timing sequence defined by LEDx_CTRL is executed on every other cycle*/
+} PCAP2_LED_REGISTER_VALUE;
+
+const PCAP2_LED_REGISTER_VALUE led_register_value[]=
+{
+  /*  on/off pulsepower  timing  intensity */
+	{0x1,0x1, 0x0,0x0, 0x0,0x0, 0x0,0x0,0x0}, /* OFF */
+	{0x0,0x1, 0x1,0x0, 0xc,0x0, 0x1,0x0,0x0}, /* RED */
+	{0x1,0x0, 0x1,0x0, 0xc,0x0, 0x1,0x0,0x0}, /* GREEN */
+	{0x0,0x0, 0x1,0x0, 0xc,0x0, 0x1,0x0,0x0}, /* ORANGE = RED + GREEN */
+	{0x1,0x1, 0x0,0x1, 0x0,0xc, 0x0,0x0,0x0}, /* BLUE */
+	{0x0,0x1, 0x1,0x1, 0xc,0xc, 0x1,0x0,0x0}, /* LIGHT_RED = RED + BLUE */
+	{0x1,0x0, 0x1,0x1, 0xc,0xc, 0x1,0x0,0x0}, /* LIGHT_GREEN = GREEN + BLUE */
+	{0x0,0x0, 0x1,0x1, 0xc,0xc, 0x1,0x0,0x0}, /* WHITE = RED + GREEN + BLUE */
+};
+
+static void e680led_led_set( enum led_brightness red, enum led_brightness green, enum led_brightness blue )
+{
+	unsigned int tempValue = 0;
+	unsigned int value = 0;
+	unsigned int stateIndex = 0;
+	unsigned char gpio_red, gpio_green, ledr_en, ledg_en, ledr_ctrl, ledg_ctrl, ledr_i, ledg_i,skip;
+
+	printk( KERN_DEBUG "e680led_led_set: red=%d, green=%d, blue=%d", red, green, blue );
+	stateIndex = ( ( blue << 2 ) | ( green << 1 ) | ( red ) )   & 0x7;
+	printk( KERN_DEBUG "LED stateIndex is %d", stateIndex );
+	gpio_red   = led_register_value[stateIndex].ind_GPIO_red    & 0x1;
+	gpio_green = led_register_value[stateIndex].ind_GPIO_green  & 0x1;
+	ledr_en    = led_register_value[stateIndex].pcap_LEDR_en    & 0x1;
+	ledg_en    = led_register_value[stateIndex].pcap_LEDG_en    & 0x1;
+	ledr_ctrl  = led_register_value[stateIndex].pcap_LEDR_CTRL  & 0xf;
+	ledg_ctrl  = led_register_value[stateIndex].pcap_LEDG_CTRL  & 0xf;
+	ledr_i     = led_register_value[stateIndex].pcap_LEDR_I     & 0x3;
+	ledg_i     = led_register_value[stateIndex].pcap_LEDG_I     & 0x3;
+	skip       = led_register_value[stateIndex].pcap_SKIP_on    & 0x1;
+
+	/* disable LEDs */
+	if( ezx_pcap_read(SSP_PCAP_ADJ_PERIPH_REGISTER,&tempValue) != SSP_PCAP_SUCCESS )
+	{
+		printk( KERN_WARNING "LED PCAP Read Failed\n" );
+		return;
+	}
+	tempValue &= (~SSP_PCAP_LED_MASK);
+	if( ezx_pcap_write(SSP_PCAP_ADJ_PERIPH_REGISTER,tempValue) != SSP_PCAP_SUCCESS )
+	{
+		printk( KERN_WARNING "LED PCAP Write Failed (Clear Data)\n" );
+		return;
+	}
+
+	/* configure GPIOs as output */
+	pxa_gpio_mode(IND_CNTL_R_BUL | GPIO_OUT);
+	pxa_gpio_mode(IND_CNTL_G_BUL | GPIO_OUT);
+
+	//FIXME: Simplify this logic
+	if ( (gpio_green && gpio_red) )
+	{
+		/*Disable Red & Green signal*/
+		pxa_gpio_set_value(IND_CNTL_R_BUL, 1); /*IND_CNTL_R_BUL Low active*/
+		PGSR(IND_CNTL_R_BUL) = PGSR(IND_CNTL_R_BUL) | GPIO_bit(IND_CNTL_R_BUL);
+
+		pxa_gpio_set_value(IND_CNTL_G_BUL, 0); /*IND_CNTL_G_BUL High active*/
+		PGSR(IND_CNTL_G_BUL) = PGSR(IND_CNTL_G_BUL) & (~GPIO_bit(IND_CNTL_G_BUL));
+
+		printk( KERN_DEBUG "LED GPIO Green & Red Disable\n");
+	} else if ( gpio_green && !gpio_red )
+	{
+		/*Green Disable, Red Enable*/
+		pxa_gpio_set_value(IND_CNTL_R_BUL, 0);
+		PGSR(IND_CNTL_R_BUL) = PGSR(IND_CNTL_R_BUL) & (~GPIO_bit(IND_CNTL_R_BUL));
+
+		pxa_gpio_set_value(IND_CNTL_G_BUL, 0);
+		PGSR(IND_CNTL_G_BUL) = PGSR(IND_CNTL_G_BUL) & (~GPIO_bit(IND_CNTL_G_BUL));
+
+		printk( KERN_DEBUG "LED GPIO Green Disable, Red Enable\n");
+	} else if (gpio_red && !gpio_green )
+	{
+		/*Red Disable, Green Enable*/
+		pxa_gpio_set_value(IND_CNTL_R_BUL, 1);
+		PGSR(IND_CNTL_R_BUL) = PGSR(IND_CNTL_R_BUL) | GPIO_bit(IND_CNTL_R_BUL);
+
+		pxa_gpio_set_value(IND_CNTL_G_BUL, 1);
+		PGSR(IND_CNTL_G_BUL) = PGSR(IND_CNTL_G_BUL) | GPIO_bit(IND_CNTL_G_BUL);
+		printk( KERN_DEBUG "LED GPIO Red Disable, Green Enable");
+	}else
+	{
+		/*Red & Green enable*/
+		pxa_gpio_set_value(IND_CNTL_R_BUL, 0);
+		PGSR(IND_CNTL_R_BUL) = PGSR(IND_CNTL_R_BUL) & (~GPIO_bit(IND_CNTL_R_BUL));
+
+		pxa_gpio_set_value(IND_CNTL_G_BUL, 1);
+		PGSR(IND_CNTL_G_BUL) = PGSR(IND_CNTL_G_BUL) | GPIO_bit(IND_CNTL_G_BUL);
+		printk( KERN_DEBUG "LED GPIO Red & Green Enable\n");
+	}
+
+	/* Write PCAP LED Peripheral Control Register*/
+	value = ( ledr_en | (ledg_en <<1) | (ledr_ctrl <<2) | (ledg_ctrl <<6) |
+		(ledr_i << 10) | (ledg_i <<12) | (skip <<14) ) & 0x7fff;
+	tempValue |= (value <<SSP_PCAP_LED_SHIFT);
+
+	if ( ezx_pcap_write(SSP_PCAP_ADJ_PERIPH_REGISTER,tempValue) == SSP_PCAP_SUCCESS )
+	{
+		printk( KERN_DEBUG "LED PCAP Write Success (0x%x :0x%x)\n",tempValue,value);
+		old_red = red;
+		old_green = green;
+		old_blue = blue;
+		return;
+	} else {
+		printk( KERN_DEBUG "LED PCAP Write Failed (State Change)\n");
+		return;
+	}
+}
+
+static void e680led_red_set(struct led_classdev *led_cdev, enum led_brightness value)
+{
+	printk( KERN_DEBUG "e680led_red_set: %d\n", value );
+	e680led_led_set( 1 && value, old_green, old_blue );
+}
+
+static void e680led_green_set(struct led_classdev *led_cdev, enum led_brightness value)
+{
+	printk( KERN_DEBUG "e680led_green_set: %d\n", value );
+	e680led_led_set( old_red, 1 && value, old_blue );
+}
+
+static void e680led_blue_set(struct led_classdev *led_cdev, enum led_brightness value)
+{
+	printk( KERN_DEBUG "e680led_blue_set: %d\n", value );
+	e680led_led_set( old_red, old_green, 1 && value );
+}
+
+static void e680led_keypad_set(struct led_classdev *led_cdev, enum led_brightness value)
+{
+	/* this is not working yet, as there is something else missing */
+#if 0
+	printk( KERN_DEBUG "e680led_keypad_set: %d\n", value );
+
+	pxa_gpio_mode(GPIO_TC_MM_EN);
+	GPDR(GPIO_TC_MM_EN)   |= GPIO_bit(GPIO_TC_MM_EN);
+	GPSR(GPIO_TC_MM_EN)   = GPIO_bit(GPIO_TC_MM_EN);
+
+	udelay( 100 );
+
+    if ( value ) {
+		GPCR(GPIO_TC_MM_EN)   = GPIO_bit(GPIO_TC_MM_EN);
+		PGSR3 &= ~GPIO_bit(GPIO_TC_MM_EN);
+    } else {
+		GPSR(GPIO_TC_MM_EN)   = GPIO_bit(GPIO_TC_MM_EN);
+		PGSR3 |= GPIO_bit(GPIO_TC_MM_EN);
+    }
+#endif
+}
+
+static struct led_classdev e680_red_led = {
+	.name			= "e680:red",
+	.default_trigger	= "none",
+	.brightness_set		= e680led_red_set,
+};
+
+static struct led_classdev e680_green_led = {
+	.name			= "e680:green",
+	.default_trigger	= "none",
+	.brightness_set		= e680led_green_set,
+};
+
+static struct led_classdev e680_blue_led = {
+	.name			= "e680:blue",
+	.default_trigger	= "none",
+	.brightness_set		= e680led_blue_set,
+};
+
+static struct led_classdev e680_keypad_led = {
+	.name			= "e680:keypad",
+	.default_trigger	= "none",
+	.brightness_set		= e680led_keypad_set,
+};
+
+#ifdef CONFIG_PM
+static int e680led_suspend(struct platform_device *dev, pm_message_t state)
+{
+	led_classdev_suspend(&e680_red_led);
+	led_classdev_suspend(&e680_green_led);
+	led_classdev_suspend(&e680_blue_led);
+	led_classdev_suspend(&e680_keypad_led);
+	return 0;
+}
+
+static int e680led_resume(struct platform_device *dev)
+{
+	led_classdev_resume(&e680_red_led);
+	led_classdev_resume(&e680_green_led);
+	led_classdev_resume(&e680_blue_led);
+	led_classdev_resume(&e680_keypad_led);
+	return 0;
+}
+#endif
+
+static int e680led_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	ret = led_classdev_register(&pdev->dev, &e680_red_led);
+	if (ret < 0)
+		return ret;
+
+	ret = led_classdev_register(&pdev->dev, &e680_green_led);
+	if (ret < 0)
+		led_classdev_unregister(&e680_red_led);
+
+	ret = led_classdev_register(&pdev->dev, &e680_blue_led);
+	if (ret < 0) {
+		led_classdev_unregister(&e680_red_led);
+		led_classdev_unregister(&e680_green_led);
+	}
+
+	ret = led_classdev_register(&pdev->dev, &e680_keypad_led);
+	if (ret < 0) {
+		led_classdev_unregister(&e680_red_led);
+		led_classdev_unregister(&e680_green_led);
+		led_classdev_unregister(&e680_blue_led);
+	}
+	return ret;
+}
+
+static int e680led_remove(struct platform_device *pdev)
+{
+	led_classdev_unregister(&e680_red_led);
+	led_classdev_unregister(&e680_green_led);
+	led_classdev_unregister(&e680_blue_led);
+	led_classdev_unregister(&e680_keypad_led);
+	return 0;
+}
+
+static struct platform_driver e680led_driver = {
+	.probe		= e680led_probe,
+	.remove		= e680led_remove,
+#ifdef CONFIG_PM
+	.suspend	= e680led_suspend,
+	.resume		= e680led_resume,
+#endif
+	.driver		= {
+		.name		= "e680-led",
+	},
+};
+
+static int __init e680led_init(void)
+{
+	return platform_driver_register(&e680led_driver);
+}
+
+static void __exit e680led_exit(void)
+{
+	e680led_led_set( 0, 0, 0 );
+	platform_driver_unregister(&e680led_driver);
+}
+
+module_init(e680led_init);
+module_exit(e680led_exit);
+
+MODULE_AUTHOR("Michael Lauer <mickey@Vanille.de>");
+MODULE_DESCRIPTION("Motorola E680 LED driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.21/arch/arm/mach-pxa/ezx-e680.c
===================================================================
--- linux-2.6.21.orig/arch/arm/mach-pxa/ezx-e680.c	2007-06-08 18:38:59.000000000 +0200
+++ linux-2.6.21/arch/arm/mach-pxa/ezx-e680.c	2007-06-08 18:39:12.000000000 +0200
@@ -242,9 +242,15 @@
        },
 };
 
+static struct platform_device e680led_device = {
+	.name		= "e680-led",
+	.id		= -1,
+};
+
 static struct platform_device *devices[] __initdata = {
 	&pcap_ts_device,
 	&e680locksw_device,
+	&e680led_device,
 };
 
 static void __init e680_init(void)
