Ignores read interrupts after penUP events until a penDOWN interrupt arrives.
Some other changes i dont remember exactly. :)
Signed-off-by: Daniel Ribeiro <drwyrm@gmail.com>
Index: linux-2.6.16/drivers/input/touchscreen/pcap_ts.c
===================================================================
--- linux-2.6.16.orig/drivers/input/touchscreen/pcap_ts.c	2007-03-09 21:26:25.000000000 -0300
+++ linux-2.6.16/drivers/input/touchscreen/pcap_ts.c	2007-03-09 21:26:42.000000000 -0300
@@ -31,7 +31,7 @@
 
 #include "../../misc/ezx/ssp_pcap.h"
 
-#if 1
+#if 0
 #define DEBUGP(x, args ...) printk(KERN_DEBUG "%s: " x, __FUNCTION__, ## args)
 #else
 #define DEBUGP(x, args ...)
@@ -39,6 +39,7 @@
 
 #define PRESSURE 1
 #define COORDINATE 2
+#define STANDBY 3
 
 struct pcap_ts {
 	int irq_xy;
@@ -97,7 +98,7 @@
 	int ret;
 	u_int32_t tmp;
 	DEBUGP("start xy read in mode %s\n", 
-		pcap_ts->read_state == COORDINATE ? "COORD" : "PRESS");
+		pcap_ts->read_state == COORDINATE ? "COORD" : (pcap_ts->read_state == PRESSURE ? "PRESS" : "STANDBY"));
 
 	ret = ezx_pcap_read(SSP_PCAP_ADJ_ADC1_REGISTER, &tmp);
 	if (ret < 0)
@@ -122,7 +123,7 @@
 	u_int32_t tmp;
 
 	DEBUGP("get xy value in mode %s\n", 
-		pcap_ts->read_state == COORDINATE ? "COORD" : "PRESS");
+		pcap_ts->read_state == COORDINATE ? "COORD" : (pcap_ts->read_state == PRESSURE ? "PRESS" : "STANDBY"));
 
 	ret = ezx_pcap_read(SSP_PCAP_ADJ_ADC2_REGISTER, &tmp);
 	if (ret < 0)
@@ -145,7 +146,16 @@
 static irqreturn_t pcap_ts_irq_xy(int irq, void *dev_id, struct pt_regs *regs)
 {
 	struct pcap_ts *pcap_ts = dev_id;
+//	DEBUGP("read_state: %d\n", pcap_ts->read_state);
 
+	/*
+	 * Ignore further read interrupts after we set STANDBY - WM
+	 */
+	if (pcap_ts->read_state == STANDBY)
+	{
+		DEBUGP("ignored\n");
+		return IRQ_HANDLED;
+	}
 	if (pcap_ts_get_xy_value(pcap_ts) < 0) {
 		printk("pcap_ts: error reading XY value\n");
 		return IRQ_HANDLED;
@@ -160,33 +170,32 @@
 		     pcap_ts->pressure <= PRESSURE_MIN ) &&
 		    pcap_ts->pressure == pcap_ts->pressure_last) {
 			/* pen has been released */
+			DEBUGP("UP\n");
 			input_report_key(pcap_ts->input, BTN_TOUCH, 0);
-			input_sync(pcap_ts->input);
-
 			input_report_abs(pcap_ts->input, ABS_PRESSURE, 0);
+			input_sync(pcap_ts->input);
 
 			pcap_ts->x = pcap_ts->y = 0;
 
+			/* no need for timer, we'll get interrupted with
+			 * next touch down event */
+			del_timer(&pcap_ts->timer);
+
 			/* ask PCAP2 to interrupt us if touch event happens
 			 * again */
-			pcap_ts->read_state = PRESSURE;
+			pcap_ts->read_state = STANDBY;
 			pcap_ts_mode(PCAP_TS_STANDBY_MODE);
 			ezx_pcap_bit_set(SSP_PCAP_ADJ_BIT_MSR_TSM, 0);
-
-			/* no need for timer, we'll get interrupted with
-			 * next touch down event */
-			del_timer(&pcap_ts->timer);
 		} else {
 			/* pen has been touched down */
+			DEBUGP("DOWN\n");
+
 			input_report_key(pcap_ts->input, BTN_TOUCH, 1);
 			/* don't input_sync(), we don't know position yet */
 
 			if (pcap_ts->pressure == 0) 
 				pcap_ts->pressure = pcap_ts->pressure_last;
 
-			input_report_abs(pcap_ts->input, ABS_PRESSURE,
-				pcap_ts->pressure);
-
 			/* switch state machine into coordinate read mode */
 			pcap_ts->read_state = COORDINATE;
 			pcap_ts_mode(PCAP_TS_POSITION_XY_MEASUREMENT);
@@ -196,18 +205,14 @@
 		/* we are in coordinate mode */
 		if (pcap_ts->x <= X_AXIS_MIN || pcap_ts->x >= X_AXIS_MAX ||
 		    pcap_ts->y <= Y_AXIS_MIN || pcap_ts->y >= Y_AXIS_MAX) {
-			DEBUGP("invalid x/y coordinate position: PEN_UP?\n");
-
+			DEBUGP("PEN_UP?\n");
 			pcap_ts->pressure = 0;
-#if 0
-			input_report_key(pcap_ts->input, BTN_TOUCH, 0);
-			pcap_ts->x = pcap_ts->y = 0;
-#endif
 		} else {
+			input_report_abs(pcap_ts->input, ABS_PRESSURE, pcap_ts->pressure);
 			input_report_abs(pcap_ts->input, ABS_X, pcap_ts->x);
 			input_report_abs(pcap_ts->input, ABS_Y, pcap_ts->y);
+			input_sync(pcap_ts->input);
 		}
-		input_sync(pcap_ts->input);
 
 		/* switch back to pressure read mode */
 		pcap_ts->read_state = PRESSURE;
