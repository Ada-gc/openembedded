Index: linux-2.6.21/drivers/input/touchscreen/pcap_ts.c
===================================================================
--- linux-2.6.21.orig/drivers/input/touchscreen/pcap_ts.c	2007-05-01 16:28:00.000000000 +0200
+++ linux-2.6.21/drivers/input/touchscreen/pcap_ts.c	2007-05-01 16:28:03.000000000 +0200
@@ -21,15 +21,14 @@
 #include <linux/string.h>
 #include <linux/pm.h>
 #include <linux/timer.h>
-#include <linux/config.h>
+//#include <linux/config.h>
 #include <linux/interrupt.h>
 #include <linux/platform_device.h>
 #include <linux/input.h>
 
 #include <asm/arch/hardware.h>
 #include <asm/arch/pxa-regs.h>
-
-#include "../../misc/ezx/ssp_pcap.h"
+#include <asm/arch/ezx-pcap.h>
 
 #if 1
 #define DEBUGP(x, args ...) printk(KERN_DEBUG "%s: " x, __FUNCTION__, ## args)
@@ -61,6 +60,9 @@
 #define PRESSURE_MAX	X_AXIS_MAX
 #define PRESSURE_MIN	X_AXIS_MIN
 
+#define SAMPLE_INTERVAL		(HZ/100)
+
+
 static int pcap_ts_mode(u_int32_t mode)
 {
 	int ret;
@@ -157,8 +159,6 @@
 		pcap_ts->x, pcap_ts->y, pcap_ts->pressure);
 
 	if (pcap_ts->read_state == PRESSURE) {
-		input_report_abs(pcap_ts->input, ABS_PRESSURE,
-				 pcap_ts->pressure);
 		if ((pcap_ts->pressure >= PRESSURE_MAX ||
 		     pcap_ts->pressure <= PRESSURE_MIN ) &&
 		    pcap_ts->pressure == pcap_ts->pressure_last) {
@@ -166,6 +166,8 @@
 			input_report_key(pcap_ts->input, BTN_TOUCH, 0);
 			input_sync(pcap_ts->input);
 
+			input_report_abs(pcap_ts->input, ABS_PRESSURE, 0);
+
 			pcap_ts->x = pcap_ts->y = 0;
 
 			/* ask PCAP2 to interrupt us if touch event happens
@@ -182,18 +184,24 @@
 			input_report_key(pcap_ts->input, BTN_TOUCH, 1);
 			/* don't input_sync(), we don't know position yet */
 
+			if (pcap_ts->pressure == 0) 
+				pcap_ts->pressure = pcap_ts->pressure_last;
+
+			input_report_abs(pcap_ts->input, ABS_PRESSURE,
+				pcap_ts->pressure);
+
 			/* switch state machine into coordinate read mode */
 			pcap_ts->read_state = COORDINATE;
 			pcap_ts_mode(PCAP_TS_POSITION_XY_MEASUREMENT);
 			pcap_ts_start_xy_read(pcap_ts);
-
-			mod_timer(&pcap_ts->timer, jiffies + HZ/20);
 		}
 	} else {
 		/* we are in coordinate mode */
 		if (pcap_ts->x <= X_AXIS_MIN || pcap_ts->x >= X_AXIS_MAX ||
 		    pcap_ts->y <= Y_AXIS_MIN || pcap_ts->y >= Y_AXIS_MAX) {
 			DEBUGP("invalid x/y coordinate position: PEN_UP?\n");
+
+			pcap_ts->pressure = 0;
 #if 0
 			input_report_key(pcap_ts->input, BTN_TOUCH, 0);
 			pcap_ts->x = pcap_ts->y = 0;
@@ -206,8 +214,8 @@
 
 		/* switch back to pressure read mode */
 		pcap_ts->read_state = PRESSURE;
-		pcap_ts_mode(PCAP_TS_STANDBY_MODE);
-		ezx_pcap_bit_set(SSP_PCAP_ADJ_BIT_MSR_TSM, 0);
+		pcap_ts_mode(PCAP_TS_PRESSURE_MEASUREMENT);
+		mod_timer(&pcap_ts->timer, jiffies + SAMPLE_INTERVAL);
 	}
 
 	return IRQ_HANDLED;
@@ -234,18 +242,19 @@
 {
 	struct pcap_ts *pcap_ts = (struct pcap_ts *) data;
 
-	ezx_pcap_bit_set(SSP_PCAP_ADJ_BIT_MSR_TSM, 1);
-	pcap_ts_mode(PCAP_TS_PRESSURE_MEASUREMENT);
-	pcap_ts->read_state = PRESSURE;
 	pcap_ts_start_xy_read(pcap_ts);
 }
 
 static int __init ezxts_probe(struct platform_device *pdev)
 {
+	int ret;
+	u_int32_t tmp;
 	struct pcap_ts *pcap_ts;
 	struct input_dev *input_dev;
 	int err = -ENOMEM;
 
+	printk(KERN_DEBUG "Start probing TS!\n");
+
 	pcap_ts = kzalloc(sizeof(*pcap_ts), GFP_KERNEL);
 	input_dev = input_allocate_device();
 	if (!pcap_ts || !input_dev)
@@ -263,7 +272,46 @@
 		goto fail;
 	}
 
-	ssp_pcap_open(SSP_PCAP_TS_OPEN);
+	// Some initialization before done in ssp_pcap_open()
+	//ssp_pcap_open(SSP_PCAP_TS_OPEN);
+	ezx_pcap_bit_set( SSP_PCAP_ADJ_BIT_ADC1_TS_REFENB, 0);
+	ezx_pcap_bit_set( SSP_PCAP_ADJ_BIT_ISR_ADCDONE2I, 1);
+	ezx_pcap_bit_set( SSP_PCAP_ADJ_BIT_ISR_TSI, 1);
+	ezx_pcap_bit_set( SSP_PCAP_ADJ_BIT_MSR_TSM, 0);
+	ezx_pcap_bit_set( SSP_PCAP_ADJ_BIT_MSR_ADCDONE2M, 0);
+	ezx_pcap_bit_set( SSP_PCAP_ADJ_BIT_ADC2_ADINC1, 0);
+	ezx_pcap_bit_set( SSP_PCAP_ADJ_BIT_ADC2_ADINC2, 0);
+	ezx_pcap_bit_set( SSP_PCAP_ADJ_BIT_ADC1_ATO0, 0);
+	ezx_pcap_bit_set( SSP_PCAP_ADJ_BIT_ADC1_ATO1, 0);
+	ezx_pcap_bit_set( SSP_PCAP_ADJ_BIT_ADC1_ATO2, 0);
+	ezx_pcap_bit_set( SSP_PCAP_ADJ_BIT_ADC1_ATO3, 0);
+	ezx_pcap_bit_set( SSP_PCAP_ADJ_BIT_ADC1_ATOX, 0);
+	ezx_pcap_bit_set( SSP_PCAP_ADJ_BIT_ADC1_MTR1, 0);
+	ezx_pcap_bit_set( SSP_PCAP_ADJ_BIT_ADC1_MTR2, 0);
+
+	//SSP_PCAP_TSI_mode_set(PCAP_TS_STANDBY_MODE);
+	ret = ezx_pcap_read(SSP_PCAP_ADJ_ADC1_REGISTER, &tmp);
+	if (ret < 0)
+		return ret;
+
+	tmp &= (~SSP_PCAP_TOUCH_PANEL_POSITION_DETECT_MODE_MASK);
+	tmp |= PCAP_TS_STANDBY_MODE;
+
+	ret = ezx_pcap_write(SSP_PCAP_ADJ_ADC1_REGISTER, tmp);
+	if (ret < 0)
+		return ret;
+
+	/* send the usb accessory infomation to PM */
+	/*
+	if((ACCESSORY_TYPE) sspUsbAccessoryInfo.type == ACCESSORY_DEVICE_USB_PORT)
+	{
+    		if( (ACCESSORY_DEVICE_STATUS )sspUsbAccessoryInfo.status == ACCESSORY_DEVICE_STATUS_ATTACHED )
+      			apm_queue_event(KRNL_ACCS_ATTACH);
+    		else
+        		apm_queue_event(KRNL_ACCS_DETACH);
+	}
+	*/
+
 
 	err = request_irq(pcap_ts->irq_xy, pcap_ts_irq_xy, SA_INTERRUPT,
 			  "PCAP Touchscreen XY", pcap_ts);
@@ -343,10 +391,11 @@
 	//.resume		= ezxts_resume,
 	.driver		= {
 		.name	= "pcap-ts",
+		.owner	= THIS_MODULE,
 	},
 };
 
-static int __devinit ezxts_init(void)
+static int __init ezxts_init(void)
 {
 	return platform_driver_register(&ezxts_driver);
 }
Index: linux-2.6.21/drivers/input/touchscreen/Kconfig
===================================================================
--- linux-2.6.21.orig/drivers/input/touchscreen/Kconfig	2007-05-01 16:28:00.000000000 +0200
+++ linux-2.6.21/drivers/input/touchscreen/Kconfig	2007-05-01 16:28:03.000000000 +0200
@@ -166,7 +166,7 @@
 
 config TOUCHSCREEN_PCAP
 	tristate "Motorola PCAP touchscreen"
-	depends on PXA_EZX_PCAP
+	depends on PXA_EZX
 	help
 	  Say Y here if you have a Motorola EZX (E680, A780) telephone
 	  and want to support the built-in touchscreen.
@@ -174,6 +174,6 @@
 	  If unsure, say N.
 
 	  To compile this driver as a module, choose M here: the
-	  module will be called hp680_ts_input.
+	  module will be called pcap_ts.
 
 endif
Index: linux-2.6.21/arch/arm/mach-pxa/ezx.c
===================================================================
--- linux-2.6.21.orig/arch/arm/mach-pxa/ezx.c	2007-05-01 16:28:00.000000000 +0200
+++ linux-2.6.21/arch/arm/mach-pxa/ezx.c	2007-05-01 16:28:03.000000000 +0200
@@ -116,6 +116,31 @@
 	.resource	= ezxemu_resources,
 };
 
+/* PCAP_TS */
+struct resource pcap_ts_resources[] = {
+	[0] = {
+		.start		= EZX_IRQ_ADCDONE2,
+		.end		= EZX_IRQ_ADCDONE2,
+		.flags		= IORESOURCE_IRQ,
+	},
+	[1] = {
+		.start		= EZX_IRQ_TS,
+		.end		= EZX_IRQ_TS,
+		.flags		= IORESOURCE_IRQ,
+	}
+};
+
+struct platform_device pcap_ts_device = {
+	.name		= "pcap-ts",
+	.id		= -1,
+	.dev		= {
+		.parent		= &ezxpcap_device.dev,
+	},
+	.num_resources	= ARRAY_SIZE(pcap_ts_resources),
+	.resource	= pcap_ts_resources,
+};
+
+
 /* OHCI Controller */
 
 static int ezx_ohci_init(struct device *dev)
@@ -342,6 +367,7 @@
 	&ezxpcap_device,
 	&ezxbp_device,
 	&ezxemu_device,
+	&pcap_ts_device,
 };
 
 static void __init a780_init(void)
