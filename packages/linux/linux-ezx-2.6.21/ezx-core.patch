Index: linux-2.6.21/arch/arm/boot/compressed/head-xscale.S
===================================================================
--- linux-2.6.21.orig/arch/arm/boot/compressed/head-xscale.S	2007-05-01 14:00:25.000000000 -0300
+++ linux-2.6.21/arch/arm/boot/compressed/head-xscale.S	2007-05-01 14:00:48.000000000 -0300
@@ -53,3 +53,6 @@
 		str	r1, [r0, #0x18]
 #endif
 
+#ifdef CONFIG_ARCH_EZX
+		mov	r7, #MACH_TYPE_EZX
+#endif
Index: linux-2.6.21/arch/arm/mach-pxa/Kconfig
===================================================================
--- linux-2.6.21.orig/arch/arm/mach-pxa/Kconfig	2007-05-01 14:00:25.000000000 -0300
+++ linux-2.6.21/arch/arm/mach-pxa/Kconfig	2007-05-01 23:02:56.000000000 -0300
@@ -37,6 +37,10 @@
 	bool "Keith und Koep Trizeps4 DIMM-Module"
 	select PXA27x
 
+config PXA_EZX
+	bool "Motorola EZX Platform"
+	select PXA_SSP
+
 endchoice
 
 if PXA_SHARPSL
@@ -71,6 +75,27 @@
 
 endif
 
+if PXA_EZX
+
+choice
+	prompt "Select target EZX device"
+
+config PXA_EZX_E680
+	bool "Motorola E680 GSM Phone"
+	select PXA27x
+
+config PXA_EZX_A780
+	bool "Motorola A780 GSM Phone"
+	select PXA27x
+
+config PXA_EZX_E2
+	bool "Motorola E2 GSM Phone"
+	select PXA27x
+
+endchoice
+
+endif
+
 endmenu
 
 config MACH_POODLE
@@ -144,4 +169,5 @@
 	tristate
 	help
 	  Enable support for PXA2xx SSP ports
+
 endif
Index: linux-2.6.21/arch/arm/mach-pxa/Makefile
===================================================================
--- linux-2.6.21.orig/arch/arm/mach-pxa/Makefile	2007-05-01 14:00:25.000000000 -0300
+++ linux-2.6.21/arch/arm/mach-pxa/Makefile	2007-05-01 23:03:58.000000000 -0300
@@ -18,6 +18,7 @@
 obj-$(CONFIG_MACH_AKITA)	+= akita-ioexp.o
 obj-$(CONFIG_MACH_POODLE)	+= poodle.o corgi_ssp.o
 obj-$(CONFIG_MACH_TOSA)         += tosa.o
+obj-$(CONFIG_PXA_EZX)		+= ezx.o ezx_lcd.o ezx_ssp.o
 
 # Support for blinky lights
 led-y := leds.o
Index: linux-2.6.21/arch/arm/mach-pxa/ezx.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/arm/mach-pxa/ezx.c	2007-05-01 23:03:58.000000000 -0300
@@ -0,0 +1,378 @@
+/*
+ *  linux/arch/arm/mach-ezx/a780.c
+ *
+ *  Support for the Motorola Ezx A780 Development Platform.
+ *
+ *  Author:	Zhuang Xiaofan
+ *  Created:	Nov 25, 2003
+ *  Copyright:	Motorola Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/major.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/bitops.h>
+#include <linux/apm_bios.h>
+#include <linux/platform_device.h>
+
+#include <asm/types.h>
+#include <asm/setup.h>
+#include <asm/memory.h>
+#include <asm/mach-types.h>
+#include <asm/hardware.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <asm/arch/ohci.h>
+#include <asm/arch/pxa-regs.h>
+
+#include "ezx.h"
+#include "generic.h"
+#include <linux/tty.h>
+#include <linux/apm_bios.h>
+
+
+extern void usb_send_readurb(void);
+extern int ezx_ssp_set_machinfo(struct ezxssp_machinfo *);
+//FIXME extern void pm_do_poweroff(void);
+
+/* BP Handshake */
+#define FIRST_STEP              2
+#define LAST_STEP               3
+#define BP_RDY_TIMEOUT          0x000c0000
+
+/* check power down condition */
+inline void check_power_off(void)
+{
+        if (!(GPIO_is_high(GPIO_BB_WDI2))) {
+#ifdef CONFIG_PM
+//FIXME                  pm_do_poweroff();
+#endif
+        }
+}
+
+/* SSP */
+struct platform_device ezxssp_device = {
+	.name		= "ezx-ssp",
+	.id		= -1,
+};
+
+struct ezxssp_machinfo ezx_ssp_machinfo = {
+	.port 		= 1,
+	.cs_pcap	= GPIO_SPI_CE,
+	.clk_pcap	= 1,
+};
+
+
+/* OHCI Controller */
+
+static int ezx_ohci_init(struct device *dev)
+{
+	/* for A780 support (connected with Neptune) */
+	pxa_gpio_mode(GPIO30_USB_P3_2);	/* GPIO30 - USB_P3_2/ICL_TXENB */
+	pxa_gpio_mode(GPIO31_USB_P3_6);	/* GPIO31 - USB_P3_6/ICL_VPOUT */
+	pxa_gpio_mode(GPIO90_USB_P3_5);	/* GPIO90 - USB_P3_5/ICL_VPIN */
+	pxa_gpio_mode(GPIO91_USB_P3_1);	/* GPIO91 - USB_P3_1/ICL_XRXD */
+	pxa_gpio_mode(GPIO56_USB_P3_4);	/* GPIO56 - USB_P3_4/ICL_VMOUT */
+	pxa_gpio_mode(GPIO113_USB_P3_3);/* GPIO113 - USB_P3_3/ICL_VMIN */
+	UP3OCR = 0x00000002;
+
+	UHCHR = UHCHR & ~(UHCHR_SSEP2 | UHCHR_SSEP3 | UHCHR_SSE);
+
+	return 0;
+}
+
+static struct pxaohci_platform_data ezx_ohci_platform_data = {
+	.port_mode	= PMM_NPS_MODE,
+	.init		= ezx_ohci_init,
+};
+
+static int step = FIRST_STEP;
+void handshake(void)
+{
+        /* step 1: check MCU_INT_SW or BP_RDY is low (now it is checked in apboot) */
+        if (step == 1) {
+                int timeout = BP_RDY_TIMEOUT;
+
+                /* config MCU_INT_SW, BP_RDY as input */
+                GPDR(GPIO_MCU_INT_SW) &= ~GPIO_bit(GPIO_MCU_INT_SW);
+                GPDR(GPIO_BP_RDY) &= ~GPIO_bit(GPIO_BP_RDY);
+
+                while ( timeout -- ) {
+                        if ( (!(GPIO_is_high(GPIO_MCU_INT_SW)))
+                                || (!(GPIO_is_high(GPIO_BP_RDY))) ) {
+                                step ++;
+                                break;
+                        }
+
+                        check_power_off();
+                }
+        }
+
+        /* step 2: wait BP_RDY is low */
+        if (step == 2) {
+                if (!(GPIO_is_high(GPIO_BP_RDY))) {
+
+                        /* config MCU_INT_SW as output */
+                        pxa_gpio_mode(GPIO_MCU_INT_SW | GPIO_OUT);
+                        clr_GPIO(GPIO_MCU_INT_SW);
+
+                        step ++;
+                }
+        }
+
+        /* step 3: wait BP_RDY is high */
+        if (step == 3) {
+                if (GPIO_is_high(GPIO_BP_RDY)) {
+                        step ++;
+                        //FIXME delay_bklight();
+                        set_GPIO(GPIO_MCU_INT_SW);
+                }
+        }
+}
+
+#ifdef CONFIG_APM
+static unsigned long idle_limit = 0;
+int pm_handle_irq(int irq)
+{
+
+        //FIXME: extern unsigned long idle_limit;
+        //FIXME: extern int can_idle, can_sleep;
+        static unsigned long tmp_jiffy;         /* for temporary store of jiffies */
+
+        /*
+         * if idle_limit is zero, never enter idle.
+         * if not OS timer, reset idle timer count
+         */
+        if (idle_limit == 0) {
+                tmp_jiffy = jiffies;
+                return irq;
+        }
+#if 0
+        if (irq != IRQ_OST0) {
+                tmp_jiffy = jiffies;
+                can_idle = 0;
+                can_sleep = 0;
+        } else if (jiffies > tmp_jiffy + idle_limit) {
+
+                /*
+                 * I think this is enough to prevent from reentering here
+                 * due to jiffies will be stoped
+                 */
+                tmp_jiffy = jiffies;
+
+                /* if pm idle timer expired, queue event  */
+                apm_queue_event(KRNL_PROC_INACT);
+                can_idle = 1;
+        }
+#endif
+
+        return irq;
+}
+
+irqreturn_t bp_wdi_intr(int irq, void *dev_id)
+{
+//FIXME        apm_queue_event(KRNL_BP_WDI);
+	return IRQ_HANDLED;
+}
+
+static struct irqaction bp_wdi_irq = {
+	.name		= "BP wdi",
+        .handler	= &bp_wdi_intr,
+};
+#endif
+
+int handshake_pass(void)
+{
+        return (step > LAST_STEP);
+}
+
+static irqreturn_t bp_rdy_intr(int irq, void *dev_id)
+{
+	static int usbipc_ready = 0;
+
+	if (!usbipc_ready) {
+		handshake();
+	        if (handshake_pass()) {
+	                disable_irq(IRQ_GPIO(GPIO_BB_WDI2));
+
+			/* set bp_rdy handle for usb ipc */
+			set_irq_type(GPIO_BP_RDY, IRQT_FALLING);
+			usbipc_ready = 1;
+       		}
+	} else
+		// FIXME usb_send_readurb();
+		{}
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction bp_rdy_irq = {
+	.name		= "BP rdy",
+	.handler	= bp_rdy_intr,
+};
+
+static irqreturn_t bp_wdi2_intr(int irq, void *dev_id)
+{
+#ifdef CONFIG_PM
+//FIXME        pm_do_poweroff();
+#endif
+	return IRQ_HANDLED;
+}
+
+static struct irqaction bp_wdi2_irq = {
+	.name		= "BP wdi2",
+	.handler	= bp_wdi2_intr,
+};
+
+
+static struct resource ezx_bp_resources[] = {
+	[0] = {
+		.start		= GPIO_BP_RDY,
+		.end		= GPIO_BP_RDY,
+		.flags		= IORESOURCE_IRQ,
+	},
+	[1] = {
+		.start		= GPIO_BB_WDI2,
+		.end		= GPIO_BB_WDI2,
+		.flags		= IORESOURCE_IRQ,
+	},
+#ifdef CONFIG_APM
+	[2] = {
+		.start		= GPIO_BB_WDI,
+		.end		= GPIO_BB_WDI,
+		.flags		= IORESOURCE_IRQ,
+	},
+#endif
+};
+
+static struct platform_device ezx_bp_device = {
+	.name		= "ezx-bp",
+	.dev		= {
+		//.parent		=
+		//.platform_data	=
+	},
+	.id		= -1,
+	.num_resources	= ARRAY_SIZE(ezx_bp_resources),
+	.resource	= ezx_bp_resources,
+};
+
+static void __init ezx_init_gpio_irq(void)
+{
+#ifdef CONFIG_APM
+        set_irq_type(GPIO_BB_WDI, IRQT_FALLING);
+        setup_irq(IRQ_GPIO(GPIO_BB_WDI), &bp_wdi_irq);
+#endif
+        set_irq_type(GPIO_BP_RDY, IRQT_BOTHEDGE);
+        setup_irq(IRQ_GPIO(GPIO_BP_RDY), &bp_rdy_irq);
+
+        set_irq_type(GPIO_BB_WDI2, IRQT_FALLING);
+        setup_irq(IRQ_GPIO(GPIO_BB_WDI2), &bp_wdi2_irq);
+}
+
+static void __init a780_init_irq(void)
+{
+	pxa_init_irq();
+
+        /* init ezx specfic gpio irq */
+        ezx_init_gpio_irq();
+
+        check_power_off();
+        handshake();
+        if (handshake_pass()) {
+                disable_irq(IRQ_GPIO(GPIO_BP_RDY));
+                disable_irq(IRQ_GPIO(GPIO_BB_WDI2));
+        }
+}
+
+static struct platform_device *devices[] __initdata = {
+	&ezxssp_device,
+	&ezx_bp_device,
+};
+
+static void __init a780_init(void)
+{
+	CKEN = CKEN9_OSTIMER | CKEN22_MEMC;
+
+	ezx_ssp_set_machinfo(&ezx_ssp_machinfo);
+
+        /* set BB_RESET PIN out put high */
+        pxa_gpio_mode(GPIO_BB_RESET|GPIO_OUT);
+        set_GPIO(GPIO_BB_RESET);
+
+	pxa_gpio_mode(GPIO_ICL_FFRXD_MD);
+	pxa_gpio_mode(GPIO_ICL_FFTXD_MD);
+	pxa_gpio_mode(GPIO_ICL_FFCTS_MD);
+	pxa_gpio_mode(GPIO_ICL_FFRTS_MD);
+
+	pxa_gpio_mode(GPIO42_BTRXD_MD);
+	pxa_gpio_mode(GPIO43_BTTXD_MD);
+	pxa_gpio_mode(GPIO44_BTCTS_MD);
+	pxa_gpio_mode(GPIO45_BTRTS_MD);
+
+        /* clear EMU MUX1/MUX2 (low) to close the audio path to EMU */
+	pxa_gpio_mode(GPIO_EMU_MUX1|GPIO_OUT);
+        clr_GPIO(GPIO_EMU_MUX1);
+	pxa_gpio_mode(GPIO_EMU_MUX2|GPIO_OUT);
+        clr_GPIO(GPIO_EMU_MUX2);
+
+#if defined(CONFIG_PXA_EZX_E680)
+	pxa_gpio_mode(GPIO46_STRXD_MD);
+	pxa_gpio_mode(GPIO47_STTXD_MD);
+
+	/* setup sleep mode values */
+	PWER  = 0xc000f803;		// disable usb 0xdc00f803;
+	PFER  = 0x0000f803;
+	PRER  = 0x00001802;
+	// keypad wakeup (PKWR,PGSR3) should be in keypad.c
+	PGSR0 = 0x00000010;
+	PGSR1 = 0x02800000;
+	PGSR2 = 0x00040000;
+	PGSR3 = 0x00000000;
+	PCFR  = PCFR_DC_EN | PCFR_FS | PCFR_FP | PCFR_OPDE;
+	PSLR  = 0x05800f00;
+
+#elif defined(CONFIG_PXA_EZX_A780)
+
+	/* Standard UART */
+	pxa_gpio_mode(GPIO46_STRXD_MD);
+	pxa_gpio_mode(GPIO47_STTXD_MD);
+
+	/* setup sleep mode values */
+	PWER  = 0xc0007803;		// disable usb, GPIO15 NC
+	PFER  = 0x00007803;
+	PRER  = 0x00001802;
+	// keypad wakeup (PKWR,PGSR3) should be in keypad.c
+	PGSR0 = 0x00000010;
+	PGSR1 = 0x02800000;
+	PGSR2 = 0x00040000;
+	PGSR3 = 0x00000008;
+	PCFR  = PCFR_DC_EN | PCFR_FS | PCFR_FP | PCFR_OPDE;
+	PSLR  = 0x05800f00;
+
+#endif
+	pxa_set_ohci_info(&ezx_ohci_platform_data);
+
+	platform_add_devices(devices, ARRAY_SIZE(devices));
+
+}
+
+MACHINE_START(EZX, "Motorola Ezx Platform")
+	/* Maintainer: Harald Welte <laforge@gnumonks.org> */
+	.phys_io 	= 0x40000000,
+	.io_pg_offst	= (io_p2v(0x40000000) >> 18) & 0xfffc,
+	.boot_params	= 0xa0000100,
+	.map_io		= pxa_map_io,
+	.init_irq	= a780_init_irq,
+	.timer		= &pxa_timer,
+	.init_machine	= a780_init,
+MACHINE_END
Index: linux-2.6.21/include/asm-arm/arch-pxa/ezx.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/include/asm-arm/arch-pxa/ezx.h	2007-05-01 14:00:48.000000000 -0300
@@ -0,0 +1,225 @@
+/*
+ *  linux/include/asm-arm/arch-pxa/ezx.h
+ *
+ *  Specific macro defines for Motorola Ezx Development Platform
+ *
+ *  Author:     Zhuang Xiaofan
+ *  Created:    Nov 25, 2003
+ *  Copyright:  Motorola Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+/* support E680 p3 and ealier PCB */
+//#define   E680_P3_AND_EARLY
+
+#define GPIO_is_high(x) (GPLR(x) & GPIO_bit(x))
+#define set_GPIO(x) (GPSR(x) = GPIO_bit(x))
+#define clr_GPIO(x) (GPCR(x) = GPIO_bit(x))
+
+/*
+ * Flags in memory for sleep use
+ */
+#define FLAG_ADDR       PHYS_OFFSET
+#define RESUME_ADDR     (PHYS_OFFSET + 4)
+#define BPSIG_ADDR      (PHYS_OFFSET + 8)
+
+#define USER_OFF_FLAG   0x5a5a5a5a
+#define SLEEP_FLAG      0x6b6b6b6b
+#define OFF_FLAG        0x7c7c7c7c
+#define REFLASH_FLAG    0x0C1D2E3F
+#define PASS_THRU_FLAG	0x12345678
+
+#define WDI_FLAG        0xbb00dead
+#define NO_FLAG         0xaa00dead
+
+/*
+ * GPIO control pin, have to change when hardware lock down
+ */
+
+#ifdef E680_P3_AND_EARLY
+
+/* shakehand  with BP's PIN  */
+#define GPIO_BP_RDY            0       /* BP_RDY     */
+#define GPIO_BB_WDI            13      /* BB_WDI     */
+#define GPIO_BB_WDI2           3       /* BB_WDI2    */
+#define GPIO_BB_RESET          57      /* BB_RESET   */
+#define GPIO_MCU_INT_SW        115     /* MCU_INT_SW */
+#define GPIO_TC_MM_EN          89      /* TC_MM_EN   */
+
+/* control PCAP direct PIN */
+#define GPIO_WDI_AP            4       /* WDI_AP                       */
+#define GPIO_SYS_RESTART       55      /* restart PCAP power           */
+#define GPIO_AP_STANDBY        28      /* make pcap enter standby mode */
+
+/* communicate with PCAP's PIN  */
+#define GPIO_PCAP_SEC_INT      1       /* PCAP interrupt PIN to AP     */
+#define GPIO_SPI_CLK           23      /* PCAP SPI port clock          */
+#define GPIO_SPI_CE            24      /* PCAP SPI port SSPFRM         */
+#define GPIO_SPI_MOSI          25      /* PCAP SPI port SSPTXD         */
+#define GPIO_SPI_MISO          26      /* PCAP SPI port SSPRXD         */
+
+/*  blue tooth control PIN   */
+#define GPIO_BT_WAKEUP         2       /* AP wake up bluetooth module        */
+#define GPIO_BT_HOSTWAKE       14      /* bluetooth module wake up Ap module */
+#define GPIO_BT_RESET          56      /* AP reset bluetooth module          */
+
+/* control LCD high - OFF low -- ON  */
+#define GPIO_LCD_OFF           116     /* control LCD                */
+
+/*  FFUART PIN              */
+#define GPIO_ICL_FFRXD_MD      (34 | GPIO_ALT_FN_1_IN)
+#define GPIO_ICL_FFCTS_MD      (35 | GPIO_ALT_FN_1_IN)
+#define GPIO_ICL_FFTXD_MD      (39 | GPIO_ALT_FN_2_OUT)
+#define GPIO_ICL_FFRTS_MD      (41 | GPIO_ALT_FN_2_OUT)
+
+#elif defined(A780_P1_AND_EARLY)
+
+/* shakehand  with BP's PIN  */
+#define GPIO_BP_RDY            0       /* BP_RDY     */
+#define GPIO_BB_WDI            13      /* BB_WDI     */
+#define GPIO_BB_WDI2           3       /* BB_WDI2    */
+#define GPIO_BB_RESET          82      /* BB_RESET   */
+#define GPIO_MCU_INT_SW        57      /* MCU_INT_SW */
+#define GPIO_TC_MM_EN          89      /* TC_MM_EN   */
+
+/* control PCAP direct PIN */
+#define GPIO_WDI_AP            4       /* WDI_AP                       */
+#define GPIO_SYS_RESTART       55      /* restart PCAP power           */
+#define GPIO_AP_STANDBY        28      /* make pcap enter standby mode */
+
+/* communicate with PCAP's PIN  */
+#define GPIO_PCAP_SEC_INT      1       /* PCAP interrupt PIN to AP     */
+#define GPIO_SPI_CLK           29      /* PCAP SPI port clock          */
+#define GPIO_SPI_CE            24      /* PCAP SPI port SSPFRM         */
+#define GPIO_SPI_MOSI          25      /* PCAP SPI port SSPTXD         */
+#define GPIO_SPI_MISO          26      /* PCAP SPI port SSPRXD         */
+
+/*  blue tooth control PIN   */
+#define GPIO_BT_WAKEUP         2       /* AP wake up bluetooth module        */
+#define GPIO_BT_HOSTWAKE       14      /* bluetooth module wake up Ap module */
+#define GPIO_BT_RESET          56      /* AP reset bluetooth module          */
+
+/* control LCD high - OFF low -- ON  */
+#define GPIO_LCD_OFF           116     /* control LCD                */
+
+/*  FFUART PIN              */
+#define GPIO_ICL_FFRXD_MD      (53 | GPIO_ALT_FN_1_IN)
+#define GPIO_ICL_FFCTS_MD      (35 | GPIO_ALT_FN_1_IN)
+#define GPIO_ICL_FFTXD_MD      (39 | GPIO_ALT_FN_2_OUT)
+#define GPIO_ICL_FFRTS_MD      (41 | GPIO_ALT_FN_2_OUT)
+
+#else
+
+/* shakehand  with BP's PIN  */
+#define GPIO_BP_RDY            0       /* BP_RDY     */
+#define GPIO_BB_WDI            13      /* BB_WDI     */
+#define GPIO_BB_WDI2           3       /* BB_WDI2    */
+#define GPIO_BB_RESET          82      /* BB_RESET   */
+#define GPIO_MCU_INT_SW        57      /* MCU_INT_SW */
+#define GPIO_TC_MM_EN          99      /* TC_MM_EN   */
+
+/* control PCAP direct PIN */
+#define GPIO_WDI_AP            4       /* WDI_AP                       */
+#define GPIO_SYS_RESTART       55      /* restart PCAP power           */
+//#define GPIO_AP_STANDBY        28      /* make pcap enter standby mode */
+
+/* communicate with PCAP's PIN  */
+#define GPIO_PCAP_SEC_INT      1       /* PCAP interrupt PIN to AP     */
+#define GPIO_SPI_CLK           29      /* PCAP SPI port clock          */
+#define GPIO_SPI_CE            24      /* PCAP SPI port SSPFRM         */
+#define GPIO_SPI_MOSI          25      /* PCAP SPI port SSPTXD         */
+#define GPIO_SPI_MISO          26      /* PCAP SPI port SSPRXD         */
+
+/*  blue tooth control PIN   */
+#define GPIO_BT_WAKEUP         28      /* AP wake up bluetooth module  */
+#define GPIO_BT_HOSTWAKE       14      /* AP wake up bluetooth module  */
+#define GPIO_BT_RESET          48      /* AP reset bluetooth module    */
+
+/* control LCD high - OFF low -- ON  */
+#define GPIO_LCD_OFF           116     /* control LCD                */
+
+/*  FFUART PIN              */
+#define GPIO_ICL_FFRXD_MD      (53 | GPIO_ALT_FN_1_IN)
+#define GPIO_ICL_FFCTS_MD      (35 | GPIO_ALT_FN_1_IN)
+#define GPIO_ICL_FFTXD_MD      (39 | GPIO_ALT_FN_2_OUT)
+#define GPIO_ICL_FFRTS_MD      (41 | GPIO_ALT_FN_2_OUT)
+
+#endif
+/*
+ * ezx platform, wake up source edge detect bit
+ */
+#define PEDR_INT_SEC            1
+
+#define GPIO_FLIP_PIN          12
+/*E680 screen lock button*/
+
+#define GPIO_LOCK_SCREEN_PIN    GPIO_FLIP_PIN
+
+/* MMC interface */
+#define GPIO_MMC_DETECT         11
+#define GPIO_MMC_CLK            32
+#define GPIO_MMC_DATA0          92
+#define GPIO_MMC_WP		107
+#define GPIO_MMC_DATA1          109
+#define GPIO_MMC_DATA2          110
+#define GPIO_MMC_DATA3          111
+#define GPIO_MMC_CMD            112
+
+/* interface function */
+#define GPIO_MMC_CLK_MD         (GPIO_MMC_CLK | GPIO_ALT_FN_2_OUT)
+#define GPIO_MMC_DATA0_MD       (GPIO_MMC_DATA0 | GPIO_ALT_FN_1_IN | GPIO_ALT_FN_1_OUT)
+#define GPIO_MMC_DATA1_MD       (GPIO_MMC_DATA1 | GPIO_ALT_FN_1_IN | GPIO_ALT_FN_1_OUT)
+#define GPIO_MMC_DATA2_MD       (GPIO_MMC_DATA2 | GPIO_ALT_FN_1_IN | GPIO_ALT_FN_1_OUT)
+#define GPIO_MMC_DATA3_MD       (GPIO_MMC_DATA3 | GPIO_ALT_FN_1_IN | GPIO_ALT_FN_1_OUT)
+
+#define GPIO_MMC_CMD_MD         (GPIO_MMC_CMD | GPIO_ALT_FN_1_IN | GPIO_ALT_FN_1_OUT)
+
+/* EMU GPIO 119 ---MUX2 120 --- MUX1   */
+#define GPIO_EMU_MUX1      120
+#define GPIO_EMU_MUX2      119
+#define GPIO_SNP_INT_CTL   86
+#define GPIO_SNP_INT_IN    87
+
+
+/* audio related pins  */
+#define AP_13MHZ_OUTPUT_PIN  9
+
+#ifdef CONFIG_ARCH_EZX_E680
+#define GPIO_VA_SEL_BUL     79
+#define GPIO_FLT_SEL_BUL    80		/* out filter select pin */
+#define GPIO_MIDI_RESET    78		/* GPIO used by MIDI chipset */
+#define GPIO_MIDI_CS       33
+#define GPIO_MIDI_IRQ      15
+#define GPIO_MIDI_NPWE     49
+#define GPIO_MIDI_RDY      18
+#endif
+
+#ifdef CONFIG_ARCH_EZX_A780
+#define GPIO_HW_ATTENUATE_A780	96	/* hw noise attenuation be used or bypassed, for receiver or louderspeaker mode */
+#endif
+
+
+/* bp status pin */
+#define GPIO_BP_STATE       41
+
+/* define usb related pin  */
+#define GPIO34_TXENB        34
+#define GPIO35_XRXD         35
+#define GPIO36_VMOUT        36
+#define GPIO39_VPOUT        39
+#define GPIO40_VPIN         40
+#define GPIO53_VMIN         53
+
+/* USB client 6 pin defination */
+#define GPIO34_TXENB_MD     (GPIO34_TXENB | GPIO_ALT_FN_1_OUT)
+#define GPIO35_XRXD_MD      (GPIO35_XRXD | GPIO_ALT_FN_2_IN )
+#define GPIO36_VMOUT_MD     (GPIO36_VMOUT | GPIO_ALT_FN_1_OUT)
+#define GPIO39_VPOUT_MD     (GPIO39_VPOUT | GPIO_ALT_FN_1_OUT)
+#define GPIO40_VPIN_MD      (GPIO40_VPIN | GPIO_ALT_FN_3_IN )
+#define GPIO53_VMIN_MD      (GPIO53_VMIN | GPIO_ALT_FN_2_IN )
+
+#define GPIO53_FFRXD_MD     (53 | GPIO_ALT_FN_1_IN)
+
Index: linux-2.6.21/include/asm-arm/arch-pxa/pxa-regs.h
===================================================================
--- linux-2.6.21.orig/include/asm-arm/arch-pxa/pxa-regs.h	2007-05-01 14:00:24.000000000 -0300
+++ linux-2.6.21/include/asm-arm/arch-pxa/pxa-regs.h	2007-05-01 23:02:53.000000000 -0300
@@ -849,6 +849,8 @@
 #define UP2OCR_HXOE		(1 << 17)	/* Host Port 2 Transceiver Output Enable */
 #define UP2OCR_SEOS		(1 << 24)	/* Single-Ended Output Select */
 
+#define UP3OCR		__REG(0x40600024)  /* USB Port 3 Output Control register */
+
 #define UDCCSN(x)	__REG2(0x40600100, (x) << 2)
 #define UDCCSR0         __REG(0x40600100) /* UDC Control/Status register - Endpoint 0 */
 #define UDCCSR0_SA	(1 << 7)	/* Setup Active */
@@ -1252,6 +1254,7 @@
 #define GPIO33_nCS_5		33	/* chip select 5 */
 #define GPIO34_FFRXD		34	/* FFUART receive */
 #define GPIO34_MMCCS0		34	/* MMC Chip Select 0 */
+#define GPIO34_USB_P2_2		34	/* USB Port2 Pin 2 */
 #define GPIO35_FFCTS		35	/* FFUART Clear to send */
 #define GPIO36_FFDCD		36	/* FFUART Data carrier detect */
 #define GPIO37_FFDSR		37	/* FFUART data set ready */
@@ -1365,6 +1368,7 @@
 #define GPIO18_RDY_MD		(18 | GPIO_ALT_FN_1_IN)
 #define GPIO19_DREQ1_MD		(19 | GPIO_ALT_FN_1_IN)
 #define GPIO20_DREQ0_MD		(20 | GPIO_ALT_FN_1_IN)
+#define GPIO22_SCLK2_MD		(22 | GPIO_ALT_FN_3_IN)
 #define GPIO23_SCLK_MD		(23 | GPIO_ALT_FN_2_OUT)
 #define GPIO24_SFRM_MD		(24 | GPIO_ALT_FN_2_OUT)
 #define GPIO25_STXD_MD		(25 | GPIO_ALT_FN_2_OUT)
@@ -1375,23 +1379,33 @@
 #define GPIO28_BITCLK_OUT_I2S_MD	(28 | GPIO_ALT_FN_1_OUT)
 #define GPIO29_SDATA_IN_AC97_MD	(29 | GPIO_ALT_FN_1_IN)
 #define GPIO29_SDATA_IN_I2S_MD	(29 | GPIO_ALT_FN_2_IN)
+#define GPIO29_SCLK_MD		(29 | GPIO_ALT_FN_3_IN)
 #define GPIO30_SDATA_OUT_AC97_MD	(30 | GPIO_ALT_FN_2_OUT)
 #define GPIO30_SDATA_OUT_I2S_MD	(30 | GPIO_ALT_FN_1_OUT)
+#define GPIO30_USB_P3_2		(30 | GPIO_ALT_FN_3_OUT)
 #define GPIO31_SYNC_I2S_MD	(31 | GPIO_ALT_FN_1_OUT)
 #define GPIO31_SYNC_AC97_MD	(31 | GPIO_ALT_FN_2_OUT)
+#define GPIO31_USB_P3_6		(31 | GPIO_ALT_FN_3_OUT)
 #define GPIO32_SDATA_IN1_AC97_MD	(32 | GPIO_ALT_FN_1_IN)
 #define GPIO32_SYSCLK_I2S_MD	(32 | GPIO_ALT_FN_1_OUT)
 #define GPIO32_MMCCLK_MD		( 32 | GPIO_ALT_FN_2_OUT)
 #define GPIO33_nCS_5_MD		(33 | GPIO_ALT_FN_2_OUT)
 #define GPIO34_FFRXD_MD		(34 | GPIO_ALT_FN_1_IN)
 #define GPIO34_MMCCS0_MD	(34 | GPIO_ALT_FN_2_OUT)
+#define GPIO34_USB_P2_2_MD	(34 | GPIO_ALT_FN_1_OUT)
 #define GPIO35_FFCTS_MD		(35 | GPIO_ALT_FN_1_IN)
+#define GPIO35_USB_P2_1_MD	(35 | GPIO_ALT_FN_2_IN)
 #define GPIO36_FFDCD_MD		(36 | GPIO_ALT_FN_1_IN)
+#define GPIO36_USB_P2_4_MD	(36 | GPIO_ALT_FN_1_OUT)
 #define GPIO37_FFDSR_MD		(37 | GPIO_ALT_FN_1_IN)
+#define GPIO37_SFRM2_MD		(37 | GPIO_ALT_FN_2_IN)
 #define GPIO38_FFRI_MD		(38 | GPIO_ALT_FN_1_IN)
+#define GPIO38_STXD2_MD		(38 | GPIO_ALT_FN_2_OUT)
 #define GPIO39_MMCCS1_MD	(39 | GPIO_ALT_FN_1_OUT)
 #define GPIO39_FFTXD_MD		(39 | GPIO_ALT_FN_2_OUT)
+#define GPIO39_USB_P2_6_MD	(39 | GPIO_ALT_FN_1_OUT)
 #define GPIO40_FFDTR_MD		(40 | GPIO_ALT_FN_2_OUT)
+#define GPIO40_USB_P2_5_MD	(40 | GPIO_ALT_FN_3_IN)
 #define GPIO41_FFRTS_MD		(41 | GPIO_ALT_FN_2_OUT)
 #define GPIO42_BTRXD_MD		(42 | GPIO_ALT_FN_1_IN)
 #define GPIO42_HWRXD_MD		(42 | GPIO_ALT_FN_3_IN)
@@ -1416,13 +1430,17 @@
 #define GPIO51_HWRTS_MD         (51 | GPIO_ALT_FN_1_OUT)
 #define GPIO51_nPIOW_MD		(51 | GPIO_ALT_FN_2_OUT)
 #define GPIO52_nPCE_1_MD	(52 | GPIO_ALT_FN_2_OUT)
+#define GPIO52_SCLK3_MD		(52 | GPIO_ALT_FN_2_OUT)
 #define GPIO53_nPCE_2_MD	(53 | GPIO_ALT_FN_2_OUT)
 #define GPIO53_MMCCLK_MD	(53 | GPIO_ALT_FN_1_OUT)
+#define GPIO53_FFRXD_MD		(53 | GPIO_ALT_FN_1_IN)
+#define GPIO53_USB_P2_3_MD	(53 | GPIO_ALT_FN_2_IN)
 #define GPIO54_MMCCLK_MD	(54 | GPIO_ALT_FN_1_OUT)
 #define GPIO54_nPCE_2_MD	(54 | GPIO_ALT_FN_2_OUT)
 #define GPIO54_pSKTSEL_MD	(54 | GPIO_ALT_FN_2_OUT)
 #define GPIO55_nPREG_MD		(55 | GPIO_ALT_FN_2_OUT)
 #define GPIO56_nPWAIT_MD	(56 | GPIO_ALT_FN_1_IN)
+#define GPIO56_USB_P3_4		(56 | GPIO_ALT_FN_1_OUT)
 #define GPIO57_nIOIS16_MD	(57 | GPIO_ALT_FN_1_IN)
 #define GPIO58_LDD_0_MD		(58 | GPIO_ALT_FN_2_OUT)
 #define GPIO59_LDD_1_MD		(59 | GPIO_ALT_FN_2_OUT)
@@ -1458,13 +1476,19 @@
 #define GPIO80_nCS_4_MD		(80 | GPIO_ALT_FN_2_OUT)
 #define GPIO81_NSSP_CLK_OUT 	(81 | GPIO_ALT_FN_1_OUT)
 #define GPIO81_NSSP_CLK_IN  	(81 | GPIO_ALT_FN_1_IN)
+#define GPIO81_STXD3_MD		(81 | GPIO_ALT_FN_1_OUT)
 #define GPIO82_NSSP_FRM_OUT 	(82 | GPIO_ALT_FN_1_OUT)
 #define GPIO82_NSSP_FRM_IN  	(82 | GPIO_ALT_FN_1_IN)
 #define GPIO83_NSSP_TX      	(83 | GPIO_ALT_FN_1_OUT)
 #define GPIO83_NSSP_RX      	(83 | GPIO_ALT_FN_2_IN)
+#define GPIO83_SFRM3_MD		(83 | GPIO_ALT_FN_1_IN)
 #define GPIO84_NSSP_TX      	(84 | GPIO_ALT_FN_1_OUT)
 #define GPIO84_NSSP_RX      	(84 | GPIO_ALT_FN_2_IN)
 #define GPIO85_nPCE_1_MD	(85 | GPIO_ALT_FN_1_OUT)
+#define GPIO88_SRXD2_MD		(88 | GPIO_ALT_FN_2_IN)
+#define GPIO89_SRXD3_MD		(89 | GPIO_ALT_FN_1_IN)
+#define GPIO90_USB_P3_5		(90 | GPIO_ALT_FN_2_IN)
+#define GPIO91_USB_P3_1		(91 | GPIO_ALT_FN_2_IN)
 #define GPIO92_MMCDAT0_MD	(92 | GPIO_ALT_FN_1_OUT)
 #define GPIO102_nPCE_1_MD	(102 | GPIO_ALT_FN_1_OUT)
 #define GPIO104_pSKTSEL_MD	(104 | GPIO_ALT_FN_1_OUT)
@@ -1476,6 +1500,7 @@
 #define GPIO112_MMCCMD_MD	(112 | GPIO_ALT_FN_1_OUT)
 #define GPIO113_I2S_SYSCLK_MD	(113 | GPIO_ALT_FN_1_OUT)
 #define GPIO113_AC97_RESET_N_MD	(113 | GPIO_ALT_FN_2_OUT)
+#define GPIO113_USB_P3_3	(113 | GPIO_ALT_FN_3_IN)
 #define GPIO117_I2CSCL_MD	(117 | GPIO_ALT_FN_1_IN)
 #define GPIO118_I2CSDA_MD	(118 | GPIO_ALT_FN_1_IN)
 
@@ -1491,6 +1516,7 @@
 #define PFER		__REG(0x40F00014)  /* Power Manager GPIO Falling-Edge Detect Enable Register */
 #define PEDR		__REG(0x40F00018)  /* Power Manager GPIO Edge Detect Status Register */
 #define PCFR		__REG(0x40F0001C)  /* Power Manager General Configuration Register */
+#define PGSR(x)		(__REG(0x40F00020 + ((unsigned long)(x)/32*4)))
 #define PGSR0		__REG(0x40F00020)  /* Power Manager GPIO Sleep State Register for GP[31-0] */
 #define PGSR1		__REG(0x40F00024)  /* Power Manager GPIO Sleep State Register for GP[63-32] */
 #define PGSR2		__REG(0x40F00028)  /* Power Manager GPIO Sleep State Register for GP[84-64] */
Index: linux-2.6.21/arch/arm/boot/compressed/head.S
===================================================================
--- linux-2.6.21.orig/arch/arm/boot/compressed/head.S	2007-05-01 14:00:25.000000000 -0300
+++ linux-2.6.21/arch/arm/boot/compressed/head.S	2007-05-01 14:00:48.000000000 -0300
@@ -117,6 +117,9 @@
 		mov	r0, r0
 		.endr
 
+		mov     r1, #0x300              @ mach_id 0x363 is official EZX
+		orr     r1, r1, #0x63           @ bootloader JUMP doesn't set r1
+
 		b	1f
 		.word	0x016f2818		@ Magic numbers to help the loader
 		.word	start			@ absolute load/run zImage address
Index: linux-2.6.21/include/asm-arm/arch-pxa/uncompress.h
===================================================================
--- linux-2.6.21.orig/include/asm-arm/arch-pxa/uncompress.h	2007-05-01 14:00:24.000000000 -0300
+++ linux-2.6.21/include/asm-arm/arch-pxa/uncompress.h	2007-05-01 14:00:48.000000000 -0300
@@ -14,14 +14,14 @@
 #define STUART		((volatile unsigned long *)0x40700000)
 #define HWUART		((volatile unsigned long *)0x41600000)
 
-#define UART		FFUART
+#define UART		STUART
 
 
 static inline void putc(char c)
 {
-	while (!(UART[5] & 0x20))
+/*	while (!(UART[5] & 0x40))
 		barrier();
-	UART[0] = c;
+	UART[0] = c;*/
 }
 
 /*
Index: linux-2.6.21/arch/arm/mach-pxa/ezx_ssp.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/arm/mach-pxa/ezx_ssp.c	2007-05-01 14:00:48.000000000 -0300
@@ -0,0 +1,126 @@
+/*
+ *  SSP control code for Motorola EZX phones
+ *
+ *  Copyright (c) 2007 Daniel Ribeiro <drwyrm@gmail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <asm/hardware.h>
+#include <asm/mach-types.h>
+
+#include <asm/arch/ssp.h>
+#include <asm/arch/pxa-regs.h>
+
+#include "ezx.h"
+
+static DEFINE_SPINLOCK(ezx_ssp_lock);
+static struct ssp_dev ezx_ssp_dev;
+static struct ssp_state ezx_ssp_state;
+static struct ezxssp_machinfo *ssp_machinfo;
+
+/* PCAP */
+unsigned long ezx_ssp_pcap_putget(ulong data)
+{
+	unsigned long flag;
+	u32 ret = 0;
+
+	spin_lock_irqsave(&ezx_ssp_lock, flag);
+	if (ssp_machinfo->cs_pcap >= 0)
+		GPCR(ssp_machinfo->cs_pcap) = GPIO_bit(ssp_machinfo->cs_pcap);
+
+	ssp_write_word(&ezx_ssp_dev,data);
+ 	ssp_read_word(&ezx_ssp_dev, &ret);
+
+	if (ssp_machinfo->cs_pcap >= 0)
+		GPSR(ssp_machinfo->cs_pcap) = GPIO_bit(ssp_machinfo->cs_pcap);
+	spin_unlock_irqrestore(&ezx_ssp_lock, flag);
+
+	return ret;
+}
+EXPORT_SYMBOL(ezx_ssp_pcap_putget);
+
+void __init ezx_ssp_set_machinfo(struct ezxssp_machinfo *machinfo)
+{
+	ssp_machinfo = machinfo;
+}
+
+static int __init ezx_ssp_probe(struct platform_device *dev)
+{
+	int ret;
+	/* PCAP init */
+	pxa_gpio_mode(29|GPIO_ALT_FN_3_OUT);
+	pxa_gpio_mode(GPIO24_SFRM_MD);
+	pxa_gpio_mode(GPIO25_STXD_MD);
+	pxa_gpio_mode(GPIO26_SRXD_MD);
+
+	/* Chip Select - Disable All */
+	if (ssp_machinfo->cs_pcap >= 0)
+		pxa_gpio_mode(ssp_machinfo->cs_pcap | GPIO_OUT | GPIO_DFLT_HIGH);
+
+	ret = ssp_init(&ezx_ssp_dev, ssp_machinfo->port, 0);
+
+	if (ret)
+		printk(KERN_ERR "Unable to register SSP handler!\n");
+	else {
+		ssp_disable(&ezx_ssp_dev);
+		ssp_config(&ezx_ssp_dev,
+			(SSCR0_Motorola | SSCR0_DataSize(16) | SSCR0_EDSS),
+			(SSCR1_TxTresh(1) | SSCR1_RxTresh(1)),
+			0, SSCR0_SerClkDiv(ssp_machinfo->clk_pcap));
+		ssp_enable(&ezx_ssp_dev);
+	}
+
+	return ret;
+}
+
+static int ezx_ssp_remove(struct platform_device *dev)
+{
+	ssp_exit(&ezx_ssp_dev);
+	return 0;
+}
+
+static int ezx_ssp_suspend(struct platform_device *dev, pm_message_t state)
+{
+	ssp_flush(&ezx_ssp_dev);
+	ssp_save_state(&ezx_ssp_dev,&ezx_ssp_state);
+
+	return 0;
+}
+
+static int ezx_ssp_resume(struct platform_device *dev)
+{
+	if (ssp_machinfo->cs_pcap >= 0)
+		GPSR(ssp_machinfo->cs_pcap) = GPIO_bit(ssp_machinfo->cs_pcap);
+	ssp_restore_state(&ezx_ssp_dev,&ezx_ssp_state);
+	ssp_enable(&ezx_ssp_dev);
+
+	return 0;
+}
+
+static struct platform_driver ezxssp_driver = {
+	.probe		= ezx_ssp_probe,
+	.remove		= ezx_ssp_remove,
+	.suspend	= ezx_ssp_suspend,
+	.resume		= ezx_ssp_resume,
+	.driver		= {
+		.name	= "ezx-ssp",
+	},
+};
+
+int __init ezx_ssp_init(void)
+{
+	return platform_driver_register(&ezxssp_driver);
+}
+
+arch_initcall(ezx_ssp_init);
Index: linux-2.6.21/arch/arm/mach-pxa/ezx.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/arm/mach-pxa/ezx.h	2007-05-01 14:00:48.000000000 -0300
@@ -0,0 +1,9 @@
+#include <asm/arch/ezx.h>
+
+/* SSP */
+struct ezxssp_machinfo {
+	int port;
+	int cs_pcap;
+	int clk_pcap;
+};
+
Index: linux-2.6.21/arch/arm/mach-pxa/ezx_lcd.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.21/arch/arm/mach-pxa/ezx_lcd.c	2007-05-01 22:53:54.000000000 -0300
@@ -0,0 +1,113 @@
+/*
+ *  linux/arch/arm/mach-ezx/a780.c
+ *
+ *  Support for the Motorola Ezx A780 Development Platform.
+ *
+ *  Author:	Zhuang Xiaofan
+ *  Created:	Nov 25, 2003
+ *  Copyright:	Motorola Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include <linux/fb.h>
+#include <linux/delay.h>
+#include <asm/arch/pxafb.h>
+#include <asm/arch/pxa-regs.h>
+
+/*
+ * EZX PXA Framebuffer
+ */
+
+static void pxafb_lcd_power(int on, struct fb_var_screeninfo *var)
+{
+	if (on) {
+//		mdelay(1);
+		GPSR3 = 0x00100000;
+		mdelay(10);
+		GPCR3 = 0x00100000;
+		GPDR3 |= 0x00100000;
+	} else {
+		GPSR3 = 0x00100000;
+		PGSR3 |= 0x00100000;
+		mdelay(41);
+		LCCR0 &= ~LCCR0_LDM;	/* disable lcd disable done interrupt */
+		LCCR0 |= LCCR0_DIS;	/* normal disable lcd */
+		mdelay(18);
+	}
+}
+
+static void ezx_backlight_power(int on)
+{
+       if (on) {
+               pxa_gpio_mode(GPIO16_PWM0_MD);
+               pxa_set_cken(CKEN0_PWM0, 1);
+               PWM_CTRL0 = 0;
+               PWM_PWDUTY0 = 0x3ff;
+               PWM_PERVAL0 = 0x3ff;
+       } else {
+               PWM_CTRL0 = 0;
+               PWM_PWDUTY0 = 0x0;
+               PWM_PERVAL0 = 0x3FF;
+               pxa_set_cken(CKEN0_PWM0, 0);
+       }
+}
+
+#ifdef CONFIG_PXA_E2
+static struct pxafb_mode_info mode_ezx = {
+       .pixclock = 192308,
+       .xres = 240,
+       .yres = 320,
+       .bpp = 8,
+       .hsync_len = 10,
+       .left_margin = 20,
+       .right_margin = 10,
+       .vsync_len = 2,
+       .upper_margin = 3,
+       .lower_margin = 2,
+       .sync = FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+};
+
+static struct pxafb_mach_info ezx_fb_info = {
+       .modes = &mode_ezx,
+       .num_modes = 1,
+       .lccr0 = 0x022008B8,
+       .lccr3 = 0xC130FF13,
+       .pxafb_backlight_power = ezx_backlight_power,
+       .pxafb_lcd_power = &pxafb_lcd_power,
+};
+
+#else
+static struct pxafb_mode_info mode_ezx = {
+	.pixclock	= 150000,
+	.xres		= 240,
+	.yres		= 320,
+	.bpp		= 16,
+	.hsync_len	= 10,
+	.left_margin	= 20,
+	.right_margin	= 10,
+	.vsync_len	= 2,
+	.upper_margin	= 3,
+	.lower_margin	= 2,
+	.sync		= FB_SYNC_HOR_HIGH_ACT | FB_SYNC_VERT_HIGH_ACT,
+};
+
+static struct pxafb_mach_info ezx_fb_info = {
+	.modes		= &mode_ezx,
+	.num_modes	= 1,
+	.lccr0		= 0x002008F8,
+	.lccr3		= 0x0430FF09,
+	.pxafb_backlight_power = ezx_backlight_power,
+	.pxafb_lcd_power = &pxafb_lcd_power,
+};
+#endif
+
+int __init __ezx_lcd_init (void)
+{
+	set_pxa_fb_info(&ezx_fb_info);
+	return 0;
+}
+
+arch_initcall(__ezx_lcd_init);
Index: linux-2.6.21/arch/arm/mm/init.c
===================================================================
--- linux-2.6.21.orig/arch/arm/mm/init.c	2007-05-01 14:00:25.000000000 -0300
+++ linux-2.6.21/arch/arm/mm/init.c	2007-05-01 14:00:48.000000000 -0300
@@ -241,6 +241,10 @@
 	 */
 	reserve_bootmem_node(pgdat, boot_pfn << PAGE_SHIFT,
 			     boot_pages << PAGE_SHIFT);
+#ifdef CONFIG_ARCH_EZX
+	/* reserve the first page memory for exiting sleep and user off */
+	reserve_bootmem_node(pgdat, PHYS_OFFSET, PAGE_SIZE);
+#endif
 
 #ifdef CONFIG_BLK_DEV_INITRD
 	/*
