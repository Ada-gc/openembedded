Index: linux-2.6.16.5-ezx/drivers/misc/ezx/ssp_pcap_main.c
===================================================================
--- linux-2.6.16.5-ezx.orig/drivers/misc/ezx/ssp_pcap_main.c	2006-04-17 08:39:05.000000000 -0300
+++ linux-2.6.16.5-ezx/drivers/misc/ezx/ssp_pcap_main.c	2006-04-29 08:55:28.000000000 -0300
@@ -56,7 +56,7 @@
 #endif
 
 #include "ssp_pcap.h"
-//#define  SSP_PCAP_OPERATE_WITH_SPI                                  
+#define  SSP_PCAP_OPERATE_WITH_SPI                                  
 
 static u32 ssp_pcap_operate_pin_with_inverter;                
 static u32 ssp_pcap_rxd_pin_with_inverter;                
@@ -91,12 +91,12 @@
 #ifdef SSP_PCAP_OPERATE_WITH_SPI
 static wait_queue_head_t ssp_pcap_send_wait;
 static U32 ssp_pcap_readValue;
-static void ssp_interrupt_routine(int irq, void *dev_id, struct pt_regs *regs );
+static irqreturn_t ssp_interrupt_routine(int irq, void *dev_id, struct pt_regs *regs );
 void ssp_put_intoData(U32 pcapValue);
 #endif
 
 static spinlock_t pcapoperation_lock = SPIN_LOCK_UNLOCKED;
-static void ssp_pcap_interrupt_routine(int irq, void *dev_id, struct pt_regs *regs );
+static irqreturn_t ssp_pcap_interrupt_routine(int irq, void *dev_id, struct pt_regs *regs );
 //static U32 ssp_pcapRegisterReadOut = 0;
 
 //static void usb_hardware_switch(void);
@@ -928,6 +928,35 @@
     printk(string);
     return;
 }
+#else
+static u32 test_pcap_spi(void)
+{
+    u32 ret = FALSE;
+    int i;
+    u32 temp;
+    /* write a data 0x0003ffff to IMR */
+    SSP_PCAP_write_data_to_PCAP(1, 0x0003ffff);
+    SSP_PCAP_read_data_from_PCAP(1, &temp);
+    if( 0x0003ffff == temp)
+        ret = TRUE; 
+
+    SSP_PCAP_write_data_to_PCAP(1, 0x0013ffff);
+
+    for(i=0; i<32 ;i++)
+    {
+        if(SSP_PCAP_SUCCESS == SSP_PCAP_read_data_from_PCAP(i,&temp))
+        {
+            ssp_pcap_registerValue[i] = temp;
+        }
+        else
+        {
+            ssp_pcap_registerValue[i] = 0; 
+        }
+    }
+
+    return ret;
+}
+
 #endif
 /*---------------------------------------------------------------------------
   DESCRIPTION:
@@ -968,17 +997,20 @@
 #endif
 
 #ifdef SSP_PCAP_OPERATE_WITH_SPI
-    CKEN    |= CKEN3_SSP;
-    pxa_gpio_mode(GPIO_SPI_CLK|(GPIO_SPI_CLK == GPIO23_SCLK? GPIO_ALT_FN_2_OUT:GPIO_ALT_FN_3_OUT);
-    pxa_gpio_mode(GPIO_SPI_CE|GPIO_ALT_FN_2_OUT);
-    pxa_gpio_mode(GPIO_SPI_MOSI|GPIO_ALT_FN_2_OUT);
-    pxa_gpio_mode(GPIO_SPI_MISO|GPIO_ALT_FN_1_IN);
+    CKEN    |= CKEN23_SSP1;
+    pxa_gpio_mode(29|GPIO_ALT_FN_3_OUT);
+    pxa_gpio_mode(GPIO24_SFRM_MD);
+    pxa_gpio_mode(GPIO25_STXD_MD);
+    pxa_gpio_mode(GPIO26_SRXD_MD);
 
-    SSCR1   = 0x00000401;
+    SSCR1 = SSCR1_TxTresh(1) | SSCR1_RxTresh(1) | SSCR1_RIE;
     SSCR0   = 0x00000000;
-    SSCR0   = 0x0000008f;
+    SSCR0  = SSCR0_DataSize(16) | SSCR0_EDSS | SSCR0_SSE | SSCR0_SerClkDiv(1);
+
     init_waitqueue_head(&ssp_pcap_send_wait);
     request_irq(IRQ_SSP,ssp_interrupt_routine,0,"SSP received the data irq ",NULL);
+
+    test_pcap_spi();
 #else
 #ifdef SSP_PCAP_OPERATE_DEBUG_INFORNMATION
     printk(" \n ********************* \n SSP GPIO mode init \n");
@@ -1100,11 +1132,13 @@
 ---------------------------------------------------------------------------*/
 void pcap_switch_off_usb(void)
 {
+#ifndef SSP_PCAP_OPERATE_WITH_SPI
     if(!ssp_pcap_init_is_ok)
     {
         ssp_pcap_gpioInit();
 	ssp_pcap_init_is_ok = 1;
     }
+#endif
     /*  only for PST tool recognize the USB cable  */
     if(SSP_PCAP_BIT_ONE == SSP_PCAP_get_bit_from_PCAP(SSP_PCAP_ADJ_BIT_PSTAT_USBDET_4V ))
     {
@@ -1665,14 +1699,16 @@
 
 ---------------------------------------------------------------------------*/
 #ifdef SSP_PCAP_OPERATE_WITH_SPI
+static int int_executed = 0;
 /*  ssp has received 2 bytes, the function will be invoked.  */
-static void ssp_interrupt_routine(int irq, void *dev_id, struct pt_regs *regs )
+static irqreturn_t ssp_interrupt_routine(int irq, void *dev_id, struct pt_regs *regs )
 {
 #ifdef SSP_PCAP_OPERATE_DEBUG_INFORNMATION
     printk("\n SSP INTERRUPT WAS CALLED \n ");  
 #endif 
     if(SSSR&SSP_SR_RNE)
     {
+#if 0
         ssp_pcap_readValue = (SSDR&SSP_PCAP_REGISTER_VALUE_DOWN_WORD_MASK)<<16;
         if(SSSR&SSP_SR_RNE)
         {
@@ -1686,15 +1722,19 @@
                 ssp_pcap_readValue = 0;
             }
 	}
+#else
+	ssp_pcap_readValue = SSDR;
+#endif
 #ifdef SSP_PCAP_OPERATE_DEBUG_INFORNMATION
         printk("\n SSP INTERRUPT send wakeup info \n ");  
 #endif 
-	wake_up(&ssp_pcap_send_wait);
+	//wake_up(&ssp_pcap_send_wait);
+	int_executed = 1;
     }
 #ifdef SSP_PCAP_OPERATE_DEBUG_INFORNMATION
     printk("\n SSP INTERRUPT EXIT \n ");   
 #endif
-    return;
+    return IRQ_HANDLED;
 }
 
 #endif
@@ -1853,7 +1893,7 @@
      return;
 }
 
-static void ssp_pcap_interrupt_routine(int irq, void *dev_id, struct pt_regs *regs )
+static irqreturn_t ssp_pcap_interrupt_routine(int irq, void *dev_id, struct pt_regs *regs )
 {
     u32 pcap_repeat_num;
     U32 tempValue;
@@ -2059,7 +2099,7 @@
 #endif
         }  
     }
-    return;
+    return IRQ_HANDLED;
 }
 
 /*---------------------------------------------------------------------------
@@ -2080,22 +2120,12 @@
 
 void ssp_put_intoData(U32 pcapValue)
 {
-#ifdef SSP_PCAP_OPERATE_DEBUG_INFORNMATION
-    char string[100];
-#endif
-    U32 tempFirstByte;
-    U32 tempSecondByte;
-    tempFirstByte = (pcapValue&SSP_PCAP_REGISTER_VALUE_UP_WORD_MASK)>>SSP_PCAP_REGISTER_VALUE_LENGTH;
-    tempSecondByte = (pcapValue&SSP_PCAP_REGISTER_VALUE_DOWN_WORD_MASK);
-	/* disable all interrupt or disable the SSP (zero to SSE) */
+    /* disable all interrupt or disable the SSP (zero to SSE) */
     local_irq_disable();
-    SSDR = tempFirstByte ;
-    SSDR = tempSecondByte ;
+    SSDR = pcapValue;
     local_irq_enable();
 #ifdef SSP_PCAP_OPERATE_DEBUG_INFORNMATION
-    printk("\n ssp put dat  \n");
-    sprintf( string,"\n fisrt part =%8x  second part =%8x \n",tempFirstByte,tempSecondByte);
-    printk(string);
+    printk("ssp_put_intoData = 0x%08x\n", pcapValue);
 #endif
     return;
 }
@@ -2121,8 +2151,10 @@
     unsigned long flags;
     /* prevent the process schedule out and mask the PCAP's interrupt handler */
     //ICMR &= ~(1<<(GPIO1_RST+PXA_IRQ_SKIP));
+#ifndef SSP_PCAP_OPERATE_WITH_SPI
     save_flags(flags);
-    local_irq_disable();
+    //local_irq_disable();
+#endif
     spin_lock(&pcapoperation_lock);
 
     if(!test_and_set_bit(0,&ssp_pcap_status)) 
@@ -2152,9 +2184,13 @@
                 ssp_pcap_registerValue[sspPcapRegister] = registerValue&SSP_PCAP_REGISTER_VALUE_MASK;
                 pcapTempValue = SSP_PCAP_REGISTER_WRITE_OP_BIT|(sspPcapRegister<<SSP_PCAP_REGISTER_ADDRESS_SHIFT )|(ssp_pcap_registerValue[sspPcapRegister]);
 
+		printk(KERN_ERR "write 0x%08x to register %u\n", registerValue, sspPcapRegister);
 #ifdef SSP_PCAP_OPERATE_WITH_SPI
                 ssp_put_intoData(pcapTempValue);
-                interruptible_sleep_on(&ssp_pcap_send_wait);
+		//SSITR_P1 = 0x40;
+                //interruptible_sleep_on(&ssp_pcap_send_wait);
+		do {} while (int_executed == 0);
+		int_executed = 0;
                 /* here need to judge the wakeup reason and handle it */
 #else
                 ssp_pcap_gpioWrite(pcapTempValue);
@@ -2163,7 +2199,9 @@
 
                 /* Now it's OK */
                 spin_unlock(&pcapoperation_lock);
+#ifndef SSP_PCAP_OPERATE_WITH_SPI
                 restore_flags(flags);
+#endif
                 //ICMR |= (1<<(GPIO1_RST+PXA_IRQ_SKIP));
 /*
 #ifdef  PCAP_LOG_FFUART_OUT
@@ -2178,7 +2216,9 @@
 
                 /* Now it's OK */
                 spin_unlock(&pcapoperation_lock);
+#ifndef SSP_PCAP_OPERATE_WITH_SPI
                 restore_flags(flags);
+#endif
                 //ICMR |= (1<<(GPIO1_RST+PXA_IRQ_SKIP));
 /*
 #ifdef  PCAP_LOG_FFUART_OUT
@@ -2195,7 +2235,9 @@
 
          /* Now it's OK */
          spin_unlock(&pcapoperation_lock);
+#ifndef SSP_PCAP_OPERATE_WITH_SPI
          restore_flags(flags);
+#endif
          //ICMR |= (1<<(GPIO1_RST+PXA_IRQ_SKIP));
 /*
 #ifdef  PCAP_LOG_FFUART_OUT
@@ -2232,8 +2274,10 @@
 */
     /* prevent the process schedule out and mask the PCAP's interrupt handler */
     //ICMR &= ~(1<<(GPIO1_RST+PXA_IRQ_SKIP));
+#ifndef SSP_PCAP_OPERATE_WITH_SPI
     save_flags(flags);
-    local_irq_disable();
+    //local_irq_disable();
+#endif
     spin_lock(&pcapoperation_lock);
       
     if(!test_and_set_bit(0,&ssp_pcap_status)) 
@@ -2263,8 +2307,11 @@
 #ifdef SSP_PCAP_OPERATE_WITH_SPI
                 pcapTempValue = SSP_PCAP_REGISTER_READ_OP_BIT|(sspPcapRegister<<SSP_PCAP_REGISTER_ADDRESS_SHIFT );
                 ssp_put_intoData(pcapTempValue);
+		//SSITR_P1 = 0x40;
                 /* sleep with timeout */
-                interruptible_sleep_on(&ssp_pcap_send_wait);
+                //interruptible_sleep_on(&ssp_pcap_send_wait);
+		do {} while (int_executed == 0);
+		int_executed = 0;
 
                 /* here need to judge the wakeup reason and handle it */
 //				if (signal_pending(current)) {
@@ -2276,11 +2323,16 @@
                 ssp_pcap_gpioRead(sspPcapRegister,pSspPcapRegisterValue);
 #endif
                 ssp_pcap_registerValue[sspPcapRegister] = *pSspPcapRegisterValue&SSP_PCAP_REGISTER_VALUE_MASK;
+
+		printk(KERN_ERR "Read from Register %u: 0x%08x\n", sspPcapRegister, 
+			*pSspPcapRegisterValue&SSP_PCAP_REGISTER_VALUE_MASK);
                 clear_bit(0,&ssp_pcap_status);
 
                 /* Now it's OK */
                 spin_unlock(&pcapoperation_lock);
+#ifndef SSP_PCAP_OPERATE_WITH_SPI
                 restore_flags(flags);
+#endif
                 //ICMR |= (1<<(GPIO1_RST+PXA_IRQ_SKIP));
                 return SSP_PCAP_SUCCESS;
                 /* maybe here should NOT be a break */
@@ -2290,7 +2342,9 @@
                 
                 /* Now it's OK */
                 spin_unlock(&pcapoperation_lock);
+#ifndef SSP_PCAP_OPERATE_WITH_SPI
                 restore_flags(flags);
+#endif
                 //ICMR |= (1<<(GPIO1_RST+PXA_IRQ_SKIP));
                 return SSP_PCAP_ERROR_REGISTER;
                 /* maybe here should NOT be a break */
@@ -2301,7 +2355,9 @@
     {
         /* Now it's OK */
         spin_unlock(&pcapoperation_lock);
+#ifndef SSP_PCAP_OPERATE_WITH_SPI
         restore_flags(flags);
+#endif
         //ICMR |= (1<<(GPIO1_RST+PXA_IRQ_SKIP));
         return SSP_PCAP_NOT_RUN;
     }    
Index: linux-2.6.16.5-ezx/include/asm-arm/arch-pxa/pxa-regs.h
===================================================================
--- linux-2.6.16.5-ezx.orig/include/asm-arm/arch-pxa/pxa-regs.h	2006-04-27 13:26:08.000000000 -0300
+++ linux-2.6.16.5-ezx/include/asm-arm/arch-pxa/pxa-regs.h	2006-04-27 15:21:37.000000000 -0300
@@ -1687,6 +1687,7 @@
 #define SSCR1_RSRE		(1 << 20)	/* Receive Service Request Enable */
 #define SSCR1_TINTE		(1 << 19)	/* Receiver Time-out Interrupt enable */
 #define SSCR1_PINTE		(1 << 18)	/* Peripheral Trailing Byte Interupt Enable */
+#define SSCR1_IFS		(1 << 16)	/* Invert Frame Signal */
 #define SSCR1_STRF		(1 << 15)	/* Select FIFO or EFWR */
 #define SSCR1_EFWR		(1 << 14)	/* Enable FIFO Write/Read */
 
