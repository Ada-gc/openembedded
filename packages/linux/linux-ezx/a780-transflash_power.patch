Index: linux-2.6.16.5-ezx/arch/arm/mach-pxa/ezx.c
===================================================================
--- linux-2.6.16.5-ezx.orig/arch/arm/mach-pxa/ezx.c	2006-05-02 19:17:34.000000000 +0200
+++ linux-2.6.16.5-ezx/arch/arm/mach-pxa/ezx.c	2006-05-02 22:30:24.000000000 +0200
@@ -137,10 +137,63 @@
 	/* this is only e680, i guess */
 }
 
+#if defined(CONFIG_PXA_EZX_A780)
+static u_int8_t mmc_voltage[] = {
+	[MMC_VDD_160] = 5,
+	[MMC_VDD_170] = 5,
+	[MMC_VDD_180] = 6,
+	[MMC_VDD_190] = 6,
+	[MMC_VDD_200] = 7,
+	[MMC_VDD_210] = 7,
+	[MMC_VDD_220] = 8,
+	[MMC_VDD_230] = 8,
+	[MMC_VDD_240] = 9,
+	[MMC_VDD_250] = 9,
+	[MMC_VDD_260] = 10,
+	[MMC_VDD_270] = 10,
+	[MMC_VDD_280] = 11,
+	[MMC_VDD_290] = 11,
+	[MMC_VDD_300] = 12,
+	[MMC_VDD_310] = 12,
+	[MMC_VDD_320] = 13,
+	[MMC_VDD_330] = 13,
+	[MMC_VDD_340] = 14,
+	[MMC_VDD_350] = 14,
+	[MMC_VDD_360] = 15,
+};
+#elif defined(CONFIG_PXA_EZX_E680)
+static u_int8_t mmc_voltage[] = {
+	[MMC_VDD_160] = 3,
+	[MMC_VDD_170] = 3,
+	[MMC_VDD_180] = 3,
+	[MMC_VDD_190] = 3,
+	[MMC_VDD_200] = 3,
+	[MMC_VDD_210] = 3,
+	[MMC_VDD_220] = 3,
+	[MMC_VDD_230] = 3,
+	[MMC_VDD_240] = 3,
+	[MMC_VDD_250] = 3,
+	[MMC_VDD_260] = 3,
+	[MMC_VDD_270] = 3,
+	[MMC_VDD_280] = 3,
+	[MMC_VDD_290] = 3,
+	[MMC_VDD_300] = 3,
+	[MMC_VDD_310] = 3,
+	[MMC_VDD_320] = 3,
+	[MMC_VDD_330] = 3,
+	[MMC_VDD_340] = 3,
+	[MMC_VDD_350] = 3,
+	[MMC_VDD_360] = 3,
+
+};
+#endif
+
 static void ezx_mci_setpower(struct device *dev, unsigned int vdd)
 {
-	printk("%s entered\n", __FUNCTION__);
-	/* FIXME: implement this */
+	printk("%s(vdd=%u) entered\n", __FUNCTION__, vdd);
+	if (vdd <= MMC_VDD_360)
+		SSP_PCAP_MMCSD_voltage(mmc_voltage[vdd]);
+
 	SSP_PCAP_MMCSD_poweron();
 }
 
@@ -152,7 +205,14 @@
 }
 
 static struct pxamci_platform_data ezx_mci_platform_data = {
-	.ocr_mask	= MMC_VDD_27_28, //|MMC_VDD_32_33|MMC_VDD_33_34,
+#if defined(CONFIG_PXA_EZX_E680)
+	.ocr_mask	= MMC_VDD_27_28,
+#elif defined(CONFIG_PXA_EZX_A780)
+	.ocr_mask	= MMC_VDD_160_165|MMC_VDD_18_19|MMC_VDD_20_21
+			  |MMC_VDD_22_23|MMC_VDD_24_25|MMC_VDD_26_27
+			  |MMC_VDD_28_29|MMC_VDD_30_31|MMC_VDD_32_33
+			  |MMC_VDD_34_35|MMC_VDD_35_36,
+#endif
 	.init		= ezx_mci_init,
 	.get_ro		= ezx_mci_get_ro,
 	.setpower	= ezx_mci_setpower,
Index: linux-2.6.16.5-ezx/drivers/misc/ezx/ssp_pcap_main.c
===================================================================
--- linux-2.6.16.5-ezx.orig/drivers/misc/ezx/ssp_pcap_main.c	2006-05-02 19:17:34.000000000 +0200
+++ linux-2.6.16.5-ezx/drivers/misc/ezx/ssp_pcap_main.c	2006-05-02 22:29:58.000000000 +0200
@@ -125,18 +125,41 @@
 
 void SSP_PCAP_MMCSD_poweroff(void)
 {
+#if defined(CONFIG_PXA_EZX_E680)
     SSP_PCAP_bit_clean(SSP_PCAP_ADJ_BIT_AUX_VREG_VAUX2_EN);
     SSP_PCAP_bit_clean(SSP_PCAP_ADJ_BIT_AUX_VREG_VAUX2_EN);
+#else
+    SSP_PCAP_bit_clean(SSP_PCAP_ADJ_BIT_AUX_VREG_VAUX3_EN);
+#endif
 }
 EXPORT_SYMBOL(SSP_PCAP_MMCSD_poweroff);
 
 void SSP_PCAP_MMCSD_poweron(void)
 {
+#if defined(CONFIG_PXA_EZX_E680)
     SSP_PCAP_bit_set(SSP_PCAP_ADJ_BIT_AUX_VREG_VAUX2_EN);
     SSP_PCAP_bit_set(SSP_PCAP_ADJ_BIT_AUX_VREG_VAUX2_EN);
+#elif defined(CONFIG_PXA_EZX_A780)
+    SSP_PCAP_bit_set(SSP_PCAP_ADJ_BIT_AUX_VREG_VAUX3_EN);
+#endif
 }
 EXPORT_SYMBOL(SSP_PCAP_MMCSD_poweron);
 
+void SSP_PCAP_MMCSD_voltage(unsigned char bits)
+{
+	unsigned int tmp;
+	SSP_PCAP_read_data_from_PCAP(SSP_PCAP_ADJ_AUX_VREG_REGISTER, &tmp);
+#if defined(CONFIG_PXA_EZX_E680)
+	tmp &= 0xffffff9f;	/* zero all vaux2 bits */
+	tmp |= (bits & 0x3) << 5;
+#elif defined(CONFIG_PXA_EZX_A780)
+	tmp &= 0xfffff0ff;	/* zero all vaux3 bits */
+	tmp |= (bits & 0xf) << 8;
+#endif
+	SSP_PCAP_write_data_to_PCAP(SSP_PCAP_ADJ_AUX_VREG_REGISTER, tmp);
+}
+EXPORT_SYMBOL(SSP_PCAP_MMCSD_voltage);
+
 static void accessory_bus_detect_handler(ACCESSORY_TYPE type,ACCESSORY_DEVICE_STATUS status,void* privdata )
 {
     sspUsbAccessoryInfo.type = (u32)type;
