diff -Naur linux-2.6.12.6/drivers/media/dvb/dvb-core/compat.h linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/compat.h
--- linux-2.6.12.6/drivers/media/dvb/dvb-core/compat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/compat.h	2006-04-11 14:31:37.000000000 +0200
@@ -0,0 +1,19 @@
+#ifndef _COMPAT_H
+#define _COMPAT_H
+
+#include <linux/i2c-id.h>
+#include <linux/version.h>
+#include <linux/utsname.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+# define class_device_create(a, b, c, d, e, f, g, h) class_simple_device_add(a, c, d, e, f, g, h)
+# define class_device_destroy(a, b...) class_simple_device_remove(b)
+# define class_create class_simple_create
+# define class_destroy class_simple_destroy
+# define class class_simple
+# define try_to_freeze() do { if (current->flags & PF_FREEZE) refrigerator(PF_FREEZE); } while(0)
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+# define class_device_create(a, b, c, d, e, f, g, h) class_device_create(a, c, d, e, f, g, h)
+#endif
+
+#endif
diff -Naur linux-2.6.12.6/drivers/media/dvb/dvb-core/demux.h linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/demux.h
--- linux-2.6.12.6/drivers/media/dvb/dvb-core/demux.h	2005-08-29 18:55:27.000000000 +0200
+++ linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/demux.h	2006-04-11 14:31:37.000000000 +0200
@@ -30,6 +30,7 @@
 #include <linux/errno.h>
 #include <linux/list.h>
 #include <linux/time.h>
+#include <linux/dvb/dmx.h>
 
 /*--------------------------------------------------------------------------*/
 /* Common definitions */
@@ -47,8 +48,11 @@
  * DMX_MAX_SECFEED_SIZE: Maximum length (in bytes) of a private section feed filter.
  */
 
+#ifndef DMX_MAX_SECTION_SIZE
+#define DMX_MAX_SECTION_SIZE 4096
+#endif
 #ifndef DMX_MAX_SECFEED_SIZE
-#define DMX_MAX_SECFEED_SIZE 4096
+#define DMX_MAX_SECFEED_SIZE (DMX_MAX_SECTION_SIZE + 188)
 #endif
 
 
@@ -124,9 +128,7 @@
 		    u16 pid,
 		    int type,
 		    enum dmx_ts_pes pes_type,
-		    size_t callback_length,
 		    size_t circular_buffer_size,
-		    int descramble,
 		    struct timespec timeout);
         int (*start_filtering) (struct dmx_ts_feed* feed);
         int (*stop_filtering) (struct dmx_ts_feed* feed);
@@ -159,7 +161,6 @@
         int (*set) (struct dmx_section_feed* feed,
 		    u16 pid,
 		    size_t circular_buffer_size,
-		    int descramble,
 		    int check_crc);
         int (*allocate_filter) (struct dmx_section_feed* feed,
 				struct dmx_section_filter** filter);
@@ -207,7 +208,6 @@
         struct list_head connectivity_list; /* List of front-ends that can
 					       be connected to a particular
 					       demux */
-        void* priv;     /* Pointer to private data of the API client */
         enum dmx_frontend_source source;
 };
 
@@ -225,8 +225,6 @@
 #define DMX_MEMORY_BASED_FILTERING              8    /* write() available */
 #define DMX_CRC_CHECKING                        16
 #define DMX_TS_DESCRAMBLING                     32
-#define DMX_SECTION_PAYLOAD_DESCRAMBLING        64
-#define DMX_MAC_ADDRESS_DESCRAMBLING            128
 
 /*
  * Demux resource type identifier.
@@ -244,9 +242,7 @@
 struct dmx_demux {
         u32 capabilities;            /* Bitfield of capability flags */
         struct dmx_frontend* frontend;    /* Front-end connected to the demux */
-        struct list_head reg_list;   /* List of registered demuxes */
         void* priv;                  /* Pointer to private data of the API client */
-        int users;                   /* Number of users */
         int (*open) (struct dmx_demux* demux);
         int (*close) (struct dmx_demux* demux);
         int (*write) (struct dmx_demux* demux, const char* buf, size_t count);
@@ -260,17 +256,6 @@
 				      dmx_section_cb callback);
         int (*release_section_feed) (struct dmx_demux* demux,
 				     struct dmx_section_feed* feed);
-        int (*descramble_mac_address) (struct dmx_demux* demux,
-				       u8* buffer1,
-				       size_t buffer1_length,
-				       u8* buffer2,
-				       size_t buffer2_length,
-				       u16 pid);
-        int (*descramble_section_payload) (struct dmx_demux* demux,
-					   u8* buffer1,
-					   size_t buffer1_length,
-					   u8* buffer2, size_t buffer2_length,
-					   u16 pid);
         int (*add_frontend) (struct dmx_demux* demux,
 			     struct dmx_frontend* frontend);
         int (*remove_frontend) (struct dmx_demux* demux,
@@ -282,20 +267,12 @@
 
         int (*get_pes_pids) (struct dmx_demux* demux, u16 *pids);
 
+	int (*get_caps) (struct dmx_demux* demux, struct dmx_caps *caps);
+
+	int (*set_source) (struct dmx_demux* demux, const dmx_source_t *src);
+
         int (*get_stc) (struct dmx_demux* demux, unsigned int num,
 			u64 *stc, unsigned int *base);
 };
 
-/*--------------------------------------------------------------------------*/
-/* Demux directory */
-/*--------------------------------------------------------------------------*/
-
-/*
- * DMX_DIR_ENTRY(): Casts elements in the list of registered
- * demuxes from the generic type struct list_head* to the type struct dmx_demux
- *.
- */
-
-#define DMX_DIR_ENTRY(list) list_entry(list, struct dmx_demux, reg_list)
-
 #endif /* #ifndef __DEMUX_H */
diff -Naur linux-2.6.12.6/drivers/media/dvb/dvb-core/dmxdev.c linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/dmxdev.c
--- linux-2.6.12.6/drivers/media/dvb/dvb-core/dmxdev.c	2005-08-29 18:55:27.000000000 +0200
+++ linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/dmxdev.c	2006-04-11 14:31:37.000000000 +0200
@@ -42,12 +42,6 @@
 
 #define dprintk	if (debug) printk
 
-static inline struct dmxdev_filter *
-dvb_dmxdev_file_to_filter(struct file *file)
-{
-	return (struct dmxdev_filter *) file->private_data;
-}
-
 static inline void dvb_dmxdev_buffer_init(struct dmxdev_buffer *buffer)
 {
 	buffer->data=NULL;
@@ -577,7 +571,7 @@
 				return ret;
 			}
 
-			ret=(*secfeed)->set(*secfeed, para->pid, 32768, 0,
+			ret=(*secfeed)->set(*secfeed, para->pid, 32768,
 					    (para->flags & DMX_CHECK_CRC) ? 1 : 0);
 
 			if (ret<0) {
@@ -640,7 +634,7 @@
 
 		ts_pes=(enum dmx_ts_pes) para->pes_type;
 
-		if (ts_pes<DMX_PES_OTHER)
+		if (otype == DMX_OUT_DECODER)
 			ts_type=TS_DECODER;
 		else
 			ts_type=0;
@@ -649,7 +643,11 @@
 			ts_type |= TS_PACKET;
 
 		if (otype == DMX_OUT_TAP)
-			ts_type |= TS_PAYLOAD_ONLY|TS_PACKET;
+		{
+			ts_type |= TS_PACKET;
+			if (ts_pes == DMX_PES_OTHER)
+				ts_type |= TS_PAYLOAD_ONLY;
+		}
 
 		ret=dmxdev->demux->allocate_ts_feed(dmxdev->demux,
 						    tsfeed,
@@ -660,7 +658,7 @@
 		(*tsfeed)->priv = (void *) filter;
 
 		ret = (*tsfeed)->set(*tsfeed, para->pid, ts_type, ts_pes,
-				     188, 32768, 0, timeout);
+				     32768, timeout);
 
 		if (ret < 0) {
 			dmxdev->demux->release_ts_feed(dmxdev->demux, *tsfeed);
@@ -669,8 +667,10 @@
 
 		ret = filter->feed.ts->start_filtering(filter->feed.ts);
 
-		if (ret < 0)
+		if (ret < 0) {
+			dmxdev->demux->release_ts_feed(dmxdev->demux, *tsfeed);
 			return ret;
+		}
 
 		break;
 	}
@@ -842,7 +842,7 @@
 static ssize_t
 dvb_demux_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 {
-	struct dmxdev_filter *dmxdevfilter=dvb_dmxdev_file_to_filter(file);
+	struct dmxdev_filter *dmxdevfilter= file->private_data;
 	int ret=0;
 
 	if (down_interruptible(&dmxdevfilter->mutex))
@@ -863,7 +863,7 @@
 static int dvb_demux_do_ioctl(struct inode *inode, struct file *file,
 			      unsigned int cmd, void *parg)
 {
-	struct dmxdev_filter *dmxdevfilter=dvb_dmxdev_file_to_filter(file);
+	struct dmxdev_filter *dmxdevfilter = file->private_data;
 	struct dmxdev *dmxdev=dmxdevfilter->dev;
 	unsigned long arg=(unsigned long) parg;
 	int ret=0;
@@ -933,6 +933,22 @@
 		dmxdev->demux->get_pes_pids(dmxdev->demux, (u16 *)parg);
 		break;
 
+	case DMX_GET_CAPS:
+		if (!dmxdev->demux->get_caps) {
+			ret = -EINVAL;
+			break;
+		}
+		ret = dmxdev->demux->get_caps(dmxdev->demux, parg);
+		break;
+
+	case DMX_SET_SOURCE:
+		if (!dmxdev->demux->set_source) {
+			ret = -EINVAL;
+			break;
+		}
+		ret = dmxdev->demux->set_source(dmxdev->demux, parg);
+		break;
+
 	case DMX_GET_STC:
 		if (!dmxdev->demux->get_stc) {
 		        ret=-EINVAL;
@@ -960,7 +976,7 @@
 
 static unsigned int dvb_demux_poll (struct file *file, poll_table *wait)
 {
-	struct dmxdev_filter *dmxdevfilter = dvb_dmxdev_file_to_filter(file);
+	struct dmxdev_filter *dmxdevfilter = file->private_data;
 	unsigned int mask = 0;
 
 	if (!dmxdevfilter)
@@ -985,7 +1001,7 @@
 
 static int dvb_demux_release(struct inode *inode, struct file *file)
 {
-	struct dmxdev_filter *dmxdevfilter = dvb_dmxdev_file_to_filter(file);
+	struct dmxdev_filter *dmxdevfilter = file->private_data;
 	struct dmxdev *dmxdev = dmxdevfilter->dev;
 
 	return dvb_dmxdev_filter_free(dmxdev, dmxdevfilter);
@@ -1109,7 +1125,6 @@
 		dvb_dmxdev_filter_state_set(&dmxdev->filter[i], DMXDEV_STATE_FREE);
 		dmxdev->dvr[i].dev=dmxdev;
 		dmxdev->dvr[i].buffer.data=NULL;
-		dvb_dmxdev_filter_state_set(&dmxdev->filter[i], DMXDEV_STATE_FREE);
 		dvb_dmxdev_dvr_state_set(&dmxdev->dvr[i], DMXDEV_STATE_FREE);
 	}
 
diff -Naur linux-2.6.12.6/drivers/media/dvb/dvb-core/dvb_ca_en50221.c linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/dvb_ca_en50221.c
--- linux-2.6.12.6/drivers/media/dvb/dvb-core/dvb_ca_en50221.c	2005-08-29 18:55:27.000000000 +0200
+++ linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/dvb_ca_en50221.c	2006-04-11 14:31:37.000000000 +0200
@@ -35,7 +35,8 @@
 #include <linux/moduleparam.h>
 #include <linux/vmalloc.h>
 #include <linux/delay.h>
-#include <linux/rwsem.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
 
 #include "dvb_ca_en50221.h"
 #include "dvb_ringbuffer.h"
@@ -47,7 +48,7 @@
 
 #define dprintk if (dvb_ca_en50221_debug) printk
 
-#define INIT_TIMEOUT_SECS 5
+#define INIT_TIMEOUT_SECS 10
 
 #define HOST_LINK_BUF_SIZE 0x200
 
@@ -110,9 +111,6 @@
 	/* size of the buffer to use when talking to the CAM */
 	int link_buf_size;
 
-	/* semaphore for syncing access to slot structure */
-	struct rw_semaphore sem;
-
 	/* buffer for incoming packets */
 	struct dvb_ringbuffer rx_buffer;
 
@@ -601,14 +599,11 @@
 	if (ebuf == NULL) {
 		int buf_free;
 
-		down_read(&ca->slot_info[slot].sem);
 		if (ca->slot_info[slot].rx_buffer.data == NULL) {
-			up_read(&ca->slot_info[slot].sem);
 			status = -EIO;
 			goto exit;
 		}
 		buf_free = dvb_ringbuffer_free(&ca->slot_info[slot].rx_buffer);
-		up_read(&ca->slot_info[slot].sem);
 
 		if (buf_free < (ca->slot_info[slot].link_buf_size + DVB_RINGBUFFER_PKTHDRSIZE)) {
 			status = -EAGAIN;
@@ -679,14 +674,11 @@
 
 	/* OK, add it to the receive buffer, or copy into external buffer if supplied */
 	if (ebuf == NULL) {
-		down_read(&ca->slot_info[slot].sem);
 		if (ca->slot_info[slot].rx_buffer.data == NULL) {
-			up_read(&ca->slot_info[slot].sem);
 			status = -EIO;
 			goto exit;
 		}
 		dvb_ringbuffer_pkt_write(&ca->slot_info[slot].rx_buffer, buf, bytes_read);
-		up_read(&ca->slot_info[slot].sem);
 	} else {
 		memcpy(ebuf, buf, bytes_read);
 	}
@@ -801,12 +793,8 @@
 {
 	dprintk("%s\n", __FUNCTION__);
 
-	down_write(&ca->slot_info[slot].sem);
 	ca->pub->slot_shutdown(ca->pub, slot);
 	ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_NONE;
-	vfree(ca->slot_info[slot].rx_buffer.data);
-	ca->slot_info[slot].rx_buffer.data = NULL;
-	up_write(&ca->slot_info[slot].sem);
 
 	/* need to wake up all processes to check if they're now
 	   trying to write to a defunct CAM */
@@ -892,7 +880,7 @@
 
 	case DVB_CA_SLOTSTATE_RUNNING:
 		if (ca->open)
-			dvb_ca_en50221_read_data(ca, slot, NULL, 0);
+			dvb_ca_en50221_thread_wakeup(ca);
 		break;
 	}
 }
@@ -1126,16 +1114,16 @@
 					break;
 				}
 
-				rxbuf = vmalloc(RX_BUFFER_SIZE);
-				if (rxbuf == NULL) {
-					printk("dvb_ca adapter %d: Unable to allocate CAM rx buffer :(\n", ca->dvbdev->adapter->num);
-					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
-					dvb_ca_en50221_thread_update_delay(ca);
-					break;
+				if (ca->slot_info[slot].rx_buffer.data == NULL) {
+					rxbuf = vmalloc(RX_BUFFER_SIZE);
+					if (rxbuf == NULL) {
+						printk("dvb_ca adapter %d: Unable to allocate CAM rx buffer :(\n", ca->dvbdev->adapter->num);
+						ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
+						dvb_ca_en50221_thread_update_delay(ca);
+						break;
+					}
+					dvb_ringbuffer_init(&ca->slot_info[slot].rx_buffer, rxbuf, RX_BUFFER_SIZE);
 				}
-				down_write(&ca->slot_info[slot].sem);
-				dvb_ringbuffer_init(&ca->slot_info[slot].rx_buffer, rxbuf, RX_BUFFER_SIZE);
-				up_write(&ca->slot_info[slot].sem);
 
 				ca->pub->slot_ts_enable(ca->pub, slot);
 				ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_RUNNING;
@@ -1147,11 +1135,7 @@
 				if (!ca->open)
 					continue;
 
-				// no need to poll if the CAM supports IRQs
-				if (ca->slot_info[slot].da_irq_supported)
-					break;
-
-				// poll mode
+				// poll slots for data
 				pktcount = 0;
 				while ((status = dvb_ca_en50221_read_data(ca, slot, NULL, 0)) > 0) {
 					if (!ca->open)
@@ -1366,12 +1350,13 @@
 /**
  * Condition for waking up in dvb_ca_en50221_io_read_condition
  */
-static int dvb_ca_en50221_io_read_condition(struct dvb_ca_private *ca, int *result, int *_slot)
+static int dvb_ca_en50221_io_read_condition(struct dvb_ca_private *ca,
+					    int *result, int *_slot)
 {
 	int slot;
 	int slot_count = 0;
 	int idx;
-	int fraglen;
+	size_t fraglen;
 	int connection_id = -1;
 	int found = 0;
 	u8 hdr[2];
@@ -1381,10 +1366,7 @@
 		if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING)
 			goto nextslot;
 
-		down_read(&ca->slot_info[slot].sem);
-
 		if (ca->slot_info[slot].rx_buffer.data == NULL) {
-			up_read(&ca->slot_info[slot].sem);
 			return 0;
 		}
 
@@ -1402,10 +1384,7 @@
 			idx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, idx, &fraglen);
 		}
 
-		if (!found)
-			up_read(&ca->slot_info[slot].sem);
-
-	      nextslot:
+nextslot:
 		slot = (slot + 1) % ca->slot_count;
 		slot_count++;
 	}
@@ -1510,8 +1489,7 @@
 		goto exit;
 	status = pktlen;
 
-      exit:
-	up_read(&ca->slot_info[slot].sem);
+exit:
 	return status;
 }
 
@@ -1543,11 +1521,11 @@
 	for (i = 0; i < ca->slot_count; i++) {
 
 		if (ca->slot_info[i].slot_state == DVB_CA_SLOTSTATE_RUNNING) {
-			down_write(&ca->slot_info[i].sem);
 			if (ca->slot_info[i].rx_buffer.data != NULL) {
+				/* it is safe to call this here without locks because
+				 * ca->open == 0. Data is not read in this case */
 				dvb_ringbuffer_flush(&ca->slot_info[i].rx_buffer);
 			}
-			up_write(&ca->slot_info[i].sem);
 		}
 	}
 
@@ -1606,7 +1584,6 @@
 	dprintk("%s\n", __FUNCTION__);
 
 	if (dvb_ca_en50221_io_read_condition(ca, &result, &slot) == 1) {
-		up_read(&ca->slot_info[slot].sem);
 		mask |= POLLIN;
 	}
 
@@ -1618,7 +1595,6 @@
 	poll_wait(file, &ca->wait_queue, wait);
 
 	if (dvb_ca_en50221_io_read_condition(ca, &result, &slot) == 1) {
-		up_read(&ca->slot_info[slot].sem);
 		mask |= POLLIN;
 	}
 
@@ -1708,7 +1684,6 @@
 		ca->slot_info[i].slot_state = DVB_CA_SLOTSTATE_NONE;
 		atomic_set(&ca->slot_info[i].camchange_count, 0);
 		ca->slot_info[i].camchange_type = DVB_CA_EN50221_CAMCHANGE_REMOVED;
-		init_rwsem(&ca->slot_info[i].sem);
 	}
 
 	if (signal_pending(current)) {
@@ -1728,7 +1703,7 @@
 	ca->thread_pid = ret;
 	return 0;
 
-      error:
+error:
 	if (ca != NULL) {
 		if (ca->dvbdev != NULL)
 			dvb_unregister_device(ca->dvbdev);
@@ -1770,6 +1745,9 @@
 
 	for (i = 0; i < ca->slot_count; i++) {
 		dvb_ca_en50221_slot_shutdown(ca, i);
+		if (ca->slot_info[i].rx_buffer.data != NULL) {
+			vfree(ca->slot_info[i].rx_buffer.data);
+		}
 	}
 	kfree(ca->slot_info);
 	dvb_unregister_device(ca->dvbdev);
diff -Naur linux-2.6.12.6/drivers/media/dvb/dvb-core/dvb_demux.c linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/dvb_demux.c
--- linux-2.6.12.6/drivers/media/dvb/dvb-core/dvb_demux.c	2005-08-29 18:55:27.000000000 +0200
+++ linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/dvb_demux.c	2006-04-11 14:31:37.000000000 +0200
@@ -38,82 +38,52 @@
 */
 // #define DVB_DEMUX_SECTION_LOSS_LOG
 
-
-static LIST_HEAD(dmx_muxs);
-
-
-static int dmx_register_demux(struct dmx_demux *demux)
-{
-	demux->users = 0;
-	list_add(&demux->reg_list, &dmx_muxs);
-	return 0;
-}
-
-static int dmx_unregister_demux(struct dmx_demux* demux)
-{
-	struct list_head *pos, *n, *head=&dmx_muxs;
-
-	list_for_each_safe (pos, n, head) {
-		if (DMX_DIR_ENTRY(pos) == demux) {
-			if (demux->users>0)
-				return -EINVAL;
-			list_del(pos);
-			return 0;
-		}
-	}
-
-	return -ENODEV;
-}
-
-
 /******************************************************************************
  * static inlined helper functions
  ******************************************************************************/
 
-
 static inline u16 section_length(const u8 *buf)
 {
-	return 3+((buf[1]&0x0f)<<8)+buf[2];
+	return 3 + ((buf[1] & 0x0f) << 8) + buf[2];
 }
 
-
 static inline u16 ts_pid(const u8 *buf)
 {
-	return ((buf[1]&0x1f)<<8)+buf[2];
+	return ((buf[1] & 0x1f) << 8) + buf[2];
 }
 
-
 static inline u8 payload(const u8 *tsp)
 {
-	if (!(tsp[3] & 0x10)) // no payload?
+	if (!(tsp[3] & 0x10))	// no payload?
 		return 0;
-	if (tsp[3] & 0x20) {  // adaptation field?
-		if (tsp[4] > 183)    // corrupted data?
+
+	if (tsp[3] & 0x20) {	// adaptation field?
+		if (tsp[4] > 183)	// corrupted data?
 			return 0;
 		else
-			return 184-1-tsp[4];
+			return 184 - 1 - tsp[4];
 	}
+
 	return 184;
 }
 
-
-static u32 dvb_dmx_crc32 (struct dvb_demux_feed *f, const u8 *src, size_t len)
+static u32 dvb_dmx_crc32(struct dvb_demux_feed *f, const u8 *src, size_t len)
 {
-	return (f->feed.sec.crc_val = crc32_be (f->feed.sec.crc_val, src, len));
+	return (f->feed.sec.crc_val = crc32_be(f->feed.sec.crc_val, src, len));
 }
 
-
-static void dvb_dmx_memcopy (struct dvb_demux_feed *f, u8 *d, const u8 *s, size_t len)
+static void dvb_dmx_memcopy(struct dvb_demux_feed *f, u8 *d, const u8 *s,
+			    size_t len)
 {
-	memcpy (d, s, len);
+	memcpy(d, s, len);
 }
 
-
 /******************************************************************************
  * Software filter functions
  ******************************************************************************/
 
-static inline int dvb_dmx_swfilter_payload (struct dvb_demux_feed *feed, const u8 *buf)
+static inline int dvb_dmx_swfilter_payload(struct dvb_demux_feed *feed,
+					   const u8 *buf)
 {
 	int count = payload(buf);
 	int p;
@@ -123,32 +93,31 @@
 	if (count == 0)
 		return -1;
 
-	p = 188-count;
+	p = 188 - count;
 
 	/*
-	cc=buf[3]&0x0f;
-	ccok=((dvbdmxfeed->cc+1)&0x0f)==cc ? 1 : 0;
-	dvbdmxfeed->cc=cc;
+	cc = buf[3] & 0x0f;
+	ccok = ((feed->cc + 1) & 0x0f) == cc;
+	feed->cc = cc;
 	if (!ccok)
 		printk("missed packet!\n");
 	*/
 
-	if (buf[1] & 0x40)  // PUSI ?
+	if (buf[1] & 0x40)	// PUSI ?
 		feed->peslen = 0xfffa;
 
 	feed->peslen += count;
 
-	return feed->cb.ts (&buf[p], count, NULL, 0, &feed->feed.ts, DMX_OK);
+	return feed->cb.ts(&buf[p], count, NULL, 0, &feed->feed.ts, DMX_OK);
 }
 
-
-static int dvb_dmx_swfilter_sectionfilter (struct dvb_demux_feed *feed,
-				    struct dvb_demux_filter *f)
+static int dvb_dmx_swfilter_sectionfilter(struct dvb_demux_feed *feed,
+					  struct dvb_demux_filter *f)
 {
 	u8 neq = 0;
 	int i;
 
-	for (i=0; i<DVB_DEMUX_MASK_MAX; i++) {
+	for (i = 0; i < DVB_DEMUX_MASK_MAX; i++) {
 		u8 xor = f->filter.filter_value[i] ^ feed->feed.sec.secbuf[i];
 
 		if (f->maskandmode[i] & xor)
@@ -160,12 +129,11 @@
 	if (f->doneq && !neq)
 		return 0;
 
-	return feed->cb.sec (feed->feed.sec.secbuf, feed->feed.sec.seclen,
-			     NULL, 0, &f->filter, DMX_OK);
+	return feed->cb.sec(feed->feed.sec.secbuf, feed->feed.sec.seclen,
+			    NULL, 0, &f->filter, DMX_OK);
 }
 
-
-static inline int dvb_dmx_swfilter_section_feed (struct dvb_demux_feed *feed)
+static inline int dvb_dmx_swfilter_section_feed(struct dvb_demux_feed *feed)
 {
 	struct dvb_demux *demux = feed->demux;
 	struct dvb_demux_filter *f = feed->filter;
@@ -195,26 +163,24 @@
 	return 0;
 }
 
-
 static void dvb_dmx_swfilter_section_new(struct dvb_demux_feed *feed)
 {
 	struct dmx_section_feed *sec = &feed->feed.sec;
 
 #ifdef DVB_DEMUX_SECTION_LOSS_LOG
-	if(sec->secbufp < sec->tsfeedp)
-	{
+	if (sec->secbufp < sec->tsfeedp) {
 		int i, n = sec->tsfeedp - sec->secbufp;
 
-		/* section padding is done with 0xff bytes entirely.
-		** due to speed reasons, we won't check all of them
-		** but just first and last
-		*/
-		if(sec->secbuf[0] != 0xff || sec->secbuf[n-1] != 0xff)
-		{
+		/*
+		 * Section padding is done with 0xff bytes entirely.
+		 * Due to speed reasons, we won't check all of them
+		 * but just first and last.
+		 */
+		if (sec->secbuf[0] != 0xff || sec->secbuf[n - 1] != 0xff) {
 			printk("dvb_demux.c section ts padding loss: %d/%d\n",
 			       n, sec->tsfeedp);
 			printk("dvb_demux.c pad data:");
-			for(i = 0; i < n; i++)
+			for (i = 0; i < n; i++)
 				printk(" %02x", sec->secbuf[i]);
 			printk("\n");
 		}
@@ -226,82 +192,81 @@
 }
 
 /*
-** Losless Section Demux 1.4.1 by Emard
-** Valsecchi Patrick:
-**  - middle of section A  (no PUSI)
-**  - end of section A and start of section B
-**    (with PUSI pointing to the start of the second section)
-**
-**  In this case, without feed->pusi_seen you'll receive a garbage section
-**  consisting of the end of section A. Basically because tsfeedp
-**  is incemented and the use=0 condition is not raised
-**  when the second packet arrives.
-**
-** Fix:
-** when demux is started, let feed->pusi_seen = 0 to
-** prevent initial feeding of garbage from the end of
-** previous section. When you for the first time see PUSI=1
-** then set feed->pusi_seen = 1
-*/
-static int dvb_dmx_swfilter_section_copy_dump(struct dvb_demux_feed *feed, const u8 *buf, u8 len)
+ * Losless Section Demux 1.4.1 by Emard
+ * Valsecchi Patrick:
+ *  - middle of section A  (no PUSI)
+ *  - end of section A and start of section B
+ *    (with PUSI pointing to the start of the second section)
+ *
+ *  In this case, without feed->pusi_seen you'll receive a garbage section
+ *  consisting of the end of section A. Basically because tsfeedp
+ *  is incemented and the use=0 condition is not raised
+ *  when the second packet arrives.
+ *
+ * Fix:
+ * when demux is started, let feed->pusi_seen = 0 to
+ * prevent initial feeding of garbage from the end of
+ * previous section. When you for the first time see PUSI=1
+ * then set feed->pusi_seen = 1
+ */
+static int dvb_dmx_swfilter_section_copy_dump(struct dvb_demux_feed *feed,
+					      const u8 *buf, u8 len)
 {
 	struct dvb_demux *demux = feed->demux;
 	struct dmx_section_feed *sec = &feed->feed.sec;
 	u16 limit, seclen, n;
 
-	if(sec->tsfeedp >= DMX_MAX_SECFEED_SIZE)
+	if (sec->tsfeedp >= DMX_MAX_SECFEED_SIZE)
 		return 0;
 
-	if(sec->tsfeedp + len > DMX_MAX_SECFEED_SIZE)
-	{
+	if (sec->tsfeedp + len > DMX_MAX_SECFEED_SIZE) {
 #ifdef DVB_DEMUX_SECTION_LOSS_LOG
 		printk("dvb_demux.c section buffer full loss: %d/%d\n",
-		       sec->tsfeedp + len - DMX_MAX_SECFEED_SIZE, DMX_MAX_SECFEED_SIZE);
+		       sec->tsfeedp + len - DMX_MAX_SECFEED_SIZE,
+		       DMX_MAX_SECFEED_SIZE);
 #endif
 		len = DMX_MAX_SECFEED_SIZE - sec->tsfeedp;
 	}
 
-	if(len <= 0)
+	if (len <= 0)
 		return 0;
 
 	demux->memcopy(feed, sec->secbuf_base + sec->tsfeedp, buf, len);
 	sec->tsfeedp += len;
 
-	/* -----------------------------------------------------
-	** Dump all the sections we can find in the data (Emard)
-	*/
-
+	/*
+	 * Dump all the sections we can find in the data (Emard)
+	 */
 	limit = sec->tsfeedp;
-	if(limit > DMX_MAX_SECFEED_SIZE)
-		return -1; /* internal error should never happen */
+	if (limit > DMX_MAX_SECFEED_SIZE)
+		return -1;	/* internal error should never happen */
 
 	/* to be sure always set secbuf */
 	sec->secbuf = sec->secbuf_base + sec->secbufp;
 
-	for(n = 0; sec->secbufp + 2 < limit; n++)
-	{
+	for (n = 0; sec->secbufp + 2 < limit; n++) {
 		seclen = section_length(sec->secbuf);
-		if(seclen <= 0 || seclen > DMX_MAX_SECFEED_SIZE
-		   || seclen + sec->secbufp > limit)
+		if (seclen <= 0 || seclen > DMX_MAX_SECTION_SIZE
+		    || seclen + sec->secbufp > limit)
 			return 0;
 		sec->seclen = seclen;
 		sec->crc_val = ~0;
 		/* dump [secbuf .. secbuf+seclen) */
-		if(feed->pusi_seen)
+		if (feed->pusi_seen)
 			dvb_dmx_swfilter_section_feed(feed);
 #ifdef DVB_DEMUX_SECTION_LOSS_LOG
 		else
 			printk("dvb_demux.c pusi not seen, discarding section data\n");
 #endif
-		sec->secbufp += seclen; /* secbufp and secbuf moving together is */
-		sec->secbuf += seclen; /* redundand but saves pointer arithmetic */
+		sec->secbufp += seclen;	/* secbufp and secbuf moving together is */
+		sec->secbuf += seclen;	/* redundant but saves pointer arithmetic */
 	}
 
 	return 0;
 }
 
-
-static int dvb_dmx_swfilter_section_packet(struct dvb_demux_feed *feed, const u8 *buf)
+static int dvb_dmx_swfilter_section_packet(struct dvb_demux_feed *feed,
+					   const u8 *buf)
 {
 	u8 p, count;
 	int ccok, dc_i = 0;
@@ -309,10 +274,10 @@
 
 	count = payload(buf);
 
-	if (count == 0)  /* count == 0 if no payload or out of range */
+	if (count == 0)		/* count == 0 if no payload or out of range */
 		return -1;
 
-	p = 188 - count; /* payload start */
+	p = 188 - count;	/* payload start */
 
 	cc = buf[3] & 0x0f;
 	ccok = ((feed->cc + 1) & 0x0f) == cc;
@@ -326,52 +291,53 @@
 
 	if (!ccok || dc_i) {
 #ifdef DVB_DEMUX_SECTION_LOSS_LOG
-		printk("dvb_demux.c discontinuity detected %d bytes lost\n", count);
-		/* those bytes under sume circumstances will again be reported
-		** in the following dvb_dmx_swfilter_section_new
-		*/
+		printk("dvb_demux.c discontinuity detected %d bytes lost\n",
+		       count);
+		/*
+		 * those bytes under sume circumstances will again be reported
+		 * in the following dvb_dmx_swfilter_section_new
+		 */
 #endif
-		/* Discontinuity detected. Reset pusi_seen = 0 to
-		** stop feeding of suspicious data until next PUSI=1 arrives
-		*/
+		/*
+		 * Discontinuity detected. Reset pusi_seen = 0 to
+		 * stop feeding of suspicious data until next PUSI=1 arrives
+		 */
 		feed->pusi_seen = 0;
 		dvb_dmx_swfilter_section_new(feed);
-		return 0;
 	}
 
 	if (buf[1] & 0x40) {
-		// PUSI=1 (is set), section boundary is here
+		/* PUSI=1 (is set), section boundary is here */
 		if (count > 1 && buf[p] < count) {
-			const u8 *before = buf+p+1;
+			const u8 *before = &buf[p + 1];
 			u8 before_len = buf[p];
-			const u8 *after = before+before_len;
-			u8 after_len = count-1-before_len;
+			const u8 *after = &before[before_len];
+			u8 after_len = count - 1 - before_len;
 
-			dvb_dmx_swfilter_section_copy_dump(feed, before, before_len);
+			dvb_dmx_swfilter_section_copy_dump(feed, before,
+							   before_len);
 			/* before start of new section, set pusi_seen = 1 */
 			feed->pusi_seen = 1;
 			dvb_dmx_swfilter_section_new(feed);
-			dvb_dmx_swfilter_section_copy_dump(feed, after, after_len);
+			dvb_dmx_swfilter_section_copy_dump(feed, after,
+							   after_len);
 		}
 #ifdef DVB_DEMUX_SECTION_LOSS_LOG
-		else
-			if (count > 0)
-				printk("dvb_demux.c PUSI=1 but %d bytes lost\n", count);
+		else if (count > 0)
+			printk("dvb_demux.c PUSI=1 but %d bytes lost\n", count);
 #endif
 	} else {
-		// PUSI=0 (is not set), no section boundary
-		const u8 *entire = buf+p;
-		u8 entire_len = count;
-
-		dvb_dmx_swfilter_section_copy_dump(feed, entire, entire_len);
+		/* PUSI=0 (is not set), no section boundary */
+		dvb_dmx_swfilter_section_copy_dump(feed, &buf[p], count);
 	}
+
 	return 0;
 }
 
-
-static inline void dvb_dmx_swfilter_packet_type(struct dvb_demux_feed *feed, const u8 *buf)
+static inline void dvb_dmx_swfilter_packet_type(struct dvb_demux_feed *feed,
+						const u8 *buf)
 {
-	switch(feed->type) {
+	switch (feed->type) {
 	case DMX_TYPE_TS:
 		if (!feed->feed.ts.is_filtering)
 			break;
@@ -379,7 +345,8 @@
 			if (feed->ts_type & TS_PAYLOAD_ONLY)
 				dvb_dmx_swfilter_payload(feed, buf);
 			else
-				feed->cb.ts(buf, 188, NULL, 0, &feed->feed.ts, DMX_OK);
+				feed->cb.ts(buf, 188, NULL, 0, &feed->feed.ts,
+					    DMX_OK);
 		}
 		if (feed->ts_type & TS_DECODER)
 			if (feed->demux->write_to_decoder)
@@ -390,7 +357,7 @@
 		if (!feed->feed.sec.is_filtering)
 			break;
 		if (dvb_dmx_swfilter_section_packet(feed, buf) < 0)
-			feed->feed.sec.seclen = feed->feed.sec.secbufp=0;
+			feed->feed.sec.seclen = feed->feed.sec.secbufp = 0;
 		break;
 
 	default:
@@ -406,7 +373,7 @@
 static void dvb_dmx_swfilter_packet(struct dvb_demux *demux, const u8 *buf)
 {
 	struct dvb_demux_feed *feed;
-	struct list_head *pos, *head=&demux->feed_list;
+	struct list_head *pos, *head = &demux->feed_list;
 	u16 pid = ts_pid(buf);
 	int dvr_done = 0;
 
@@ -432,21 +399,21 @@
 	}
 }
 
-void dvb_dmx_swfilter_packets(struct dvb_demux *demux, const u8 *buf, size_t count)
+void dvb_dmx_swfilter_packets(struct dvb_demux *demux, const u8 *buf,
+			      size_t count)
 {
 	spin_lock(&demux->lock);
 
 	while (count--) {
-		if(buf[0] == 0x47) {
-		        dvb_dmx_swfilter_packet(demux, buf);
-		}
+		if (buf[0] == 0x47)
+			dvb_dmx_swfilter_packet(demux, buf);
 		buf += 188;
 	}
 
 	spin_unlock(&demux->lock);
 }
-EXPORT_SYMBOL(dvb_dmx_swfilter_packets);
 
+EXPORT_SYMBOL(dvb_dmx_swfilter_packets);
 
 void dvb_dmx_swfilter(struct dvb_demux *demux, const u8 *buf, size_t count)
 {
@@ -454,8 +421,10 @@
 
 	spin_lock(&demux->lock);
 
-	if ((i = demux->tsbufp)) {
-		if (count < (j=188-i)) {
+	if (demux->tsbufp) {
+		i = demux->tsbufp;
+		j = 188 - i;
+		if (count < j) {
 			memcpy(&demux->tsbuf[i], buf, count);
 			demux->tsbufp += count;
 			goto bailout;
@@ -469,13 +438,13 @@
 
 	while (p < count) {
 		if (buf[p] == 0x47) {
-			if (count-p >= 188) {
-				dvb_dmx_swfilter_packet(demux, buf+p);
+			if (count - p >= 188) {
+				dvb_dmx_swfilter_packet(demux, &buf[p]);
 				p += 188;
 			} else {
-				i = count-p;
-				memcpy(demux->tsbuf, buf+p, i);
-				demux->tsbufp=i;
+				i = count - p;
+				memcpy(demux->tsbuf, &buf[p], i);
+				demux->tsbufp = i;
 				goto bailout;
 			}
 		} else
@@ -485,24 +454,29 @@
 bailout:
 	spin_unlock(&demux->lock);
 }
+
 EXPORT_SYMBOL(dvb_dmx_swfilter);
 
 void dvb_dmx_swfilter_204(struct dvb_demux *demux, const u8 *buf, size_t count)
 {
-	int p = 0,i, j;
+	int p = 0, i, j;
 	u8 tmppack[188];
+
 	spin_lock(&demux->lock);
 
-	if ((i = demux->tsbufp)) {
-		if (count < (j=204-i)) {
+	if (demux->tsbufp) {
+		i = demux->tsbufp;
+		j = 204 - i;
+		if (count < j) {
 			memcpy(&demux->tsbuf[i], buf, count);
 			demux->tsbufp += count;
 			goto bailout;
 		}
 		memcpy(&demux->tsbuf[i], buf, j);
-		if ((demux->tsbuf[0] == 0x47)|(demux->tsbuf[0]==0xB8))  {
+		if ((demux->tsbuf[0] == 0x47) | (demux->tsbuf[0] == 0xB8)) {
 			memcpy(tmppack, demux->tsbuf, 188);
-			if (tmppack[0] == 0xB8) tmppack[0] = 0x47;
+			if (tmppack[0] == 0xB8)
+				tmppack[0] = 0x47;
 			dvb_dmx_swfilter_packet(demux, tmppack);
 		}
 		demux->tsbufp = 0;
@@ -510,16 +484,17 @@
 	}
 
 	while (p < count) {
-		if ((buf[p] == 0x47)|(buf[p] == 0xB8)) {
-			if (count-p >= 204) {
-				memcpy(tmppack, buf+p, 188);
-				if (tmppack[0] == 0xB8) tmppack[0] = 0x47;
+		if ((buf[p] == 0x47) | (buf[p] == 0xB8)) {
+			if (count - p >= 204) {
+				memcpy(tmppack, &buf[p], 188);
+				if (tmppack[0] == 0xB8)
+					tmppack[0] = 0x47;
 				dvb_dmx_swfilter_packet(demux, tmppack);
 				p += 204;
 			} else {
-				i = count-p;
-				memcpy(demux->tsbuf, buf+p, i);
-				demux->tsbufp=i;
+				i = count - p;
+				memcpy(demux->tsbuf, &buf[p], i);
+				demux->tsbufp = i;
 				goto bailout;
 			}
 		} else {
@@ -530,14 +505,14 @@
 bailout:
 	spin_unlock(&demux->lock);
 }
-EXPORT_SYMBOL(dvb_dmx_swfilter_204);
 
+EXPORT_SYMBOL(dvb_dmx_swfilter_204);
 
-static struct dvb_demux_filter * dvb_dmx_filter_alloc(struct dvb_demux *demux)
+static struct dvb_demux_filter *dvb_dmx_filter_alloc(struct dvb_demux *demux)
 {
 	int i;
 
-	for (i=0; i<demux->filternum; i++)
+	for (i = 0; i < demux->filternum; i++)
 		if (demux->filter[i].state == DMX_STATE_FREE)
 			break;
 
@@ -549,11 +524,11 @@
 	return &demux->filter[i];
 }
 
-static struct dvb_demux_feed * dvb_dmx_feed_alloc(struct dvb_demux *demux)
+static struct dvb_demux_feed *dvb_dmx_feed_alloc(struct dvb_demux *demux)
 {
 	int i;
 
-	for (i=0; i<demux->feednum; i++)
+	for (i = 0; i < demux->feednum; i++)
 		if (demux->feed[i].state == DMX_STATE_FREE)
 			break;
 
@@ -581,7 +556,7 @@
 	spin_lock_irq(&feed->demux->lock);
 	if (dvb_demux_feed_find(feed)) {
 		printk(KERN_ERR "%s: feed already in list (type=%x state=%x pid=%x)\n",
-				__FUNCTION__, feed->type, feed->state, feed->pid);
+		       __FUNCTION__, feed->type, feed->state, feed->pid);
 		goto out;
 	}
 
@@ -595,7 +570,7 @@
 	spin_lock_irq(&feed->demux->lock);
 	if (!(dvb_demux_feed_find(feed))) {
 		printk(KERN_ERR "%s: feed not in list (type=%x state=%x pid=%x)\n",
-				__FUNCTION__, feed->type, feed->state, feed->pid);
+		       __FUNCTION__, feed->type, feed->state, feed->pid);
 		goto out;
 	}
 
@@ -604,18 +579,17 @@
 	spin_unlock_irq(&feed->demux->lock);
 }
 
-static int dmx_ts_feed_set (struct dmx_ts_feed* ts_feed, u16 pid, int ts_type,
-		     enum dmx_ts_pes pes_type, size_t callback_length,
-		     size_t circular_buffer_size, int descramble,
-		     struct timespec timeout)
+static int dmx_ts_feed_set(struct dmx_ts_feed *ts_feed, u16 pid, int ts_type,
+			   enum dmx_ts_pes pes_type,
+			   size_t circular_buffer_size, struct timespec timeout)
 {
-	struct dvb_demux_feed *feed = (struct dvb_demux_feed *) ts_feed;
+	struct dvb_demux_feed *feed = (struct dvb_demux_feed *)ts_feed;
 	struct dvb_demux *demux = feed->demux;
 
 	if (pid > DMX_MAX_PID)
 		return -EINVAL;
 
-	if (down_interruptible (&demux->mutex))
+	if (down_interruptible(&demux->mutex))
 		return -ERESTARTSYS;
 
 	if (ts_type & TS_DECODER) {
@@ -638,20 +612,13 @@
 
 	feed->pid = pid;
 	feed->buffer_size = circular_buffer_size;
-	feed->descramble = descramble;
 	feed->timeout = timeout;
-	feed->cb_length = callback_length;
 	feed->ts_type = ts_type;
 	feed->pes_type = pes_type;
 
-	if (feed->descramble) {
-		up(&demux->mutex);
-		return -ENOSYS;
-	}
-
 	if (feed->buffer_size) {
 #ifdef NOBUFS
-		feed->buffer=NULL;
+		feed->buffer = NULL;
 #else
 		feed->buffer = vmalloc(feed->buffer_size);
 		if (!feed->buffer) {
@@ -667,14 +634,13 @@
 	return 0;
 }
 
-
-static int dmx_ts_feed_start_filtering(struct dmx_ts_feed* ts_feed)
+static int dmx_ts_feed_start_filtering(struct dmx_ts_feed *ts_feed)
 {
-	struct dvb_demux_feed *feed = (struct dvb_demux_feed *) ts_feed;
+	struct dvb_demux_feed *feed = (struct dvb_demux_feed *)ts_feed;
 	struct dvb_demux *demux = feed->demux;
 	int ret;
 
-	if (down_interruptible (&demux->mutex))
+	if (down_interruptible(&demux->mutex))
 		return -ERESTARTSYS;
 
 	if (feed->state != DMX_STATE_READY || feed->type != DMX_TYPE_TS) {
@@ -701,13 +667,13 @@
 	return 0;
 }
 
-static int dmx_ts_feed_stop_filtering(struct dmx_ts_feed* ts_feed)
+static int dmx_ts_feed_stop_filtering(struct dmx_ts_feed *ts_feed)
 {
-	struct dvb_demux_feed *feed = (struct dvb_demux_feed *) ts_feed;
+	struct dvb_demux_feed *feed = (struct dvb_demux_feed *)ts_feed;
 	struct dvb_demux *demux = feed->demux;
 	int ret;
 
-	if (down_interruptible (&demux->mutex))
+	if (down_interruptible(&demux->mutex))
 		return -ERESTARTSYS;
 
 	if (feed->state < DMX_STATE_GO) {
@@ -731,13 +697,14 @@
 	return ret;
 }
 
-static int dvbdmx_allocate_ts_feed (struct dmx_demux *dmx, struct dmx_ts_feed **ts_feed,
-			     dmx_ts_cb callback)
+static int dvbdmx_allocate_ts_feed(struct dmx_demux *dmx,
+				   struct dmx_ts_feed **ts_feed,
+				   dmx_ts_cb callback)
 {
-	struct dvb_demux *demux = (struct dvb_demux *) dmx;
+	struct dvb_demux *demux = (struct dvb_demux *)dmx;
 	struct dvb_demux_feed *feed;
 
-	if (down_interruptible (&demux->mutex))
+	if (down_interruptible(&demux->mutex))
 		return -ERESTARTSYS;
 
 	if (!(feed = dvb_dmx_feed_alloc(demux))) {
@@ -760,7 +727,6 @@
 	(*ts_feed)->stop_filtering = dmx_ts_feed_stop_filtering;
 	(*ts_feed)->set = dmx_ts_feed_set;
 
-
 	if (!(feed->filter = dvb_dmx_filter_alloc(demux))) {
 		feed->state = DMX_STATE_FREE;
 		up(&demux->mutex);
@@ -776,22 +742,22 @@
 	return 0;
 }
 
-static int dvbdmx_release_ts_feed(struct dmx_demux *dmx, struct dmx_ts_feed *ts_feed)
+static int dvbdmx_release_ts_feed(struct dmx_demux *dmx,
+				  struct dmx_ts_feed *ts_feed)
 {
-	struct dvb_demux *demux = (struct dvb_demux *) dmx;
-	struct dvb_demux_feed *feed = (struct dvb_demux_feed *) ts_feed;
+	struct dvb_demux *demux = (struct dvb_demux *)dmx;
+	struct dvb_demux_feed *feed = (struct dvb_demux_feed *)ts_feed;
 
-	if (down_interruptible (&demux->mutex))
+	if (down_interruptible(&demux->mutex))
 		return -ERESTARTSYS;
 
 	if (feed->state == DMX_STATE_FREE) {
 		up(&demux->mutex);
 		return -EINVAL;
 	}
-
 #ifndef NOBUFS
 	vfree(feed->buffer);
-	feed->buffer=0;
+	feed->buffer = NULL;
 #endif
 
 	feed->state = DMX_STATE_FREE;
@@ -808,19 +774,18 @@
 	return 0;
 }
 
-
 /******************************************************************************
  * dmx_section_feed API calls
  ******************************************************************************/
 
-static int dmx_section_feed_allocate_filter(struct dmx_section_feed* feed,
-				     struct dmx_section_filter** filter)
+static int dmx_section_feed_allocate_filter(struct dmx_section_feed *feed,
+					    struct dmx_section_filter **filter)
 {
-	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *) feed;
+	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;
 	struct dvb_demux *dvbdemux = dvbdmxfeed->demux;
 	struct dvb_demux_filter *dvbdmxfilter;
 
-	if (down_interruptible (&dvbdemux->mutex))
+	if (down_interruptible(&dvbdemux->mutex))
 		return -ERESTARTSYS;
 
 	dvbdmxfilter = dvb_dmx_filter_alloc(dvbdemux);
@@ -844,36 +809,29 @@
 	return 0;
 }
 
-
-static int dmx_section_feed_set(struct dmx_section_feed* feed,
-			 u16 pid, size_t circular_buffer_size,
-			 int descramble, int check_crc)
+static int dmx_section_feed_set(struct dmx_section_feed *feed,
+				u16 pid, size_t circular_buffer_size,
+				int check_crc)
 {
-	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *) feed;
+	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;
 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 
 	if (pid > 0x1fff)
 		return -EINVAL;
 
-	if (down_interruptible (&dvbdmx->mutex))
+	if (down_interruptible(&dvbdmx->mutex))
 		return -ERESTARTSYS;
 
 	dvb_demux_feed_add(dvbdmxfeed);
 
 	dvbdmxfeed->pid = pid;
 	dvbdmxfeed->buffer_size = circular_buffer_size;
-	dvbdmxfeed->descramble = descramble;
-	if (dvbdmxfeed->descramble) {
-		up(&dvbdmx->mutex);
-		return -ENOSYS;
-	}
-
 	dvbdmxfeed->feed.sec.check_crc = check_crc;
 
 #ifdef NOBUFS
 	dvbdmxfeed->buffer = NULL;
 #else
-	dvbdmxfeed->buffer=vmalloc(dvbdmxfeed->buffer_size);
+	dvbdmxfeed->buffer = vmalloc(dvbdmxfeed->buffer_size);
 	if (!dvbdmxfeed->buffer) {
 		up(&dvbdmx->mutex);
 		return -ENOMEM;
@@ -885,7 +843,6 @@
 	return 0;
 }
 
-
 static void prepare_secfilters(struct dvb_demux_feed *dvbdmxfeed)
 {
 	int i;
@@ -893,12 +850,12 @@
 	struct dmx_section_filter *sf;
 	u8 mask, mode, doneq;
 
-	if (!(f=dvbdmxfeed->filter))
+	if (!(f = dvbdmxfeed->filter))
 		return;
 	do {
 		sf = &f->filter;
 		doneq = 0;
-		for (i=0; i<DVB_DEMUX_MASK_MAX; i++) {
+		for (i = 0; i < DVB_DEMUX_MASK_MAX; i++) {
 			mode = sf->filter_mode[i];
 			mask = sf->filter_mask[i];
 			f->maskandmode[i] = mask & mode;
@@ -908,14 +865,13 @@
 	} while ((f = f->next));
 }
 
-
 static int dmx_section_feed_start_filtering(struct dmx_section_feed *feed)
 {
-	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *) feed;
+	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;
 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 	int ret;
 
-	if (down_interruptible (&dvbdmx->mutex))
+	if (down_interruptible(&dvbdmx->mutex))
 		return -ERESTARTSYS;
 
 	if (feed->is_filtering) {
@@ -954,14 +910,13 @@
 	return 0;
 }
 
-
-static int dmx_section_feed_stop_filtering(struct dmx_section_feed* feed)
+static int dmx_section_feed_stop_filtering(struct dmx_section_feed *feed)
 {
-	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *) feed;
+	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;
 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 	int ret;
 
-	if (down_interruptible (&dvbdmx->mutex))
+	if (down_interruptible(&dvbdmx->mutex))
 		return -ERESTARTSYS;
 
 	if (!dvbdmx->stop_feed) {
@@ -980,15 +935,14 @@
 	return ret;
 }
 
-
 static int dmx_section_feed_release_filter(struct dmx_section_feed *feed,
-				struct dmx_section_filter* filter)
+					   struct dmx_section_filter *filter)
 {
-	struct dvb_demux_filter *dvbdmxfilter = (struct dvb_demux_filter *) filter, *f;
-	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *) feed;
+	struct dvb_demux_filter *dvbdmxfilter = (struct dvb_demux_filter *)filter, *f;
+	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;
 	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
 
-	if (down_interruptible (&dvbdmx->mutex))
+	if (down_interruptible(&dvbdmx->mutex))
 		return -ERESTARTSYS;
 
 	if (dvbdmxfilter->feed != dvbdmxfeed) {
@@ -1005,7 +959,7 @@
 	if (f == dvbdmxfilter) {
 		dvbdmxfeed->filter = dvbdmxfilter->next;
 	} else {
-		while(f->next != dvbdmxfilter)
+		while (f->next != dvbdmxfilter)
 			f = f->next;
 		f->next = f->next->next;
 	}
@@ -1020,10 +974,10 @@
 					struct dmx_section_feed **feed,
 					dmx_section_cb callback)
 {
-	struct dvb_demux *dvbdmx = (struct dvb_demux *) demux;
+	struct dvb_demux *dvbdmx = (struct dvb_demux *)demux;
 	struct dvb_demux_feed *dvbdmxfeed;
 
-	if (down_interruptible (&dvbdmx->mutex))
+	if (down_interruptible(&dvbdmx->mutex))
 		return -ERESTARTSYS;
 
 	if (!(dvbdmxfeed = dvb_dmx_feed_alloc(dvbdmx))) {
@@ -1041,7 +995,7 @@
 	dvbdmxfeed->filter = NULL;
 	dvbdmxfeed->buffer = NULL;
 
-	(*feed)=&dvbdmxfeed->feed.sec;
+	(*feed) = &dvbdmxfeed->feed.sec;
 	(*feed)->is_filtering = 0;
 	(*feed)->parent = demux;
 	(*feed)->priv = NULL;
@@ -1059,21 +1013,21 @@
 static int dvbdmx_release_section_feed(struct dmx_demux *demux,
 				       struct dmx_section_feed *feed)
 {
-	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *) feed;
-	struct dvb_demux *dvbdmx = (struct dvb_demux *) demux;
+	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;
+	struct dvb_demux *dvbdmx = (struct dvb_demux *)demux;
 
-	if (down_interruptible (&dvbdmx->mutex))
+	if (down_interruptible(&dvbdmx->mutex))
 		return -ERESTARTSYS;
 
-	if (dvbdmxfeed->state==DMX_STATE_FREE) {
+	if (dvbdmxfeed->state == DMX_STATE_FREE) {
 		up(&dvbdmx->mutex);
 		return -EINVAL;
 	}
 #ifndef NOBUFS
 	vfree(dvbdmxfeed->buffer);
-	dvbdmxfeed->buffer=0;
+	dvbdmxfeed->buffer = NULL;
 #endif
-	dvbdmxfeed->state=DMX_STATE_FREE;
+	dvbdmxfeed->state = DMX_STATE_FREE;
 
 	dvb_demux_feed_del(dvbdmxfeed);
 
@@ -1083,14 +1037,13 @@
 	return 0;
 }
 
-
 /******************************************************************************
  * dvb_demux kernel data API calls
  ******************************************************************************/
 
 static int dvbdmx_open(struct dmx_demux *demux)
 {
-	struct dvb_demux *dvbdemux = (struct dvb_demux *) demux;
+	struct dvb_demux *dvbdemux = (struct dvb_demux *)demux;
 
 	if (dvbdemux->users >= MAX_DVB_DEMUX_USERS)
 		return -EUSERS;
@@ -1099,10 +1052,9 @@
 	return 0;
 }
 
-
 static int dvbdmx_close(struct dmx_demux *demux)
 {
-	struct dvb_demux *dvbdemux = (struct dvb_demux *) demux;
+	struct dvb_demux *dvbdemux = (struct dvb_demux *)demux;
 
 	if (dvbdemux->users == 0)
 		return -ENODEV;
@@ -1112,15 +1064,14 @@
 	return 0;
 }
 
-
 static int dvbdmx_write(struct dmx_demux *demux, const char *buf, size_t count)
 {
-	struct dvb_demux *dvbdemux=(struct dvb_demux *) demux;
+	struct dvb_demux *dvbdemux = (struct dvb_demux *)demux;
 
 	if ((!demux->frontend) || (demux->frontend->source != DMX_MEMORY_FE))
 		return -EINVAL;
 
-	if (down_interruptible (&dvbdemux->mutex))
+	if (down_interruptible(&dvbdemux->mutex))
 		return -ERESTARTSYS;
 	dvb_dmx_swfilter(dvbdemux, buf, count);
 	up(&dvbdemux->mutex);
@@ -1130,10 +1081,10 @@
 	return count;
 }
 
-
-static int dvbdmx_add_frontend(struct dmx_demux *demux, struct dmx_frontend *frontend)
+static int dvbdmx_add_frontend(struct dmx_demux *demux,
+			       struct dmx_frontend *frontend)
 {
-	struct dvb_demux *dvbdemux = (struct dvb_demux *) demux;
+	struct dvb_demux *dvbdemux = (struct dvb_demux *)demux;
 	struct list_head *head = &dvbdemux->frontend_list;
 
 	list_add(&(frontend->connectivity_list), head);
@@ -1141,13 +1092,13 @@
 	return 0;
 }
 
-
-static int dvbdmx_remove_frontend(struct dmx_demux *demux, struct dmx_frontend *frontend)
+static int dvbdmx_remove_frontend(struct dmx_demux *demux,
+				  struct dmx_frontend *frontend)
 {
-	struct dvb_demux *dvbdemux = (struct dvb_demux *) demux;
+	struct dvb_demux *dvbdemux = (struct dvb_demux *)demux;
 	struct list_head *pos, *n, *head = &dvbdemux->frontend_list;
 
-	list_for_each_safe (pos, n, head) {
+	list_for_each_safe(pos, n, head) {
 		if (DMX_FE_ENTRY(pos) == frontend) {
 			list_del(pos);
 			return 0;
@@ -1157,25 +1108,25 @@
 	return -ENODEV;
 }
 
-
-static struct list_head * dvbdmx_get_frontends(struct dmx_demux *demux)
+static struct list_head *dvbdmx_get_frontends(struct dmx_demux *demux)
 {
-	struct dvb_demux *dvbdemux = (struct dvb_demux *) demux;
+	struct dvb_demux *dvbdemux = (struct dvb_demux *)demux;
 
 	if (list_empty(&dvbdemux->frontend_list))
 		return NULL;
+
 	return &dvbdemux->frontend_list;
 }
 
-
-static int dvbdmx_connect_frontend(struct dmx_demux *demux, struct dmx_frontend *frontend)
+static int dvbdmx_connect_frontend(struct dmx_demux *demux,
+				   struct dmx_frontend *frontend)
 {
-	struct dvb_demux *dvbdemux = (struct dvb_demux *) demux;
+	struct dvb_demux *dvbdemux = (struct dvb_demux *)demux;
 
 	if (demux->frontend)
 		return -EINVAL;
 
-	if (down_interruptible (&dvbdemux->mutex))
+	if (down_interruptible(&dvbdemux->mutex))
 		return -ERESTARTSYS;
 
 	demux->frontend = frontend;
@@ -1183,12 +1134,11 @@
 	return 0;
 }
 
-
 static int dvbdmx_disconnect_frontend(struct dmx_demux *demux)
 {
-	struct dvb_demux *dvbdemux = (struct dvb_demux *) demux;
+	struct dvb_demux *dvbdemux = (struct dvb_demux *)demux;
 
-	if (down_interruptible (&dvbdemux->mutex))
+	if (down_interruptible(&dvbdemux->mutex))
 		return -ERESTARTSYS;
 
 	demux->frontend = NULL;
@@ -1196,44 +1146,42 @@
 	return 0;
 }
 
-
-static int dvbdmx_get_pes_pids(struct dmx_demux *demux, u16 *pids)
+static int dvbdmx_get_pes_pids(struct dmx_demux *demux, u16 * pids)
 {
-	struct dvb_demux *dvbdemux = (struct dvb_demux *) demux;
+	struct dvb_demux *dvbdemux = (struct dvb_demux *)demux;
 
-	memcpy(pids, dvbdemux->pids, 5*sizeof(u16));
+	memcpy(pids, dvbdemux->pids, 5 * sizeof(u16));
 	return 0;
 }
 
-
 int dvb_dmx_init(struct dvb_demux *dvbdemux)
 {
-	int i, err;
+	int i;
 	struct dmx_demux *dmx = &dvbdemux->dmx;
 
 	dvbdemux->users = 0;
-	dvbdemux->filter = vmalloc(dvbdemux->filternum*sizeof(struct dvb_demux_filter));
+	dvbdemux->filter = vmalloc(dvbdemux->filternum * sizeof(struct dvb_demux_filter));
 
 	if (!dvbdemux->filter)
 		return -ENOMEM;
 
-	dvbdemux->feed = vmalloc(dvbdemux->feednum*sizeof(struct dvb_demux_feed));
+	dvbdemux->feed = vmalloc(dvbdemux->feednum * sizeof(struct dvb_demux_feed));
 	if (!dvbdemux->feed) {
 		vfree(dvbdemux->filter);
 		return -ENOMEM;
 	}
-	for (i=0; i<dvbdemux->filternum; i++) {
+	for (i = 0; i < dvbdemux->filternum; i++) {
 		dvbdemux->filter[i].state = DMX_STATE_FREE;
 		dvbdemux->filter[i].index = i;
 	}
-	for (i=0; i<dvbdemux->feednum; i++) {
+	for (i = 0; i < dvbdemux->feednum; i++) {
 		dvbdemux->feed[i].state = DMX_STATE_FREE;
 		dvbdemux->feed[i].index = i;
 	}
-	dvbdemux->frontend_list.next=
-	  dvbdemux->frontend_list.prev=
-	    &dvbdemux->frontend_list;
-	for (i=0; i<DMX_TS_PES_OTHER; i++) {
+
+	INIT_LIST_HEAD(&dvbdemux->frontend_list);
+
+	for (i = 0; i < DMX_TS_PES_OTHER; i++) {
 		dvbdemux->pesfilter[i] = NULL;
 		dvbdemux->pids[i] = 0xffff;
 	}
@@ -1247,12 +1195,11 @@
 	if (!dvbdemux->check_crc32)
 		dvbdemux->check_crc32 = dvb_dmx_crc32;
 
-	 if (!dvbdemux->memcopy)
-		 dvbdemux->memcopy = dvb_dmx_memcopy;
+	if (!dvbdemux->memcopy)
+		dvbdemux->memcopy = dvb_dmx_memcopy;
 
 	dmx->frontend = NULL;
-	dmx->reg_list.prev = dmx->reg_list.next = &dmx->reg_list;
-	dmx->priv = (void *) dvbdemux;
+	dmx->priv = dvbdemux;
 	dmx->open = dvbdmx_open;
 	dmx->close = dvbdmx_close;
 	dmx->write = dvbdmx_write;
@@ -1261,9 +1208,6 @@
 	dmx->allocate_section_feed = dvbdmx_allocate_section_feed;
 	dmx->release_section_feed = dvbdmx_release_section_feed;
 
-	dmx->descramble_mac_address = NULL;
-	dmx->descramble_section_payload = NULL;
-
 	dmx->add_frontend = dvbdmx_add_frontend;
 	dmx->remove_frontend = dvbdmx_remove_frontend;
 	dmx->get_frontends = dvbdmx_get_frontends;
@@ -1274,21 +1218,15 @@
 	sema_init(&dvbdemux->mutex, 1);
 	spin_lock_init(&dvbdemux->lock);
 
-	if ((err = dmx_register_demux(dmx)) < 0)
-		return err;
-
 	return 0;
 }
-EXPORT_SYMBOL(dvb_dmx_init);
 
+EXPORT_SYMBOL(dvb_dmx_init);
 
-int dvb_dmx_release(struct dvb_demux *dvbdemux)
+void dvb_dmx_release(struct dvb_demux *dvbdemux)
 {
-	struct dmx_demux *dmx = &dvbdemux->dmx;
-
-	dmx_unregister_demux(dmx);
 	vfree(dvbdemux->filter);
 	vfree(dvbdemux->feed);
-	return 0;
 }
+
 EXPORT_SYMBOL(dvb_dmx_release);
diff -Naur linux-2.6.12.6/drivers/media/dvb/dvb-core/dvb_demux.h linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/dvb_demux.h
--- linux-2.6.12.6/drivers/media/dvb/dvb-core/dvb_demux.h	2005-08-29 18:55:27.000000000 +0200
+++ linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/dvb_demux.h	2006-04-11 14:31:37.000000000 +0200
@@ -20,7 +20,6 @@
  *
  */
 
-
 #ifndef _DVB_DEMUX_H_
 #define _DVB_DEMUX_H_
 
@@ -44,103 +43,98 @@
 #define DVB_DEMUX_MASK_MAX 18
 
 struct dvb_demux_filter {
-        struct dmx_section_filter filter;
-        u8 maskandmode    [DMX_MAX_FILTER_SIZE];
-        u8 maskandnotmode [DMX_MAX_FILTER_SIZE];
+	struct dmx_section_filter filter;
+	u8 maskandmode[DMX_MAX_FILTER_SIZE];
+	u8 maskandnotmode[DMX_MAX_FILTER_SIZE];
 	int doneq;
 
-        struct dvb_demux_filter *next;
-        struct dvb_demux_feed *feed;
-        int index;
-        int state;
-        int type;
-	int pesto;
-
-        u16 handle;
-        u16 hw_handle;
-        struct timer_list timer;
-	int ts_state;
-};
+	struct dvb_demux_filter *next;
+	struct dvb_demux_feed *feed;
+	int index;
+	int state;
+	int type;
 
+	u16 hw_handle;
+	struct timer_list timer;
+};
 
 #define DMX_FEED_ENTRY(pos) list_entry(pos, struct dvb_demux_feed, list_head)
 
 struct dvb_demux_feed {
-        union {
-	        struct dmx_ts_feed ts;
-	        struct dmx_section_feed sec;
+	union {
+		struct dmx_ts_feed ts;
+		struct dmx_section_feed sec;
 	} feed;
 
-        union {
-	        dmx_ts_cb ts;
-	        dmx_section_cb sec;
+	union {
+		dmx_ts_cb ts;
+		dmx_section_cb sec;
 	} cb;
 
-        struct dvb_demux *demux;
+	struct dvb_demux *demux;
 	void *priv;
-        int type;
-        int state;
-        u16 pid;
-        u8 *buffer;
-        int buffer_size;
-        int descramble;
-
-        struct timespec timeout;
-        struct dvb_demux_filter *filter;
-        int cb_length;
+	int type;
+	int state;
+	u16 pid;
+	u8 *buffer;
+	int buffer_size;
+
+	struct timespec timeout;
+	struct dvb_demux_filter *filter;
 
-        int ts_type;
-        enum dmx_ts_pes pes_type;
+	int ts_type;
+	enum dmx_ts_pes pes_type;
 
-        int cc;
-        int pusi_seen; /* prevents feeding of garbage from previous section */
+	int cc;
+	int pusi_seen;		/* prevents feeding of garbage from previous section */
 
-        u16 peslen;
+	u16 peslen;
 
 	struct list_head list_head;
-		int index; /* a unique index for each feed (can be used as hardware pid filter index) */
+	unsigned int index;	/* a unique index for each feed (can be used as hardware pid filter index) */
 };
 
 struct dvb_demux {
-        struct dmx_demux dmx;
-        void *priv;
-        int filternum;
-        int feednum;
-        int (*start_feed) (struct dvb_demux_feed *feed);
-        int (*stop_feed) (struct dvb_demux_feed *feed);
-        int (*write_to_decoder) (struct dvb_demux_feed *feed,
+	struct dmx_demux dmx;
+	void *priv;
+	int filternum;
+	int feednum;
+	int (*start_feed)(struct dvb_demux_feed *feed);
+	int (*stop_feed)(struct dvb_demux_feed *feed);
+	int (*write_to_decoder)(struct dvb_demux_feed *feed,
 				 const u8 *buf, size_t len);
-	u32 (*check_crc32) (struct dvb_demux_feed *feed,
+	u32 (*check_crc32)(struct dvb_demux_feed *feed,
 			    const u8 *buf, size_t len);
-	void (*memcopy) (struct dvb_demux_feed *feed, u8 *dst,
+	void (*memcopy)(struct dvb_demux_feed *feed, u8 *dst,
 			 const u8 *src, size_t len);
 
-        int users;
+	int users;
 #define MAX_DVB_DEMUX_USERS 10
-        struct dvb_demux_filter *filter;
-        struct dvb_demux_feed *feed;
+	struct dvb_demux_filter *filter;
+	struct dvb_demux_feed *feed;
 
-        struct list_head frontend_list;
+	struct list_head frontend_list;
 
-        struct dvb_demux_feed *pesfilter[DMX_TS_PES_OTHER];
-        u16 pids[DMX_TS_PES_OTHER];
-        int playing;
-        int recording;
+	struct dvb_demux_feed *pesfilter[DMX_TS_PES_OTHER];
+	u16 pids[DMX_TS_PES_OTHER];
+	int playing;
+	int recording;
 
 #define DMX_MAX_PID 0x2000
 	struct list_head feed_list;
-        u8 tsbuf[204];
-        int tsbufp;
+	u8 tsbuf[204];
+	int tsbufp;
 
 	struct semaphore mutex;
 	spinlock_t lock;
 };
 
-
 int dvb_dmx_init(struct dvb_demux *dvbdemux);
-int dvb_dmx_release(struct dvb_demux *dvbdemux);
-void dvb_dmx_swfilter_packets(struct dvb_demux *dvbdmx, const u8 *buf, size_t count);
+void dvb_dmx_release(struct dvb_demux *dvbdemux);
+void dvb_dmx_swfilter_packets(struct dvb_demux *dvbdmx, const u8 *buf,
+			      size_t count);
 void dvb_dmx_swfilter(struct dvb_demux *demux, const u8 *buf, size_t count);
-void dvb_dmx_swfilter_204(struct dvb_demux *demux, const u8 *buf, size_t count);
+void dvb_dmx_swfilter_204(struct dvb_demux *demux, const u8 *buf,
+			  size_t count);
 
 #endif /* _DVB_DEMUX_H_ */
diff -Naur linux-2.6.12.6/drivers/media/dvb/dvb-core/dvbdev.c linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/dvbdev.c
--- linux-2.6.12.6/drivers/media/dvb/dvb-core/dvbdev.c	2005-08-29 18:55:27.000000000 +0200
+++ linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/dvbdev.c	2006-04-11 14:31:37.000000000 +0200
@@ -56,8 +56,7 @@
 #define nums2minor(num,type,id)	((num << 6) | (id << 4) | type)
 #define MAX_DVB_MINORS		(DVB_MAX_ADAPTERS*64)
 
-struct class_simple *dvb_class;
-EXPORT_SYMBOL(dvb_class);
+static struct class *dvb_class;
 
 static struct dvb_device* dvbdev_find_device (int minor)
 {
@@ -236,8 +235,8 @@
 			S_IFCHR | S_IRUSR | S_IWUSR,
 			"dvb/adapter%d/%s%d", adap->num, dnames[type], id);
 
-	class_simple_device_add(dvb_class, MKDEV(DVB_MAJOR, nums2minor(adap->num, type, id)),
-				NULL, "dvb%d.%s%d", adap->num, dnames[type], id);
+	class_device_create(dvb_class, NULL, MKDEV(DVB_MAJOR, nums2minor(adap->num, type, id)),
+			    NULL, "dvb%d.%s%d", adap->num, dnames[type], id);
 
 	dprintk("DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\n",
 		adap->num, dnames[type], id, nums2minor(adap->num, type, id),
@@ -256,7 +255,7 @@
 	devfs_remove("dvb/adapter%d/%s%d", dvbdev->adapter->num,
 			dnames[dvbdev->type], dvbdev->id);
 
-	class_simple_device_remove(MKDEV(DVB_MAJOR, nums2minor(dvbdev->adapter->num,
+	class_device_destroy(dvb_class, MKDEV(DVB_MAJOR, nums2minor(dvbdev->adapter->num,
 					dvbdev->type, dvbdev->id)));
 
 	list_del (&dvbdev->list_head);
@@ -412,7 +411,7 @@
 
 	devfs_mk_dir("dvb");
 
-	dvb_class = class_simple_create(THIS_MODULE, "dvb");
+	dvb_class = class_create(THIS_MODULE, "dvb");
 	if (IS_ERR(dvb_class)) {
 		retval = PTR_ERR(dvb_class);
 		goto error;
@@ -429,7 +428,7 @@
 static void __exit exit_dvbdev(void)
 {
         devfs_remove("dvb");
-	class_simple_destroy(dvb_class);
+	class_destroy(dvb_class);
 	cdev_del(&dvb_device_cdev);
         unregister_chrdev_region(MKDEV(DVB_MAJOR, 0), MAX_DVB_MINORS);
 }
diff -Naur linux-2.6.12.6/drivers/media/dvb/dvb-core/dvbdev.h linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/dvbdev.h
--- linux-2.6.12.6/drivers/media/dvb/dvb-core/dvbdev.h	2005-08-29 18:55:27.000000000 +0200
+++ linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/dvbdev.h	2006-04-11 14:31:37.000000000 +0200
@@ -29,6 +29,7 @@
 #include <linux/list.h>
 #include <linux/devfs_fs_kernel.h>
 #include <linux/smp_lock.h>
+#include "compat.h"
 
 #define DVB_MAJOR 212
 
diff -Naur linux-2.6.12.6/drivers/media/dvb/dvb-core/dvb_frontend.c linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/dvb_frontend.c
--- linux-2.6.12.6/drivers/media/dvb/dvb-core/dvb_frontend.c	2005-08-29 18:55:27.000000000 +0200
+++ linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/dvb_frontend.c	2006-04-11 14:31:37.000000000 +0200
@@ -35,6 +35,7 @@
 #include <linux/moduleparam.h>
 #include <linux/list.h>
 #include <linux/suspend.h>
+#include <linux/jiffies.h>
 #include <asm/processor.h>
 #include <asm/semaphore.h>
 
@@ -112,6 +113,7 @@
 	int exit;
 	int wakeup;
 	fe_status_t status;
+	fe_sec_tone_mode_t tone;
 };
 
 
@@ -327,7 +329,8 @@
 		return 1;
 
 	if (fepriv->dvbdev->writers == 1)
-		if (jiffies - fepriv->release_jiffies > dvb_shutdown_timeout * HZ)
+		if (time_after(jiffies, fepriv->release_jiffies +
+					dvb_shutdown_timeout * HZ))
 			return 1;
 
 	return 0;
@@ -389,8 +392,7 @@
 			break;
 		}
 
-		if (current->flags & PF_FREEZE)
-			refrigerator(PF_FREEZE);
+		try_to_freeze();
 
 		if (down_interruptible(&fepriv->sem))
 			break;
@@ -433,9 +435,7 @@
 			/* we're tuned, and the lock is still good... */
 			if (s & FE_HAS_LOCK)
 				continue;
-			else {
-				/* if we _WERE_ tuned, but now don't have a lock,
-				 * need to zigzag */
+			else { /* if we _WERE_ tuned, but now don't have a lock */
 				fepriv->state = FESTATE_ZIGZAG_FAST;
 				fepriv->started_auto_step = fepriv->auto_step;
 				check_wrapped = 0;
@@ -556,6 +556,49 @@
 				fepriv->thread_pid);
 }
 
+s32 timeval_usec_diff(struct timeval lasttime, struct timeval curtime)
+{
+	return ((curtime.tv_usec < lasttime.tv_usec) ?
+		1000000 - lasttime.tv_usec + curtime.tv_usec :
+		curtime.tv_usec - lasttime.tv_usec);
+}
+EXPORT_SYMBOL(timeval_usec_diff);
+
+static inline void timeval_usec_add(struct timeval *curtime, u32 add_usec)
+{
+	curtime->tv_usec += add_usec;
+	if (curtime->tv_usec >= 1000000) {
+		curtime->tv_usec -= 1000000;
+		curtime->tv_sec++;
+	}
+}
+
+/*
+ * Sleep until gettimeofday() > waketime + add_usec
+ * This needs to be as precise as possible, but as the delay is
+ * usually between 2ms and 32ms, it is done using a scheduled msleep
+ * followed by usleep (normally a busy-wait loop) for the remainder
+ */
+void dvb_frontend_sleep_until(struct timeval *waketime, u32 add_usec)
+{
+	struct timeval lasttime;
+	s32 delta, newdelta;
+
+	timeval_usec_add(waketime, add_usec);
+
+	do_gettimeofday(&lasttime);
+	delta = timeval_usec_diff(lasttime, *waketime);
+	if (delta > 2500) {
+		msleep((delta - 1500) / 1000);
+		do_gettimeofday(&lasttime);
+		newdelta = timeval_usec_diff(lasttime, *waketime);
+		delta = (newdelta > delta) ? 0 : newdelta;
+	}
+	if (delta > 0)
+		udelay(delta);
+}
+EXPORT_SYMBOL(dvb_frontend_sleep_until);
+
 static int dvb_frontend_start(struct dvb_frontend *fe)
 {
 	int ret;
@@ -625,11 +668,21 @@
 		break;
 	}
 
-	case FE_READ_STATUS:
+	case FE_READ_STATUS: {
+		fe_status_t* status = parg;
+
+		/* if retune was requested but hasn't occured yet, prevent
+		 * that user get signal state from previous tuning */
+		if(fepriv->state == FESTATE_RETUNE) {
+			err=0;
+			*status = 0;
+			break;
+		}
+
 		if (fe->ops->read_status)
-			err = fe->ops->read_status(fe, (fe_status_t*) parg);
+			err = fe->ops->read_status(fe, status);
 		break;
-
+	}
 	case FE_READ_BER:
 		if (fe->ops->read_ber)
 			err = fe->ops->read_ber(fe, (__u32*) parg);
@@ -680,6 +733,7 @@
 			err = fe->ops->set_tone(fe, (fe_sec_tone_mode_t) parg);
 			fepriv->state = FESTATE_DISEQC;
 			fepriv->status = 0;
+			fepriv->tone = (fe_sec_tone_mode_t) parg;
 		}
 		break;
 
@@ -696,6 +750,60 @@
 			err = fe->ops->dishnetwork_send_legacy_command(fe, (unsigned int) parg);
 			fepriv->state = FESTATE_DISEQC;
 			fepriv->status = 0;
+		} else if (fe->ops->set_voltage) {
+			/*
+			 * NOTE: This is a fallback condition.  Some frontends
+			 * (stv0299 for instance) take longer than 8msec to
+			 * respond to a set_voltage command.  Those switches
+			 * need custom routines to switch properly.  For all
+			 * other frontends, the following shoule work ok.
+			 * Dish network legacy switches (as used by Dish500)
+			 * are controlled by sending 9-bit command words
+			 * spaced 8msec apart.
+			 * the actual command word is switch/port dependant
+			 * so it is up to the userspace application to send
+			 * the right command.
+			 * The command must always start with a '0' after
+			 * initialization, so parg is 8 bits and does not
+			 * include the initialization or start bit
+			 */
+			unsigned int cmd = ((unsigned int) parg) << 1;
+			struct timeval nexttime;
+			struct timeval tv[10];
+			int i;
+			u8 last = 1;
+			if (dvb_frontend_debug)
+				printk("%s switch command: 0x%04x\n", __FUNCTION__, cmd);
+			do_gettimeofday(&nexttime);
+			if (dvb_frontend_debug)
+				memcpy(&tv[0], &nexttime, sizeof(struct timeval));
+			/* before sending a command, initialize by sending
+			 * a 32ms 18V to the switch
+			 */
+			fe->ops->set_voltage(fe, SEC_VOLTAGE_18);
+			dvb_frontend_sleep_until(&nexttime, 32000);
+
+			for (i = 0; i < 9; i++) {
+				if (dvb_frontend_debug)
+					do_gettimeofday(&tv[i + 1]);
+				if ((cmd & 0x01) != last) {
+					/* set voltage to (last ? 13V : 18V) */
+					fe->ops->set_voltage(fe, (last) ? SEC_VOLTAGE_13 : SEC_VOLTAGE_18);
+					last = (last) ? 0 : 1;
+				}
+				cmd = cmd >> 1;
+				if (i != 8)
+					dvb_frontend_sleep_until(&nexttime, 8000);
+			}
+			if (dvb_frontend_debug) {
+				printk("%s(%d): switch delay (should be 32k followed by all 8k\n",
+					__FUNCTION__, fe->dvb->num);
+				for (i = 1; i < 10; i++)
+					printk("%d: %d\n", i, timeval_usec_diff(tv[i-1] , tv[i]));
+			}
+			err = 0;
+			fepriv->state = FESTATE_DISEQC;
+			fepriv->status = 0;
 		}
 		break;
 
@@ -882,6 +990,7 @@
 	init_MUTEX (&fepriv->events.sem);
 	fe->dvb = dvb;
 	fepriv->inversion = INVERSION_OFF;
+	fepriv->tone = SEC_TONE_OFF;
 
 	printk ("DVB: registering frontend %i (%s)...\n",
 		fe->dvb->num,
diff -Naur linux-2.6.12.6/drivers/media/dvb/dvb-core/dvb_frontend.h linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/dvb_frontend.h
--- linux-2.6.12.6/drivers/media/dvb/dvb-core/dvb_frontend.h	2005-08-29 18:55:27.000000000 +0200
+++ linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/dvb_frontend.h	2006-04-11 14:31:37.000000000 +0200
@@ -40,28 +40,6 @@
 
 #include "dvbdev.h"
 
-/* FIXME: Move to i2c-id.h */
-#define I2C_DRIVERID_DVBFE_SP8870	I2C_DRIVERID_EXP2
-#define I2C_DRIVERID_DVBFE_CX22700	I2C_DRIVERID_EXP2
-#define I2C_DRIVERID_DVBFE_AT76C651	I2C_DRIVERID_EXP2
-#define I2C_DRIVERID_DVBFE_CX24110	I2C_DRIVERID_EXP2
-#define I2C_DRIVERID_DVBFE_CX22702	I2C_DRIVERID_EXP2
-#define I2C_DRIVERID_DVBFE_DIB3000MB	I2C_DRIVERID_EXP2
-#define I2C_DRIVERID_DVBFE_DST		I2C_DRIVERID_EXP2
-#define I2C_DRIVERID_DVBFE_DUMMY	I2C_DRIVERID_EXP2
-#define I2C_DRIVERID_DVBFE_L64781	I2C_DRIVERID_EXP2
-#define I2C_DRIVERID_DVBFE_MT312	I2C_DRIVERID_EXP2
-#define I2C_DRIVERID_DVBFE_MT352	I2C_DRIVERID_EXP2
-#define I2C_DRIVERID_DVBFE_NXT6000	I2C_DRIVERID_EXP2
-#define I2C_DRIVERID_DVBFE_SP887X	I2C_DRIVERID_EXP2
-#define I2C_DRIVERID_DVBFE_STV0299	I2C_DRIVERID_EXP2
-#define I2C_DRIVERID_DVBFE_TDA1004X	I2C_DRIVERID_EXP2
-#define I2C_DRIVERID_DVBFE_TDA8083	I2C_DRIVERID_EXP2
-#define I2C_DRIVERID_DVBFE_VES1820	I2C_DRIVERID_EXP2
-#define I2C_DRIVERID_DVBFE_VES1X93	I2C_DRIVERID_EXP2
-#define I2C_DRIVERID_DVBFE_TDA80XX	I2C_DRIVERID_EXP2
-
-
 struct dvb_frontend_tune_settings {
         int min_delay_ms;
         int step_size;
@@ -123,4 +101,7 @@
 
 extern int dvb_unregister_frontend(struct dvb_frontend* fe);
 
+extern void dvb_frontend_sleep_until(struct timeval *waketime, u32 add_usec);
+extern s32 timeval_usec_diff(struct timeval lasttime, struct timeval curtime);
+
 #endif
diff -Naur linux-2.6.12.6/drivers/media/dvb/dvb-core/dvb_net.c linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/dvb_net.c
--- linux-2.6.12.6/drivers/media/dvb/dvb-core/dvb_net.c	2005-08-29 18:55:27.000000000 +0200
+++ linux-2.6.12.6-patched/drivers/media/dvb/dvb-core/dvb_net.c	2006-04-11 14:31:37.000000000 +0200
@@ -62,7 +62,6 @@
 #include <linux/uio.h>
 #include <asm/uaccess.h>
 #include <linux/crc32.h>
-#include <linux/version.h>
 
 #include "dvb_demux.h"
 #include "dvb_net.h"
@@ -171,11 +170,7 @@
 
 	skb->mac.raw=skb->data;
 	skb_pull(skb,dev->hard_header_len);
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,8)
-	eth = skb->mac.ethernet;
-#else
 	eth = eth_hdr(skb);
-#endif
 
 	if (*eth->h_dest & 1) {
 		if(memcmp(eth->h_dest,dev->broadcast, ETH_ALEN)==0)
@@ -908,7 +903,7 @@
 			return ret;
 		}
 
-		ret = priv->secfeed->set(priv->secfeed, priv->pid, 32768, 0, 1);
+		ret = priv->secfeed->set(priv->secfeed, priv->pid, 32768, 1);
 
 		if (ret<0) {
 			printk("%s: could not set section feed\n", dev->name);
@@ -960,9 +955,7 @@
 		priv->tsfeed->priv = (void *)dev;
 		ret = priv->tsfeed->set(priv->tsfeed, priv->pid,
 					TS_PACKET, DMX_TS_PES_OTHER,
-					188 * 100, /* nr. of bytes delivered per callback */
 					32768,     /* circular buffer size */
-					0,         /* descramble */
 					timeout);
 
 		if (ret < 0) {
diff -Naur linux-2.6.12.6/drivers/media/dvb/frontends/stv0299.c linux-2.6.12.6-patched/drivers/media/dvb/frontends/stv0299.c
--- linux-2.6.12.6/drivers/media/dvb/frontends/stv0299.c	2005-08-29 18:55:27.000000000 +0200
+++ linux-2.6.12.6-patched/drivers/media/dvb/frontends/stv0299.c	2006-04-11 14:31:37.000000000 +0200
@@ -48,6 +48,7 @@
 #include <linux/moduleparam.h>
 #include <linux/string.h>
 #include <linux/slab.h>
+#include <linux/jiffies.h>
 #include <asm/div64.h>
 
 #include "dvb_frontend.h"
@@ -386,36 +387,6 @@
 	};
 }
 
-static inline s32 stv0299_calc_usec_delay (struct timeval lasttime, struct timeval curtime)
-{
-	return ((curtime.tv_usec < lasttime.tv_usec) ?
-		1000000 - lasttime.tv_usec + curtime.tv_usec :
-		curtime.tv_usec - lasttime.tv_usec);
-}
-
-static void stv0299_sleep_until (struct timeval *waketime, u32 add_usec)
-{
-	struct timeval lasttime;
-	s32 delta, newdelta;
-
-	waketime->tv_usec += add_usec;
-	if (waketime->tv_usec >= 1000000) {
-		waketime->tv_usec -= 1000000;
-		waketime->tv_sec++;
-	}
-
-	do_gettimeofday (&lasttime);
-	delta = stv0299_calc_usec_delay (lasttime, *waketime);
-	if (delta > 2500) {
-		msleep ((delta - 1500) / 1000);
-		do_gettimeofday (&lasttime);
-		newdelta = stv0299_calc_usec_delay (lasttime, *waketime);
-		delta = (newdelta > delta) ? 0 : newdelta;
-	}
-	if (delta > 0)
-		udelay (delta);
-}
-
 static int stv0299_send_legacy_dish_cmd (struct dvb_frontend* fe, u32 cmd)
 {
 	struct stv0299_state* state = fe->demodulator_priv;
@@ -443,7 +414,7 @@
 		memcpy (&tv[0], &nexttime, sizeof (struct timeval));
 	stv0299_writeregI (state, 0x0c, reg0x0c | 0x50); /* set LNB to 18V */
 
-	stv0299_sleep_until (&nexttime, 32000);
+	dvb_frontend_sleep_until(&nexttime, 32000);
 
 	for (i=0; i<9; i++) {
 		if (debug_legacy_dish_switch)
@@ -457,13 +428,13 @@
 		cmd = cmd >> 1;
 
 		if (i != 8)
-			stv0299_sleep_until (&nexttime, 8000);
+			dvb_frontend_sleep_until(&nexttime, 8000);
 	}
 	if (debug_legacy_dish_switch) {
 		printk ("%s(%d): switch delay (should be 32k followed by all 8k\n",
 			__FUNCTION__, fe->dvb->num);
-		for (i=1; i < 10; i++)
-			printk ("%d: %d\n", i, stv0299_calc_usec_delay (tv[i-1] , tv[i]));
+		for (i = 1; i < 10; i++)
+			printk ("%d: %d\n", i, timeval_usec_diff(tv[i-1] , tv[i]));
 	}
 
 	return 0;
@@ -481,7 +452,7 @@
 
 	if (state->config->pll_init) {
 		stv0299_writeregI(state, 0x05, 0xb5);	/*  enable i2c repeater on stv0299  */
-		state->config->pll_init(fe);
+		state->config->pll_init(fe, state->i2c);
 		stv0299_writeregI(state, 0x05, 0x35);	/*  disable i2c repeater on stv0299  */
 	}
 
@@ -582,49 +553,14 @@
 	if (state->config->invert) invval = (~invval) & 1;
 	stv0299_writeregI(state, 0x0c, (stv0299_readreg(state, 0x0c) & 0xfe) | invval);
 
-	if (state->config->enhanced_tuning) {
-		/* check if we should do a finetune */
-		int frequency_delta = p->frequency - state->tuner_frequency;
-		int minmax = p->u.qpsk.symbol_rate / 2000;
-		if (minmax < 5000) minmax = 5000;
-
-		if ((frequency_delta > -minmax) && (frequency_delta < minmax) && (frequency_delta != 0) &&
-		    (state->fec_inner == p->u.qpsk.fec_inner) &&
-		    (state->symbol_rate == p->u.qpsk.symbol_rate)) {
-			int Drot_freq = (frequency_delta << 16) / (state->config->mclk / 1000);
-
-			// zap the derotator registers first
-			stv0299_writeregI(state, 0x22, 0x00);
-			stv0299_writeregI(state, 0x23, 0x00);
-
-			// now set them as we want
-			stv0299_writeregI(state, 0x22, Drot_freq >> 8);
-			stv0299_writeregI(state, 0x23, Drot_freq);
-		} else {
-			/* A "normal" tune is requested */
-			stv0299_writeregI(state, 0x05, 0xb5);	/*  enable i2c repeater on stv0299  */
-			state->config->pll_set(fe, p);
-			stv0299_writeregI(state, 0x05, 0x35);	/*  disable i2c repeater on stv0299  */
-
-			stv0299_writeregI(state, 0x32, 0x80);
-			stv0299_writeregI(state, 0x22, 0x00);
-			stv0299_writeregI(state, 0x23, 0x00);
-			stv0299_writeregI(state, 0x32, 0x19);
-			stv0299_set_symbolrate (fe, p->u.qpsk.symbol_rate);
-			stv0299_set_FEC (state, p->u.qpsk.fec_inner);
-		}
-	} else {
-		stv0299_writeregI(state, 0x05, 0xb5);	/*  enable i2c repeater on stv0299  */
-		state->config->pll_set(fe, p);
-		stv0299_writeregI(state, 0x05, 0x35);	/*  disable i2c repeater on stv0299  */
-
-		stv0299_set_FEC (state, p->u.qpsk.fec_inner);
-		stv0299_set_symbolrate (fe, p->u.qpsk.symbol_rate);
-		stv0299_writeregI(state, 0x22, 0x00);
-		stv0299_writeregI(state, 0x23, 0x00);
-		stv0299_readreg (state, 0x23);
-		stv0299_writeregI(state, 0x12, 0xb9);
-	}
+	stv0299_writeregI(state, 0x05, 0xb5);	/*  enable i2c repeater on stv0299  */
+	state->config->pll_set(fe, state->i2c, p);
+	stv0299_writeregI(state, 0x05, 0x35);	/*  disable i2c repeater on stv0299  */
+
+	stv0299_set_FEC (state, p->u.qpsk.fec_inner);
+	stv0299_set_symbolrate (fe, p->u.qpsk.symbol_rate);
+	stv0299_writeregI(state, 0x22, 0x00);
+	stv0299_writeregI(state, 0x23, 0x00);
 
 	state->tuner_frequency = p->frequency;
 	state->fec_inner = p->u.qpsk.fec_inner;
diff -Naur linux-2.6.12.6/drivers/media/dvb/frontends/stv0299.h linux-2.6.12.6-patched/drivers/media/dvb/frontends/stv0299.h
--- linux-2.6.12.6/drivers/media/dvb/frontends/stv0299.h	2005-08-29 18:55:27.000000000 +0200
+++ linux-2.6.12.6-patched/drivers/media/dvb/frontends/stv0299.h	2006-04-11 14:31:37.000000000 +0200
@@ -73,9 +73,6 @@
 	/* does the inversion require inversion? */
 	u8 invert:1;
 
-	/* Should the enhanced tuning code be used? */
-	u8 enhanced_tuning:1;
-
 	/* Skip reinitialisation? */
 	u8 skip_reinit:1;
 
@@ -92,8 +89,8 @@
 	int (*set_symbol_rate)(struct dvb_frontend* fe, u32 srate, u32 ratio);
 
 	/* PLL maintenance */
-	int (*pll_init)(struct dvb_frontend* fe);
-	int (*pll_set)(struct dvb_frontend* fe, struct dvb_frontend_parameters* params);
+	int (*pll_init)(struct dvb_frontend *fe, struct i2c_adapter *i2c);
+	int (*pll_set)(struct dvb_frontend *fe, struct i2c_adapter *i2c, struct dvb_frontend_parameters *params);
 };
 
 extern int stv0299_writereg (struct dvb_frontend* fe, u8 reg, u8 data);
diff -Naur linux-2.6.12.6/drivers/media/dvb/frontends/tda1004x.c linux-2.6.12.6-patched/drivers/media/dvb/frontends/tda1004x.c
--- linux-2.6.12.6/drivers/media/dvb/frontends/tda1004x.c	2005-08-29 18:55:27.000000000 +0200
+++ linux-2.6.12.6-patched/drivers/media/dvb/frontends/tda1004x.c	2006-04-11 14:31:37.000000000 +0200
@@ -32,6 +32,10 @@
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/device.h>
+#include <linux/jiffies.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+
 #include "dvb_frontend.h"
 #include "tda1004x.h"
 
@@ -49,10 +53,8 @@
 	/* private demod data */
 	u8 initialised;
 	enum tda1004x_demod demod_type;
-	u8 fw_version;
 };
 
-
 static int debug;
 #define dprintk(args...) \
 	do { \
@@ -122,6 +124,8 @@
 #define TDA10046H_GPIO_OUT_SEL	 0x41
 #define TDA10046H_GPIO_SELECT	 0x42
 #define TDA10046H_AGC_CONF	 0x43
+#define TDA10046H_AGC_THR	 0x44
+#define TDA10046H_AGC_RENORM	 0x45
 #define TDA10046H_AGC_GAINS	 0x46
 #define TDA10046H_AGC_TUN_MIN	 0x47
 #define TDA10046H_AGC_TUN_MAX	 0x48
@@ -267,21 +271,58 @@
 static int tda10046h_set_bandwidth(struct tda1004x_state *state,
 				   fe_bandwidth_t bandwidth)
 {
-	static u8 bandwidth_6mhz[] = { 0x80, 0x15, 0xfe, 0xab, 0x8e };
-	static u8 bandwidth_7mhz[] = { 0x6e, 0x02, 0x53, 0xc8, 0x25 };
-	static u8 bandwidth_8mhz[] = { 0x60, 0x12, 0xa8, 0xe4, 0xbd };
-
+	static u8 bandwidth_6mhz_53M[] = { 0x7b, 0x2e, 0x11, 0xf0, 0xd2 };
+	static u8 bandwidth_7mhz_53M[] = { 0x6a, 0x02, 0x6a, 0x43, 0x9f };
+	static u8 bandwidth_8mhz_53M[] = { 0x5c, 0x32, 0xc2, 0x96, 0x6d };
+
+	static u8 bandwidth_6mhz_48M[] = { 0x70, 0x02, 0x49, 0x24, 0x92 };
+	static u8 bandwidth_7mhz_48M[] = { 0x60, 0x02, 0xaa, 0xaa, 0xab };
+	static u8 bandwidth_8mhz_48M[] = { 0x54, 0x03, 0x0c, 0x30, 0xc3 };
+	int tda10046_clk53m;	
+
+	if ((state->config->if_freq == TDA10046_FREQ_045) ||
+	    (state->config->if_freq == TDA10046_FREQ_052))
+		tda10046_clk53m = 0;
+	else
+		tda10046_clk53m = 1;
 	switch (bandwidth) {
 	case BANDWIDTH_6_MHZ:
-		tda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_6mhz, sizeof(bandwidth_6mhz));
+		if (tda10046_clk53m)
+			tda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_6mhz_53M,
+					          sizeof(bandwidth_6mhz_53M));
+		else
+			tda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_6mhz_48M,
+					          sizeof(bandwidth_6mhz_48M));
+		if (state->config->if_freq == TDA10046_FREQ_045) {
+			tda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0x0a);
+			tda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0xab);
+		}
 		break;
 
 	case BANDWIDTH_7_MHZ:
-		tda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_7mhz, sizeof(bandwidth_7mhz));
+		if (tda10046_clk53m)
+			tda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_7mhz_53M,
+					          sizeof(bandwidth_7mhz_53M));
+		else
+			tda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_7mhz_48M,
+					          sizeof(bandwidth_7mhz_48M));
+		if (state->config->if_freq == TDA10046_FREQ_045) {
+			tda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0x0c);
+			tda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0x00);
+		}
 		break;
 
 	case BANDWIDTH_8_MHZ:
-		tda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_8mhz, sizeof(bandwidth_8mhz));
+		if (tda10046_clk53m)
+			tda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_8mhz_53M,
+					          sizeof(bandwidth_8mhz_53M));
+		else
+			tda1004x_write_buf(state, TDA10046H_TIME_WREF1, bandwidth_8mhz_48M,
+					          sizeof(bandwidth_8mhz_48M));
+		if (state->config->if_freq == TDA10046_FREQ_045) {
+			tda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0x0d);
+			tda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0x55);
+		}
 		break;
 
 	default:
@@ -315,20 +356,35 @@
 		memcpy(buf + 1, mem + pos, tx_size);
 		fw_msg.len = tx_size + 1;
 		if (i2c_transfer(state->i2c, &fw_msg, 1) != 1) {
-			printk("tda1004x: Error during firmware upload\n");
+			printk(KERN_ERR "tda1004x: Error during firmware upload\n");
 			return -EIO;
 		}
 		pos += tx_size;
 
 		dprintk("%s: fw_pos=0x%x\n", __FUNCTION__, pos);
 	}
+	// give the DSP a chance to settle 03/10/05 Hac
+	msleep(100);
 
 	return 0;
 }
 
-static int tda1004x_check_upload_ok(struct tda1004x_state *state, u8 dspVersion)
+static int tda1004x_check_upload_ok(struct tda1004x_state *state)
 {
 	u8 data1, data2;
+	unsigned long timeout;
+
+	if (state->demod_type == TDA1004X_DEMOD_TDA10046) {
+		timeout = jiffies + 2 * HZ;
+		while(!(tda1004x_read_byte(state, TDA1004X_STATUS_CD) & 0x20)) {
+			if (time_after(jiffies, timeout)) {
+				printk(KERN_ERR "tda1004x: timeout waiting for DSP ready\n");
+				break;
+			}
+			msleep(1);
+		}
+	} else
+		msleep(100);
 
 	// check upload was OK
 	tda1004x_write_mask(state, TDA1004X_CONFC4, 0x10, 0); // we want to read from the DSP
@@ -336,9 +392,11 @@
 
 	data1 = tda1004x_read_byte(state, TDA1004X_DSP_DATA1);
 	data2 = tda1004x_read_byte(state, TDA1004X_DSP_DATA2);
-	if ((data1 != 0x67) || (data2 != dspVersion))
+	if (data1 != 0x67 || data2 < 0x20 || data2 > 0x2e) {
+		printk(KERN_INFO "tda1004x: found firmware revision %x -- invalid\n", data2);
 		return -EIO;
-
+	}
+	printk(KERN_INFO "tda1004x: found firmware revision %x -- ok\n", data2);
 	return 0;
 }
 
@@ -349,14 +407,14 @@
 	const struct firmware *fw;
 
 	/* don't re-upload unless necessary */
-	if (tda1004x_check_upload_ok(state, 0x2c) == 0)
+	if (tda1004x_check_upload_ok(state) == 0)
 		return 0;
 
 	/* request the firmware, this will block until someone uploads it */
-	printk("tda1004x: waiting for firmware upload (%s)...\n", TDA10045_DEFAULT_FIRMWARE);
+	printk(KERN_INFO "tda1004x: waiting for firmware upload (%s)...\n", TDA10045_DEFAULT_FIRMWARE);
 	ret = state->config->request_firmware(fe, &fw, TDA10045_DEFAULT_FIRMWARE);
 	if (ret) {
-		printk("tda1004x: no firmware upload (timeout or file not found?)\n");
+		printk(KERN_ERR "tda1004x: no firmware upload (timeout or file not found?)\n");
 		return ret;
 	}
 
@@ -370,95 +428,111 @@
 	tda10045h_set_bandwidth(state, BANDWIDTH_8_MHZ);
 
 	ret = tda1004x_do_upload(state, fw->data, fw->size, TDA10045H_FWPAGE, TDA10045H_CODE_IN);
+	release_firmware(fw);
 	if (ret)
 		return ret;
-	printk("tda1004x: firmware upload complete\n");
+	printk(KERN_INFO "tda1004x: firmware upload complete\n");
 
 	/* wait for DSP to initialise */
 	/* DSPREADY doesn't seem to work on the TDA10045H */
 	msleep(100);
 
-	return tda1004x_check_upload_ok(state, 0x2c);
+	return tda1004x_check_upload_ok(state);
 }
 
-static int tda10046_get_fw_version(struct tda1004x_state *state,
-				   const struct firmware *fw)
+static void tda10046_init_plls(struct dvb_frontend* fe)
 {
-	const unsigned char pattern[] = { 0x67, 0x00, 0x50, 0x62, 0x5e, 0x18, 0x67 };
-	unsigned int i;
+	struct tda1004x_state* state = fe->demodulator_priv;
+	int tda10046_clk53m;	
 
-	/* area guessed from firmware v20, v21 and v25 */
-	for (i = 0x660; i < 0x700; i++) {
-		if (!memcmp(&fw->data[i], pattern, sizeof(pattern))) {
-			state->fw_version = fw->data[i + sizeof(pattern)];
-			printk(KERN_INFO "tda1004x: using firmware v%02x\n",
-					state->fw_version);
-			return 0;
-		}
-	}
+	if ((state->config->if_freq == TDA10046_FREQ_045) ||
+	    (state->config->if_freq == TDA10046_FREQ_052))
+		tda10046_clk53m = 0;
+	else
+		tda10046_clk53m = 1;
 
-	return -EINVAL;
+	tda1004x_write_byteI(state, TDA10046H_CONFPLL1, 0xf0);
+	if(tda10046_clk53m) {
+		printk(KERN_INFO "tda1004x: setting up plls for 53MHz sampling clock\n");
+		tda1004x_write_byteI(state, TDA10046H_CONFPLL2, 0x08); // PLL M = 8
+	} else {
+		printk(KERN_INFO "tda1004x: setting up plls for 48MHz sampling clock\n");
+		tda1004x_write_byteI(state, TDA10046H_CONFPLL2, 0x03); // PLL M = 3
+	}
+	if (state->config->xtal_freq == TDA10046_XTAL_4M ) {
+		dprintk("%s: setting up PLLs for a 4 MHz Xtal\n", __FUNCTION__);
+		tda1004x_write_byteI(state, TDA10046H_CONFPLL3, 0); // PLL P = N = 0
+	} else {
+		dprintk("%s: setting up PLLs for a 16 MHz Xtal\n", __FUNCTION__);
+		tda1004x_write_byteI(state, TDA10046H_CONFPLL3, 3); // PLL P = 0, N = 3
+	}
+	if(tda10046_clk53m)
+		tda1004x_write_byteI(state, TDA10046H_FREQ_OFFSET, 0x67);
+	else
+		tda1004x_write_byteI(state, TDA10046H_FREQ_OFFSET, 0x72);
+	/* Note clock frequency is handled implicitly */		
+	switch (state->config->if_freq) {
+	case TDA10046_FREQ_045:
+		tda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0x0c);
+		tda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0x00);
+		break;
+	case TDA10046_FREQ_052:
+		tda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0x0d);
+		tda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0xc7);
+		break;
+	case TDA10046_FREQ_3617:
+		tda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0xd7);
+		tda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0x59);
+		break;
+	case TDA10046_FREQ_3613:
+		tda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0xd7);
+		tda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0x3f);
+		break;
+	}
+	tda10046h_set_bandwidth(state, BANDWIDTH_8_MHZ); // default bandwidth 8 MHz
+	/* let the PLLs settle */
+	msleep(120);
 }
 
 static int tda10046_fwupload(struct dvb_frontend* fe)
 {
 	struct tda1004x_state* state = fe->demodulator_priv;
-	unsigned long timeout;
 	int ret;
 	const struct firmware *fw;
 
 	/* reset + wake up chip */
-	tda1004x_write_mask(state, TDA1004X_CONFC4, 1, 0);
+	tda1004x_write_byteI(state, TDA1004X_CONFC4, 0);
 	tda1004x_write_mask(state, TDA10046H_CONF_TRISTATE1, 1, 0);
-	msleep(100);
+	/* let the clocks recover from sleep */
+	msleep(5);
+
+	/* The PLLs need to be reprogrammed after sleep */
+	tda10046_init_plls(fe);
 
 	/* don't re-upload unless necessary */
-	if (tda1004x_check_upload_ok(state, state->fw_version) == 0)
+	if (tda1004x_check_upload_ok(state) == 0)
 		return 0;
 
-	/* request the firmware, this will block until someone uploads it */
-	printk("tda1004x: waiting for firmware upload (%s)...\n", TDA10046_DEFAULT_FIRMWARE);
-	ret = state->config->request_firmware(fe, &fw, TDA10046_DEFAULT_FIRMWARE);
-	if (ret) {
-		printk("tda1004x: no firmware upload (timeout or file not found?)\n");
-		return ret;
-	}
-
-	if (fw->size < 24478) { /* size of firmware v20, which is the smallest of v20, v21 and v25 */
-		printk("tda1004x: firmware file seems to be too small (%d bytes)\n", fw->size);
-		return -EINVAL;
-	}
-
-	ret = tda10046_get_fw_version(state, fw);
-	if (ret < 0) {
-		printk("tda1004x: unable to find firmware version\n");
-		return ret;
-	}
-
-	/* set parameters */
-	tda1004x_write_byteI(state, TDA10046H_CONFPLL2, 10);
-	tda1004x_write_byteI(state, TDA10046H_CONFPLL3, state->config->n_i2c);
-	tda1004x_write_byteI(state, TDA10046H_FREQ_OFFSET, 99);
-	tda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0xd4);
-	tda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0x2c);
-	tda1004x_write_mask(state, TDA1004X_CONFC4, 8, 8); // going to boot from HOST
-
-	ret = tda1004x_do_upload(state, fw->data, fw->size, TDA10046H_CODE_CPT, TDA10046H_CODE_IN);
-	if (ret)
-		return ret;
-	printk("tda1004x: firmware upload complete\n");
-
-	/* wait for DSP to initialise */
-	timeout = jiffies + HZ;
-	while (!(tda1004x_read_byte(state, TDA1004X_STATUS_CD) & 0x20)) {
-		if (time_after(jiffies, timeout)) {
-			printk("tda1004x: DSP failed to initialised.\n");
-			return -EIO;
+	if (state->config->request_firmware != NULL) {
+		/* request the firmware, this will block until someone uploads it */
+		printk(KERN_INFO "tda1004x: waiting for firmware upload...\n");
+		ret = state->config->request_firmware(fe, &fw, TDA10046_DEFAULT_FIRMWARE);
+		if (ret) {
+			printk(KERN_ERR "tda1004x: no firmware upload (timeout or file not found?)\n");
+   	   		return ret;
 		}
-		msleep(1);
+		tda1004x_write_mask(state, TDA1004X_CONFC4, 8, 8); // going to boot from HOST
+		ret = tda1004x_do_upload(state, fw->data, fw->size, TDA10046H_CODE_CPT, TDA10046H_CODE_IN);
+		release_firmware(fw);
+		if (ret)
+			return ret;
+	} else {
+		/* boot from firmware eeprom */
+		printk(KERN_INFO "tda1004x: booting from eeprom\n");
+		tda1004x_write_mask(state, TDA1004X_CONFC4, 4, 4);
+		msleep(300);
 	}
-
-	return tda1004x_check_upload_ok(state, state->fw_version);
+	return tda1004x_check_upload_ok(state);
 }
 
 static int tda1004x_encode_fec(int fec)
@@ -560,45 +634,54 @@
 
 	if (tda10046_fwupload(fe)) {
 		printk("tda1004x: firmware upload failed\n");
-		return -EIO;
+			return -EIO;
 	}
 
-	tda1004x_write_mask(state, TDA1004X_CONFC4, 1, 0); // wake up the chip
-
-	// Init the PLL
+	// Init the tuner PLL
 	if (state->config->pll_init) {
 		tda1004x_enable_tuner_i2c(state);
-		state->config->pll_init(fe);
+		if (state->config->pll_init(fe)) {
+			printk(KERN_ERR "tda1004x: pll init failed\n");
+			return 	-EIO;
+		}
 		tda1004x_disable_tuner_i2c(state);
 	}
 
 	// tda setup
 	tda1004x_write_mask(state, TDA1004X_CONFC4, 0x20, 0); // disable DSP watchdog timer
-	tda1004x_write_mask(state, TDA1004X_CONFC1, 0x40, 0x40);
-	tda1004x_write_mask(state, TDA1004X_AUTO, 8, 0); // select HP stream
-	tda1004x_write_mask(state, TDA1004X_CONFC1, 0x80, 0); // disable pulse killer
-	tda1004x_write_byteI(state, TDA10046H_CONFPLL2, 10); // PLL M = 10
-	tda1004x_write_byteI(state, TDA10046H_CONFPLL3, state->config->n_i2c); // PLL P = N = 0
-	tda1004x_write_byteI(state, TDA10046H_FREQ_OFFSET, 99); // FREQOFFS = 99
-	tda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_MSB, 0xd4); // } PHY2 = -11221
-	tda1004x_write_byteI(state, TDA10046H_FREQ_PHY2_LSB, 0x2c); // }
-	tda1004x_write_byteI(state, TDA10046H_AGC_CONF, 0); // AGC setup
-	tda1004x_write_mask(state, TDA10046H_CONF_POLARITY, 0x60, 0x60); // set AGC polarities
+	tda1004x_write_byteI(state, TDA1004X_AUTO, 0x87);    // 100 ppm crystal, select HP stream
+	tda1004x_write_byteI(state, TDA1004X_CONFC1, 8);      // disable pulse killer
+
+	switch (state->config->agc_config) {
+	case TDA10046_AGC_DEFAULT:
+		tda1004x_write_byteI(state, TDA10046H_AGC_CONF, 0x00); // AGC setup
+		tda1004x_write_byteI(state, TDA10046H_CONF_POLARITY, 0x60); // set AGC polarities
+		break;
+	case TDA10046_AGC_IFO_AUTO_NEG:
+		tda1004x_write_byteI(state, TDA10046H_AGC_CONF, 0x0a); // AGC setup
+		tda1004x_write_byteI(state, TDA10046H_CONF_POLARITY, 0x60); // set AGC polarities
+		break;
+	case TDA10046_AGC_IFO_AUTO_POS:
+		tda1004x_write_byteI(state, TDA10046H_AGC_CONF, 0x0a); // AGC setup
+		tda1004x_write_byteI(state, TDA10046H_CONF_POLARITY, 0x00); // set AGC polarities
+		break;
+	case TDA10046_AGC_TDA827X:
+		tda1004x_write_byteI(state, TDA10046H_AGC_CONF, 0x02);   // AGC setup
+		tda1004x_write_byteI(state, TDA10046H_AGC_THR, 0x70);    // AGC Threshold
+		tda1004x_write_byteI(state, TDA10046H_AGC_RENORM, 0x08); // Gain Renormalize
+		tda1004x_write_byteI(state, TDA10046H_CONF_POLARITY, 0x6a); // set AGC polarities
+		break;
+	}
+	tda1004x_write_byteI(state, TDA1004X_CONFADC2, 0x38);
+	tda1004x_write_byteI(state, TDA10046H_CONF_TRISTATE1, 0x61); // Turn both AGC outputs on
 	tda1004x_write_byteI(state, TDA10046H_AGC_TUN_MIN, 0);	  // }
 	tda1004x_write_byteI(state, TDA10046H_AGC_TUN_MAX, 0xff); // } AGC min/max values
 	tda1004x_write_byteI(state, TDA10046H_AGC_IF_MIN, 0);	  // }
 	tda1004x_write_byteI(state, TDA10046H_AGC_IF_MAX, 0xff);  // }
-	tda1004x_write_mask(state, TDA10046H_CVBER_CTRL, 0x30, 0x10); // 10^6 VBER measurement bits
-	tda1004x_write_byteI(state, TDA10046H_AGC_GAINS, 1); // IF gain 2, TUN gain 1
-	tda1004x_write_mask(state, TDA1004X_AUTO, 0x80, 0); // crystal is 50ppm
+	tda1004x_write_byteI(state, TDA10046H_AGC_GAINS, 0x12); // IF gain 2, TUN gain 1
+	tda1004x_write_byteI(state, TDA10046H_CVBER_CTRL, 0x1a); // 10^6 VBER measurement bits
 	tda1004x_write_byteI(state, TDA1004X_CONF_TS1, 7); // MPEG2 interface config
-	tda1004x_write_mask(state, TDA1004X_CONF_TS2, 0x31, 0); // MPEG2 interface config
-	tda1004x_write_mask(state, TDA10046H_CONF_TRISTATE1, 0x9e, 0); // disable AGC_TUN
-	tda1004x_write_byteI(state, TDA10046H_CONF_TRISTATE2, 0xe1); // tristate setup
-	tda1004x_write_byteI(state, TDA10046H_GPIO_OUT_SEL, 0xcc); // GPIO output config
-	tda1004x_write_mask(state, TDA10046H_GPIO_SELECT, 8, 8); // GPIO select
-	tda10046h_set_bandwidth(state, BANDWIDTH_8_MHZ); // default bandwidth 8 MHz
-
+	tda1004x_write_byteI(state, TDA1004X_CONF_TS2, 0xc0); // MPEG2 interface config
 	tda1004x_write_mask(state, 0x3a, 0x80, state->config->invert_oclk << 7);
 
 	state->initialised = 1;
@@ -626,12 +709,12 @@
 
 	// set frequency
 	tda1004x_enable_tuner_i2c(state);
-	state->config->pll_set(fe, fe_params);
+	if (state->config->pll_set(fe, fe_params)) {
+		printk(KERN_ERR "tda1004x: pll set failed\n");
+		return 	-EIO;
+	}
 	tda1004x_disable_tuner_i2c(state);
 
-	if (state->demod_type == TDA1004X_DEMOD_TDA10046)
-		tda1004x_write_mask(state, TDA10046H_AGC_CONF, 4, 4);
-
 	// Hardcoded to use auto as much as possible on the TDA10045 as it
 	// is very unreliable if AUTO mode is _not_ used.
 	if (state->demod_type == TDA1004X_DEMOD_TDA10045) {
@@ -642,9 +725,9 @@
 
 	// Set standard params.. or put them to auto
 	if ((fe_params->u.ofdm.code_rate_HP == FEC_AUTO) ||
-	    (fe_params->u.ofdm.code_rate_LP == FEC_AUTO) ||
-	    (fe_params->u.ofdm.constellation == QAM_AUTO) ||
-	    (fe_params->u.ofdm.hierarchy_information == HIERARCHY_AUTO)) {
+		(fe_params->u.ofdm.code_rate_LP == FEC_AUTO) ||
+		(fe_params->u.ofdm.constellation == QAM_AUTO) ||
+		(fe_params->u.ofdm.hierarchy_information == HIERARCHY_AUTO)) {
 		tda1004x_write_mask(state, TDA1004X_AUTO, 1, 1);	// enable auto
 		tda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x03, 0);	// turn off constellation bits
 		tda1004x_write_mask(state, TDA1004X_IN_CONF1, 0x60, 0);	// turn off hierarchy bits
@@ -794,6 +877,8 @@
 
 	case TDA1004X_DEMOD_TDA10046:
 		tda1004x_write_mask(state, TDA1004X_AUTO, 0x40, 0x40);
+		msleep(1);
+		tda1004x_write_mask(state, TDA10046H_AGC_CONF, 4, 1);
 		break;
 	}
 
@@ -805,6 +890,7 @@
 static int tda1004x_get_fe(struct dvb_frontend* fe, struct dvb_frontend_parameters *fe_params)
 {
 	struct tda1004x_state* state = fe->demodulator_priv;
+
 	dprintk("%s\n", __FUNCTION__);
 
 	// inversion status
@@ -829,16 +915,18 @@
 			break;
 		}
 		break;
-
 	case TDA1004X_DEMOD_TDA10046:
 		switch (tda1004x_read_byte(state, TDA10046H_TIME_WREF1)) {
-		case 0x60:
+		case 0x5c:
+		case 0x54:
 			fe_params->u.ofdm.bandwidth = BANDWIDTH_8_MHZ;
 			break;
-		case 0x6e:
+		case 0x6a:
+		case 0x60:
 			fe_params->u.ofdm.bandwidth = BANDWIDTH_7_MHZ;
 			break;
-		case 0x80:
+		case 0x7b:
+		case 0x70:
 			fe_params->u.ofdm.bandwidth = BANDWIDTH_6_MHZ;
 			break;
 		}
@@ -1012,8 +1100,7 @@
 	tmp = tda1004x_read_byte(state, TDA1004X_SNR);
 	if (tmp < 0)
 		return -EIO;
-	if (tmp)
-		tmp = 255 - tmp;
+	tmp = 255 - tmp;
 
 	*snr = ((tmp << 8) | tmp);
 	dprintk("%s: snr=0x%x\n", __FUNCTION__, *snr);
@@ -1089,6 +1176,16 @@
 		break;
 
 	case TDA1004X_DEMOD_TDA10046:
+		if (state->config->pll_sleep != NULL) {
+			tda1004x_enable_tuner_i2c(state);
+			state->config->pll_sleep(fe);
+			if (state->config->if_freq != TDA10046_FREQ_052) {
+				/* special hack for Philips EUROPA Based boards:
+				 * keep the I2c bridge open for tuner access in analog mode
+				 */
+				tda1004x_disable_tuner_i2c(state);
+			}
+		}
 		tda1004x_write_mask(state, TDA1004X_CONFC4, 1, 1);
 		break;
 	}
@@ -1100,8 +1197,9 @@
 static int tda1004x_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings* fesettings)
 {
 	fesettings->min_delay_ms = 800;
-	fesettings->step_size = 166667;
-	fesettings->max_drift = 166667*2;
+	/* Drift compensation makes no sense for DVB-T */
+	fesettings->step_size = 0;
+	fesettings->max_drift = 0;
 	return 0;
 }
 
@@ -1216,7 +1314,6 @@
 	memcpy(&state->ops, &tda10046_ops, sizeof(struct dvb_frontend_ops));
 	state->initialised = 0;
 	state->demod_type = TDA1004X_DEMOD_TDA10046;
-	state->fw_version = 0x20;	/* dummy default value */
 
 	/* check if the demod is there */
 	if (tda1004x_read_byte(state, TDA1004X_CHIPID) != 0x46) {
diff -Naur linux-2.6.12.6/drivers/media/dvb/frontends/tda1004x.h linux-2.6.12.6-patched/drivers/media/dvb/frontends/tda1004x.h
--- linux-2.6.12.6/drivers/media/dvb/frontends/tda1004x.h	2005-08-29 18:55:27.000000000 +0200
+++ linux-2.6.12.6-patched/drivers/media/dvb/frontends/tda1004x.h	2006-04-11 14:31:37.000000000 +0200
@@ -26,6 +26,25 @@
 #include <linux/dvb/frontend.h>
 #include <linux/firmware.h>
 
+enum tda10046_xtal {
+	TDA10046_XTAL_4M,
+	TDA10046_XTAL_16M,
+};
+
+enum tda10046_agc {
+	TDA10046_AGC_DEFAULT,		/* original configuration */
+	TDA10046_AGC_IFO_AUTO_NEG,	/* IF AGC only, automatic, negtive */
+	TDA10046_AGC_IFO_AUTO_POS,	/* IF AGC only, automatic, positive */
+	TDA10046_AGC_TDA827X,	    /* IF AGC only, special setup for tda827x */
+};
+
+enum tda10046_if {
+	TDA10046_FREQ_3617,		/* original config, 36,166 MHZ */
+	TDA10046_FREQ_3613,		/* 36,13 MHZ */
+	TDA10046_FREQ_045,		/* low IF, 4.0, 4.5, or 5.0 MHZ */
+	TDA10046_FREQ_052,		/* low IF, 5.1667 MHZ for tda9889 */
+};
+
 struct tda1004x_config
 {
 	/* the demodulator's i2c address */
@@ -37,14 +56,22 @@
 	/* Does the OCLK signal need inverted? */
 	u8 invert_oclk;
 
-	/* value of N_I2C of the CONF_PLL3 register */
-	u8 n_i2c;
+	/* Xtal frequency, 4 or 16MHz*/
+	enum tda10046_xtal xtal_freq;
+
+	/* IF frequency */
+	enum tda10046_if if_freq;
+
+	/* AGC configuration */
+	enum tda10046_agc agc_config;
 
 	/* PLL maintenance */
 	int (*pll_init)(struct dvb_frontend* fe);
+	void (*pll_sleep)(struct dvb_frontend* fe);
 	int (*pll_set)(struct dvb_frontend* fe, struct dvb_frontend_parameters* params);
 
 	/* request firmware for device */
+	/* set this to NULL if the card has a firmware EEPROM */
 	int (*request_firmware)(struct dvb_frontend* fe, const struct firmware **fw, char* name);
 };
 
