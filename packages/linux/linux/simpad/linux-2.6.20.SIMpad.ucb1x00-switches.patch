diff -uNr linux-2.6.20.vanilla/drivers/mfd/Kconfig linux-2.6.20/drivers/mfd/Kconfig
--- linux-2.6.20.vanilla/drivers/mfd/Kconfig	2007-02-09 18:27:41.000000000 +0100
+++ linux-2.6.20/drivers/mfd/Kconfig	2007-02-09 19:29:23.000000000 +0100
@@ -23,4 +23,7 @@
 	tristate "Touchscreen interface support"
 	depends on MCP_UCB1200 && INPUT
 
+config MCP_UCB1200_SWITCHES
+        tristate "SIMpad Switches support"
+        depends on MCP_UCB1200 && INPUT
 endmenu
diff -uNr linux-2.6.20.vanilla/drivers/mfd/Makefile linux-2.6.20/drivers/mfd/Makefile
--- linux-2.6.20.vanilla/drivers/mfd/Makefile	2007-02-09 18:27:41.000000000 +0100
+++ linux-2.6.20/drivers/mfd/Makefile	2007-02-09 19:29:23.000000000 +0100
@@ -6,7 +6,7 @@
 obj-$(CONFIG_MCP_SA11X0)	+= mcp-sa11x0.o
 obj-$(CONFIG_MCP_UCB1200)	+= ucb1x00-core.o
 obj-$(CONFIG_MCP_UCB1200_TS)	+= ucb1x00-ts.o
-
+obj-$(CONFIG_MCP_UCB1200_SWITCHES) += ucb1x00-switches.o
 ifeq ($(CONFIG_SA1100_ASSABET),y)
 obj-$(CONFIG_MCP_UCB1200)	+= ucb1x00-assabet.o
 endif
diff -uNr linux-2.6.20.vanilla/drivers/mfd/ucb1x00-switches.c linux-2.6.20/drivers/mfd/ucb1x00-switches.c
--- linux-2.6.20.vanilla/drivers/mfd/ucb1x00-switches.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20/drivers/mfd/ucb1x00-switches.c	2007-02-09 19:30:34.000000000 +0100
@@ -0,0 +1,200 @@
+/*
+ *  linux/drivers/mfd/ucb1x00-switches.c
+ *
+ *  Copyright (C) 2007 Bernhard Guillon.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License.
+ *
+ *  This driver is for the Switches of Siemens SIMpad (CL4,SL4,SLC), T-Sinus-Pad and
+ *  Swisscom WP50 devices.
+ *
+ *  Six switches are routed to GPIO pins on the UCB1300: S3 -- S8.
+ *
+ *  This driver is based on the 2.4 ucb1x00-switches, the 2.6 ucb1x00-assabet
+ *  and the ucb1x00-ts driver.
+ *
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/device.h>
+
+#include <asm/dma.h>
+
+#include "ucb1x00.h"
+
+struct ucb1x00_switches {
+	struct input_dev	*idev;
+	struct ucb1x00		*ucb;
+};
+
+static void ucb1x00_dev_irq(int idx, void *id)
+{
+	static unsigned short int last;
+	unsigned short int this;	
+	struct ucb1x00_switches *switches = id;
+	struct input_dev *idev = switches->idev;
+	ucb1x00_enable(switches->ucb);
+	
+	//check if it really is a event this is not real neccessary because input dev checkes it itself a second.
+	this=~ucb1x00_io_read(switches->ucb);
+	if (this==last) {
+		 return;
+	}
+
+	last=this;
+	switch (idx) {
+
+	case 0:
+
+		if ((this & (1<<0)) != 0) input_report_key(idev, KEY_PROG1, 1);
+		else input_report_key(idev, KEY_PROG1, 0);
+		break;
+
+	case 1:
+
+		if ((this & (1<<1)) != 0) input_report_key(idev, KEY_PROG2, 1);
+		else input_report_key(idev, KEY_PROG2, 0);
+		break;
+
+	case 2:
+
+		if ((this & (1<<2)) != 0) input_report_key(idev, KEY_UP, 1); 
+		else input_report_key(idev, KEY_UP, 0); 
+		break;
+
+	case 3:
+
+		if ((this & (1<<3)) != 0) input_report_key(idev, KEY_DOWN, 1); 
+		else input_report_key(idev, KEY_DOWN, 0); 
+		break;
+
+	case 4:
+
+		if ((this & (1<<4)) != 0) input_report_key(idev, KEY_LEFT, 1);
+		else input_report_key(idev, KEY_LEFT, 0);
+		break;
+
+	case 5:
+
+		if ((this & (1<<5)) != 0) input_report_key(idev, KEY_RIGHT, 1);
+		else input_report_key(idev, KEY_RIGHT, 0);
+		break;
+
+	default:
+
+		printk(KERN_DEBUG "switches-ucb1x00 is BUGGY!!! \n");
+
+	}
+
+	ucb1x00_disable_irq(switches->ucb, UCB_IRQ_TSPX, UCB_FALLING);
+	
+}
+
+static int ucb1x00_switches_add(struct ucb1x00_dev *dev)
+{
+	struct ucb1x00_switches *switches;
+	struct input_dev *idev;
+	int err,i;
+	
+	switches = kzalloc(sizeof(struct ucb1x00_switches), GFP_KERNEL);
+	idev = input_allocate_device();
+
+
+	if (!switches || !idev) {
+		err = -ENOMEM;
+		goto fail;
+	}
+
+	switches->ucb = dev->ucb;
+	
+
+	idev->private    = switches;
+	idev->name       = "SIMpad Switches";
+	idev->id.product = switches->ucb->id;
+	
+	__set_bit(EV_KEY,    idev->evbit);
+	__set_bit(EV_REP,    idev->evbit);
+	__set_bit(KEY_PROG1,    idev->keybit);
+	__set_bit(KEY_PROG2,    idev->keybit);
+	__set_bit(KEY_UP,    idev->keybit);
+	__set_bit(KEY_DOWN,    idev->keybit);
+	__set_bit(KEY_LEFT,    idev->keybit);
+	__set_bit(KEY_RIGHT,    idev->keybit);
+	
+	err = input_register_device(idev);
+	if (err)
+		goto fail;
+	switches->idev = idev;
+	dev->priv = switches;
+	
+	ucb1x00_enable(switches->ucb);
+
+	ucb1x00_io_set_dir(switches->ucb,
+			   UCB_IO_0 | UCB_IO_1 | UCB_IO_2 |
+			   UCB_IO_3 | UCB_IO_4 | UCB_IO_5, 
+			   UCB_IO_8 | UCB_IO_9);
+
+	ucb1x00_disable(switches->ucb);
+	
+	for (i = 0; i < 6; ++i) {
+		ucb1x00_enable_irq(switches->ucb, i, UCB_RISING | UCB_FALLING);
+		if (ucb1x00_hook_irq(switches->ucb, i, ucb1x00_dev_irq, switches) < 0) {
+			printk(KERN_ERR "unable to hook IRQ for "
+			       "UCB1300 SWITCH_%d\n", i);
+			return -EBUSY;
+		}
+	}
+		
+	return 0;
+
+fail:
+	input_free_device(idev);
+	kfree(switches);
+	return err;
+
+}
+
+static void ucb1x00_switches_remove(struct ucb1x00_dev *dev)
+{
+	int i;
+	struct ucb1x00_switches *switches = dev->priv;
+	input_unregister_device(switches->idev);
+		
+	for (i = 5; i >= 0; --i) {
+
+		ucb1x00_disable_irq(switches->ucb, i, UCB_RISING | UCB_FALLING);
+
+		/* Only error conditions are ENOENT and EINVAL; silently
+		 * ignore:
+		 */
+		ucb1x00_free_irq(switches->ucb, i, NULL);
+
+	}
+	ucb1x00_disable(switches->ucb);
+	kfree(switches);
+}
+
+static struct ucb1x00_driver ucb1x00_switches_driver = {
+	.add	= ucb1x00_switches_add,
+	.remove	= ucb1x00_switches_remove,
+};
+
+static int __init ucb1x00_switches_init(void)
+{
+	return ucb1x00_register_driver(&ucb1x00_switches_driver);
+}
+
+static void __exit ucb1x00_switches_exit(void)
+{
+	ucb1x00_unregister_driver(&ucb1x00_switches_driver);
+}
+
+module_init(ucb1x00_switches_init);
+module_exit(ucb1x00_switches_exit);
+
+MODULE_AUTHOR("Bernhard Guillon <Bernhard.Guillon@opensimpad.org>");
+MODULE_DESCRIPTION("UCB1x00 Switches driver for Siemens SIMpad");
+MODULE_LICENSE("GPL");
