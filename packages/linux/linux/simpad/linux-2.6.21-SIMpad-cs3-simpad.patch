diff -uNr linux-2.6.21.vanilla/arch/arm/mach-sa1100/Makefile linux-2.6.21/arch/arm/mach-sa1100/Makefile
--- linux-2.6.21.vanilla/arch/arm/mach-sa1100/Makefile	2007-05-01 16:40:44.000000000 +0200
+++ linux-2.6.21/arch/arm/mach-sa1100/Makefile	2007-05-01 16:52:10.000000000 +0200
@@ -40,6 +40,7 @@
 obj-$(CONFIG_SA1100_SHANNON)		+= shannon.o
 
 obj-$(CONFIG_SA1100_SIMPAD)		+= simpad.o
+obj-$(CONFIG_SA1100_SIMPAD)             += cs3-simpad.o
 led-$(CONFIG_SA1100_SIMPAD)		+= leds-simpad.o
 
 # LEDs support
diff -uNr linux-2.6.21.vanilla/arch/arm/mach-sa1100/cs3-simpad.c linux-2.6.21/arch/arm/mach-sa1100/cs3-simpad.c
--- linux-2.6.21.vanilla/arch/arm/mach-sa1100/cs3-simpad.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21/arch/arm/mach-sa1100/cs3-simpad.c	2007-05-01 16:52:10.000000000 +0200
@@ -0,0 +1,300 @@
+/*
+ *  cs3-simpad.c
+ *
+ *  This driver shows the GPIO states of the cs3 latch. You can also
+ *  switch some GPIOS.
+ *
+ *  (c) 2007 Bernhard Guillon <Bernhard.Guillon@OpenSIMpad.org>
+ *
+ *  You may use this code as per GPL version 2
+ *
+ *  Some parts are based on battery.c
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/device.h>
+
+#include <asm/arch/simpad.h>
+
+extern long get_cs3_shadow(void);
+extern void set_cs3_bit(int value);
+extern void clear_cs3_bit(int value);
+
+struct cs3 {
+	struct class_device class_dev;
+	const char *name;
+	char *id;
+	int type;
+};
+
+struct cs3 cs3 ={
+        .name = "latch_cs3",
+};
+
+static ssize_t get_VCC_5V_EN (struct class_device *class_dev, char *buf) {
+    if (get_cs3_shadow() & VCC_5V_EN ) 
+        return sprintf(buf, "1\n");
+    else 
+        return sprintf(buf, "0\n");
+} 
+
+static ssize_t get_VCC_3V_EN (struct class_device *class_dev, char *buf) {
+    if (get_cs3_shadow() & VCC_3V_EN) 
+        return sprintf(buf, "1\n");
+    else 
+        return sprintf(buf, "0\n");
+} 
+
+static ssize_t get_EN1 (struct class_device *class_dev, char *buf) {
+    if (get_cs3_shadow() & EN1) 
+        return sprintf(buf, "1\n");
+    else 
+        return sprintf(buf, "0\n");
+} 
+
+static ssize_t get_EN0 (struct class_device *class_dev, char *buf) {
+    if (get_cs3_shadow() & EN0) 
+        return sprintf(buf, "1\n");
+    else 
+        return sprintf(buf, "0\n");
+} 
+
+static ssize_t get_DISPLAY_ON (struct class_device *class_dev, char *buf) {
+    if (get_cs3_shadow() & DISPLAY_ON) 
+        return sprintf(buf, "1\n");
+    else 
+        return sprintf(buf, "0\n");
+} 
+
+static ssize_t get_PCMCIA_BUFF_DIS (struct class_device *class_dev, char *buf) {
+    if (get_cs3_shadow() & PCMCIA_BUFF_DIS) 
+        return sprintf(buf, "1\n");
+    else 
+        return sprintf(buf, "0\n");
+} 
+
+static ssize_t get_MQ_RESET (struct class_device *class_dev, char *buf) {
+    if (get_cs3_shadow() & MQ_RESET) 
+        return sprintf(buf, "1\n");
+    else 
+        return sprintf(buf, "0\n");
+} 
+
+static ssize_t get_PCMCIA_RESET (struct class_device *class_dev, char *buf) {
+    if (get_cs3_shadow() & PCMCIA_RESET) 
+        return sprintf(buf, "1\n");
+    else 
+        return sprintf(buf, "0\n");
+}
+
+static ssize_t get_DECT_POWER_ON (struct class_device *class_dev, char *buf) {
+    if (get_cs3_shadow() & DECT_POWER_ON) 
+        return sprintf(buf, "1\n");
+    else 
+        return sprintf(buf, "0\n");
+} 
+
+static ssize_t get_IRDA_SD (struct class_device *class_dev, char *buf) {
+    if (get_cs3_shadow() & IRDA_SD) 
+        return sprintf(buf, "1\n");
+    else 
+        return sprintf(buf, "0\n");
+} 
+
+static ssize_t get_RS232_ON (struct class_device *class_dev, char *buf) {
+    if (get_cs3_shadow() & RS232_ON) 
+        return sprintf(buf, "1\n");
+    else 
+        return sprintf(buf, "0\n");
+} 
+
+static ssize_t get_SD_MEDIAQ (struct class_device *class_dev, char *buf) {
+    if (get_cs3_shadow() & SD_MEDIAQ) 
+        return sprintf(buf, "1\n");
+    else 
+        return sprintf(buf, "0\n");
+}
+
+static ssize_t get_LED2_ON (struct class_device *class_dev, char *buf) {
+    if (get_cs3_shadow() & LED2_ON) 
+        return sprintf(buf, "1\n");
+    else 
+        return sprintf(buf, "0\n");
+} 
+
+static ssize_t get_IRDA_MODE (struct class_device *class_dev, char *buf) {
+    if (get_cs3_shadow() & IRDA_MODE) 
+        return sprintf(buf, "1\n");
+    else 
+        return sprintf(buf, "0\n");
+}
+
+static ssize_t get_ENABLE_5V (struct class_device *class_dev, char *buf) {
+    if (get_cs3_shadow() & ENABLE_5V) 
+        return sprintf(buf, "1\n");
+    else 
+        return sprintf(buf, "0\n");
+} 
+
+static ssize_t get_RESET_SIMCARD (struct class_device *class_dev, char *buf) {
+    if (get_cs3_shadow() & RESET_SIMCARD) 
+        return sprintf(buf, "1\n");
+    else 
+        return sprintf(buf, "0\n");
+}
+
+
+static ssize_t write_DISPLAY_ON (struct class_device *cdev, const char * buf, size_t count){
+    char val;
+        if (sscanf(buf, "%c",&val) !=1)
+            return -EINVAL;
+        if (val=='1')
+            set_cs3_bit(DISPLAY_ON);
+        else if (val=='0')
+            clear_cs3_bit(DISPLAY_ON);
+        return strlen(buf);
+}
+
+static ssize_t write_DECT_POWER_ON (struct class_device *cdev, const char * buf, size_t count){
+    char val;
+        if (sscanf(buf, "%c",&val) !=1)
+            return -EINVAL;
+        if (val=='1')
+            set_cs3_bit(DECT_POWER_ON);
+        else if (val=='0')
+            clear_cs3_bit(DECT_POWER_ON);
+        return strlen(buf);
+}
+
+static ssize_t write_IRDA_SD (struct class_device *cdev, const char * buf, size_t count){
+    char val;
+        if (sscanf(buf, "%c",&val) !=1)
+            return -EINVAL;
+        if (val=='1')
+            set_cs3_bit(IRDA_SD);
+        else if (val=='0')
+            clear_cs3_bit(IRDA_SD);
+        return strlen(buf);
+}
+
+static ssize_t write_SD_MEDIAQ (struct class_device *cdev, const char * buf, size_t count){
+    char val;
+        if (sscanf(buf, "%c",&val) !=1)
+            return -EINVAL;
+        if (val=='1')
+            set_cs3_bit(SD_MEDIAQ);
+        else if (val=='0')
+            clear_cs3_bit(SD_MEDIAQ);
+        return strlen(buf);
+}
+
+static ssize_t write_LED2_ON (struct class_device *cdev, const char * buf, size_t count){
+    char val;
+        if (sscanf(buf, "%c",&val) !=1)
+            return -EINVAL;
+        if (val=='1')
+            set_cs3_bit(LED2_ON);
+        else if (val=='0')
+            clear_cs3_bit(LED2_ON);
+        return strlen(buf);
+}
+
+static ssize_t write_IRDA_MODE (struct class_device *cdev, const char * buf, size_t count){
+    char val;
+        if (sscanf(buf, "%c",&val) !=1)
+            return -EINVAL;
+        if (val=='1')
+            set_cs3_bit(IRDA_MODE);
+        else if (val=='0')
+            clear_cs3_bit(IRDA_MODE);
+        return strlen(buf);
+}
+
+static ssize_t write_RESET_SIMCARD (struct class_device *cdev, const char * buf, size_t count){
+    char val;
+        if (sscanf(buf, "%c",&val) !=1)
+            return -EINVAL;
+        if (val=='1')
+            set_cs3_bit(RESET_SIMCARD);
+        else if (val=='0')
+            clear_cs3_bit(RESET_SIMCARD);
+        return strlen(buf);
+}
+
+static CLASS_DEVICE_ATTR(vcc_5v_en, 0444, get_VCC_5V_EN, NULL);
+static CLASS_DEVICE_ATTR(vcc_3v_en, 0444, get_VCC_3V_EN, NULL);
+static CLASS_DEVICE_ATTR(en1, 0444, get_EN1, NULL);
+static CLASS_DEVICE_ATTR(en0, 0444, get_EN0, NULL);
+static CLASS_DEVICE_ATTR(display_on, 0664, get_DISPLAY_ON, write_DISPLAY_ON);
+static CLASS_DEVICE_ATTR(pcmcia_buff_dis, 0444, get_PCMCIA_BUFF_DIS, NULL);
+static CLASS_DEVICE_ATTR(mq_reset, 0444, get_MQ_RESET, NULL);
+static CLASS_DEVICE_ATTR(pcmcia_reset, 0444, get_PCMCIA_RESET, NULL);
+static CLASS_DEVICE_ATTR(dect_power_on, 0664, get_DECT_POWER_ON, write_DECT_POWER_ON);
+static CLASS_DEVICE_ATTR(irda_sd, 0664, get_IRDA_SD, write_IRDA_SD);
+static CLASS_DEVICE_ATTR(rs232_on, 0444, get_RS232_ON, NULL);
+static CLASS_DEVICE_ATTR(sd_mediaq, 0664, get_SD_MEDIAQ, write_SD_MEDIAQ);
+static CLASS_DEVICE_ATTR(led2_on, 0664, get_LED2_ON, write_LED2_ON);
+static CLASS_DEVICE_ATTR(irda_mode, 0664, get_IRDA_MODE, write_IRDA_MODE);
+static CLASS_DEVICE_ATTR(enable_5v, 0444, get_ENABLE_5V, NULL);
+static CLASS_DEVICE_ATTR(reset_simcard, 0664, get_RESET_SIMCARD, write_RESET_SIMCARD);
+
+static struct class simpad_gpios_class = {
+        .name = "simpad"
+};
+
+#define create_entry_conditional(name) \
+	rc = class_device_create_file(&cs3->class_dev, &class_device_attr_##name); \
+	if (rc) goto out; \
+
+static int register_cs3_latch(struct cs3 *cs3){
+    int rc = 0;
+	cs3->class_dev.class = &simpad_gpios_class;
+	strcpy(cs3->class_dev.class_id, cs3->name);
+	rc = class_device_register(&cs3->class_dev);
+	if(rc)
+		goto out;
+
+	create_entry_conditional(vcc_5v_en);
+    create_entry_conditional(vcc_3v_en);
+    create_entry_conditional(en1);
+    create_entry_conditional(en0);
+    create_entry_conditional(display_on);
+    create_entry_conditional(pcmcia_buff_dis);
+    create_entry_conditional(mq_reset);
+    create_entry_conditional(pcmcia_reset);
+    create_entry_conditional(dect_power_on);
+    create_entry_conditional(irda_sd);
+    create_entry_conditional(rs232_on);
+    create_entry_conditional(sd_mediaq);
+    create_entry_conditional(led2_on);
+    create_entry_conditional(irda_mode);
+    create_entry_conditional(enable_5v);
+    create_entry_conditional(reset_simcard);
+    
+out:
+    return rc;
+}
+
+static int __init simpad_gpios_class_init(void)
+{
+    if (class_register(&simpad_gpios_class) != 0)
+    printk(KERN_ERR "cs3 latch class failed "
+                    "to register properly\n");
+    register_cs3_latch(&cs3);
+	return 0;
+}
+
+static void __exit simpad_gpios_class_exit(void)
+{
+	class_unregister(&simpad_gpios_class);
+}
+
+module_init(simpad_gpios_class_init);
+module_exit(simpad_gpios_class_exit);
+                                                                                
+MODULE_DESCRIPTION("CS3_latch driver");
+MODULE_AUTHOR("Bernhard Guillon");
+MODULE_LICENSE("GPL");
