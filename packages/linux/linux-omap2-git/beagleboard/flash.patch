Received: from mail.service.utwente.nl ([130.89.5.253]) by exchange.service.utwente.nl with Microsoft SMTPSVC(6.0.3790.3959);
	 Mon, 4 Aug 2008 17:59:28 +0200
Received: from mx.utwente.nl ([130.89.2.12]) by mail.service.utwente.nl with Microsoft SMTPSVC(6.0.3790.3959);
	 Mon, 4 Aug 2008 17:59:27 +0200
Received: from vger.kernel.org (vger.kernel.org [209.132.176.167])
          by mx.utwente.nl (8.12.10/SuSE Linux 0.7) with ESMTP id m74FwiDg028981
          for <k.kooi@student.utwente.nl>; Mon, 4 Aug 2008 17:58:45 +0200
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754560AbYHDP6O (ORCPT <rfc822;k.kooi@student.utwente.nl>);
	Mon, 4 Aug 2008 11:58:14 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S1756033AbYHDP6N
	(ORCPT <rfc822;linux-omap-outgoing>); Mon, 4 Aug 2008 11:58:13 -0400
Received: from fg-out-1718.google.com ([72.14.220.154]:19323 "EHLO
	fg-out-1718.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1757716AbYHDP6L (ORCPT
	<rfc822;linux-omap@vger.kernel.org>); Mon, 4 Aug 2008 11:58:11 -0400
Received: by fg-out-1718.google.com with SMTP id 19so1022490fgg.17
        for <linux-omap@vger.kernel.org>; Mon, 04 Aug 2008 08:58:10 -0700 (PDT)
DKIM-Signature: 	v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=googlemail.com; s=gamma;
        h=domainkey-signature:received:received:message-id:date:from
         :user-agent:x-accept-language:mime-version:to:cc:subject
         :content-type;
        bh=9UH32BpZIt6pkxG3XXDaUMdlsAxT/6HeJgy/cl4UMoY=;
        b=f81vPPHp6KYejbQyr/s6gwGwGNYUr4art1U829ybVG5aVezJQUy8iuNQqgwPGNLhz+
         sCPYTp/d7RKpnui9FFxQcy5HOMggvJAgdxr49Y61RZMM+OJS2BugTaUUXWS3/RoEBR+h
         o/UXxMqR45NI684Nvvcx56Qc4NZQOIyiW3U1I=
DomainKey-Signature: a=rsa-sha1; c=nofws;
        d=googlemail.com; s=gamma;
        h=message-id:date:from:user-agent:x-accept-language:mime-version:to
         :cc:subject:content-type;
        b=lVauU4WHsnkoGN1/uhQ8jzixuaX2VXizHsSNc8Tq8RZPvOw+yZfIGd1ix6QWVBjttR
         9TgcojtGA0jx2hYbplibTmFPnoDcKym2qyF5DrX+G0ZLD/nVA+K9bd16sHErFeNz5eId
         tx0WvpQ2hkVKKG4NgJqINAGB3iNcP80PlM/vk=
Received: by 10.86.70.11 with SMTP id s11mr3676282fga.15.1217865490017;
        Mon, 04 Aug 2008 08:58:10 -0700 (PDT)
Received: from ?192.168.178.25? ( [195.4.48.71])
        by mx.google.com with ESMTPS id d4sm55517fga.8.2008.08.04.08.58.08
        (version=TLSv1/SSLv3 cipher=RC4-MD5);
        Mon, 04 Aug 2008 08:58:09 -0700 (PDT)
Message-ID: <4897270F.7000205@googlemail.com>
Date: 	Mon, 04 Aug 2008 17:58:07 +0200
From: Dirk Behme <dirk.behme@googlemail.com>
User-Agent: Mozilla Thunderbird 1.0.7 (X11/20050923)
X-Accept-Language: en-us, en
MIME-Version: 1.0
To: "linux-omap@vger.kernel.org" <linux-omap@vger.kernel.org>
CC: Steve Sakoman <sakoman@gmail.com>
Subject: [PATCH 1/3 v2] mtd omap2 nand driver: extend to work with omap3 boards
Content-Type: multipart/mixed;
 boundary="------------070804080507040009060104"
Sender: linux-omap-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-omap.vger.kernel.org>
X-Mailing-List: 	linux-omap@vger.kernel.org
X-UTwente-MailScanner-Information: Scanned by MailScanner. Contact servicedesk@icts.utwente.nl for more information.
X-UTwente-MailScanner: Found to be clean
X-UTwente-MailScanner-From: linux-omap-owner@vger.kernel.org
X-Spam-Status: No
Return-Path: linux-omap-owner@vger.kernel.org
X-OriginalArrivalTime: 04 Aug 2008 15:59:28.0133 (UTC) FILETIME=[12F8BB50:01C8F64B]

This is a multi-part message in MIME format.
--------------070804080507040009060104
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit

From: Teerth Reddy <teerth@ti.com>, Steve Sakoman <steve@sakoman.com>, 
Dirk Behme <dirk.behme@gmail.com>

Extend omap2 mtd nand driver to work with ARCH_OMAP3 boards

Signed-off-by: Steve Sakoman <steve@sakoman.com>
Signed-off-by: Dirk Behme <dirk.behme@gmail.com>


--------------070804080507040009060104
Content-Type: text/plain;
 name="1_nand.txt"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="1_nand.txt"

Index: linux-beagle/drivers/mtd/nand/Kconfig
===================================================================
--- linux-beagle.orig/drivers/mtd/nand/Kconfig
+++ linux-beagle/drivers/mtd/nand/Kconfig
@@ -70,10 +70,10 @@ config MTD_NAND_AMS_DELTA
 	  Support for NAND flash on Amstrad E3 (Delta).
 
 config MTD_NAND_OMAP2
-	tristate "NAND Flash device on OMAP 2420H4/2430SDP boards"
-	depends on (ARM && ARCH_OMAP2 && MTD_NAND)
+	tristate "NAND Flash device on OMAP2 and OMAP3"
+	depends on ARM && MTD_NAND && (ARCH_OMAP2 || ARCH_OMAP3)
 	help
-          Support for NAND flash on Texas Instruments 2430SDP/2420H4 platforms.
+          Support for NAND flash on Texas Instruments OMAP2 and OMAP3 platforms.
 
 config MTD_NAND_OMAP
 	tristate "NAND Flash device on OMAP H3/H2/P2 boards"
Index: linux-beagle/drivers/mtd/nand/omap2.c
===================================================================
--- linux-beagle.orig/drivers/mtd/nand/omap2.c
+++ linux-beagle/drivers/mtd/nand/omap2.c
@@ -111,15 +111,6 @@
 static const char *part_probes[] = { "cmdlinepart", NULL };
 #endif
 
-static int hw_ecc = 1;
-
-/* new oob placement block for use with hardware ecc generation */
-static struct nand_ecclayout omap_hw_eccoob = {
-	.eccbytes = 12,
-	.eccpos = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13},
-	.oobfree = {{16, 32}, {33, 63} },
-};
-
 struct omap_nand_info {
 	struct nand_hw_control		controller;
 	struct omap_nand_platform_data	*pdata;
@@ -133,6 +124,13 @@ struct omap_nand_info {
 	void __iomem			*gpmc_cs_baseaddr;
 	void __iomem			*gpmc_baseaddr;
 };
+
+/*
+ * omap_nand_wp - This function enable or disable the Write Protect feature on
+ * NAND device
+ * @mtd: MTD device structure
+ * @mode: WP ON/OFF
+ */
 static void omap_nand_wp(struct mtd_info *mtd, int mode)
 {
 	struct omap_nand_info *info = container_of(mtd,
@@ -189,11 +187,11 @@ static void omap_hwcontrol(struct mtd_in
 }
 
 /*
-* omap_read_buf - read data from NAND controller into buffer
-* @mtd: MTD device structure
-* @buf: buffer to store date
-* @len: number of bytes to read
-*/
+ * omap_read_buf - read data from NAND controller into buffer
+ * @mtd: MTD device structure
+ * @buf: buffer to store date
+ * @len: number of bytes to read
+ */
 static void omap_read_buf(struct mtd_info *mtd, u_char *buf, int len)
 {
 	struct omap_nand_info *info = container_of(mtd,
@@ -207,11 +205,11 @@ static void omap_read_buf(struct mtd_inf
 }
 
 /*
-* omap_write_buf - write buffer to NAND controller
-* @mtd: MTD device structure
-* @buf: data buffer
-* @len: number of bytes to write
-*/
+ * omap_write_buf - write buffer to NAND controller
+ * @mtd: MTD device structure
+ * @buf: data buffer
+ * @len: number of bytes to write
+ */
 static void omap_write_buf(struct mtd_info *mtd, const u_char * buf, int len)
 {
 	struct omap_nand_info *info = container_of(mtd,
@@ -250,10 +248,16 @@ static int omap_verify_buf(struct mtd_in
 	return 0;
 }
 
+#ifdef CONFIG_MTD_NAND_OMAP_HWECC
+/*
+ * omap_hwecc_init-Initialize the Hardware ECC for NAND flash in GPMC controller
+ * @mtd: MTD device structure
+ */
 static void omap_hwecc_init(struct mtd_info *mtd)
 {
 	struct omap_nand_info *info = container_of(mtd, struct omap_nand_info,
 							mtd);
+	register struct nand_chip *chip = mtd->priv;
 	unsigned long val = 0x0;
 
 	/* Read from ECC Control Register */
@@ -264,16 +268,15 @@ static void omap_hwecc_init(struct mtd_i
 
 	/* Read from ECC Size Config Register */
 	val = __raw_readl(info->gpmc_baseaddr + GPMC_ECC_SIZE_CONFIG);
-	/* ECCSIZE1=512 | ECCSIZE0=8bytes | Select eccResultsize[0123] */
-	val = ((0x000000FF<<22) | (0x00000003<<12) | (0x0000000F));
+	/* ECCSIZE1=512 | Select eccResultsize[0-3] */
+	val = ((((chip->ecc.size >> 1) - 1) << 22) | (0x0000000F));
 	__raw_writel(val, info->gpmc_baseaddr + GPMC_ECC_SIZE_CONFIG);
-
-
 }
 
 /*
- * This function will generate true ECC value, which can be used
+ * gen_true_ecc - This function will generate true ECC value, which can be used
  * when correcting data read from NAND flash memory core
+ * @ecc_buf: buffer to store ecc code
  */
 static void gen_true_ecc(u8 *ecc_buf)
 {
@@ -289,8 +292,12 @@ static void gen_true_ecc(u8 *ecc_buf)
 }
 
 /*
- * This function compares two ECC's and indicates if there is an error.
- * If the error can be corrected it will be corrected to the buffer
+ * omap_compare_ecc - This function compares two ECC's and indicates if there
+ * is an error. If the error can be corrected it will be corrected to the
+ * buffer
+ * @ecc_data1:  ecc code from nand spare area
+ * @ecc_data2:  ecc code from hardware register obtained from hardware ecc
+ * @page_data:  page data
  */
 static int omap_compare_ecc(u8 *ecc_data1,	/* read from NAND memory */
 			    u8 *ecc_data2,	/* read from register */
@@ -409,6 +416,14 @@ static int omap_compare_ecc(u8 *ecc_data
 	}
 }
 
+/*
+ * omap_correct_data - Compares the ecc read from nand spare area with ECC
+ * registers values and corrects one bit error if it has occured
+ * @mtd: MTD device structure
+ * @dat: page data
+ * @read_ecc: ecc read from nand flash
+ * @calc_ecc: ecc read from ECC registers
+ */
 static int omap_correct_data(struct mtd_info *mtd, u_char * dat,
 				u_char * read_ecc, u_char * calc_ecc)
 {
@@ -436,65 +451,64 @@ static int omap_correct_data(struct mtd_
 }
 
 /*
-** Generate non-inverted ECC bytes.
-**
-** Using noninverted ECC can be considered ugly since writing a blank
-** page ie. padding will clear the ECC bytes. This is no problem as long
-** nobody is trying to write data on the seemingly unused page.
-**
-** Reading an erased page will produce an ECC mismatch between
-** generated and read ECC bytes that has to be dealt with separately.
-*/
+ * omap_calcuate_ecc - Generate non-inverted ECC bytes.
+ * Using noninverted ECC can be considered ugly since writing a blank
+ * page ie. padding will clear the ECC bytes. This is no problem as long
+ * nobody is trying to write data on the seemingly unused page. Reading
+ * an erased page will produce an ECC mismatch between generated and read
+ * ECC bytes that has to be dealt with separately.
+ * @mtd: MTD device structure
+ * @dat: The pointer to data on which ecc is computed
+ * @ecc_code: The ecc_code buffer
+ */
 static int omap_calculate_ecc(struct mtd_info *mtd, const u_char *dat,
 				u_char *ecc_code)
 {
 	struct omap_nand_info *info = container_of(mtd, struct omap_nand_info,
 							mtd);
 	unsigned long val = 0x0;
-	unsigned long reg, n;
-
-	/* Ex NAND_ECC_HW12_2048 */
-	if ((info->nand.ecc.mode == NAND_ECC_HW) &&
-		(info->nand.ecc.size  == 2048))
-		n = 4;
-	else
-		n = 1;
+	unsigned long reg;
 
 	/* Start Reading from HW ECC1_Result = 0x200 */
 	reg = (unsigned long)(info->gpmc_baseaddr + GPMC_ECC1_RESULT);
-	while (n--) {
-		val = __raw_readl(reg);
-		*ecc_code++ = val;		/* P128e, ..., P1e */
-		*ecc_code++ = val >> 16;	/* P128o, ..., P1o */
-		/* P2048o, P1024o, P512o, P256o, P2048e, P1024e, P512e, P256e */
-		*ecc_code++ = ((val >> 8) & 0x0f) | ((val >> 20) & 0xf0);
-		reg += 4;
-	}
+	val = __raw_readl(reg);
+	*ecc_code++ = val;          /* P128e, ..., P1e */
+	*ecc_code++ = val >> 16;    /* P128o, ..., P1o */
+	/* P2048o, P1024o, P512o, P256o, P2048e, P1024e, P512e, P256e */
+	*ecc_code++ = ((val >> 8) & 0x0f) | ((val >> 20) & 0xf0);
+	reg += 4;
 
 	return 0;
-} /* omap_calculate_ecc */
+}
 
+/*
+ * omap_enable_hwecc - This function enables the hardware ecc functionality
+ * @mtd: MTD device structure
+ * @mode: Read/Write mode
+ */
 static void omap_enable_hwecc(struct mtd_info *mtd, int mode)
 {
 	struct omap_nand_info *info = container_of(mtd, struct omap_nand_info,
 							mtd);
+	register struct nand_chip *chip = mtd->priv;
+	unsigned int dev_width = (chip->options & NAND_BUSWIDTH_16) ? 1 : 0;
 	unsigned long val = __raw_readl(info->gpmc_baseaddr + GPMC_ECC_CONFIG);
 
 	switch (mode) {
 	case NAND_ECC_READ    :
 		__raw_writel(0x101, info->gpmc_baseaddr + GPMC_ECC_CONTROL);
-		/* ECC 16 bit col) | ( CS 0 )  | ECC Enable */
-		val = (1 << 7) | (0x0) | (0x1) ;
+		/* (ECC 16 or 8 bit col) | ( CS  )  | ECC Enable */
+		val = (dev_width << 7) | (info->gpmc_cs << 1) | (0x1);
 		break;
 	case NAND_ECC_READSYN :
-		__raw_writel(0x100, info->gpmc_baseaddr + GPMC_ECC_CONTROL);
-		/* ECC 16 bit col) | ( CS 0 )  | ECC Enable */
-		val = (1 << 7) | (0x0) | (0x1) ;
+		 __raw_writel(0x100, info->gpmc_baseaddr + GPMC_ECC_CONTROL);
+		/* (ECC 16 or 8 bit col) | ( CS  )  | ECC Enable */
+		val = (dev_width << 7) | (info->gpmc_cs << 1) | (0x1);
 		break;
 	case NAND_ECC_WRITE   :
 		__raw_writel(0x101, info->gpmc_baseaddr + GPMC_ECC_CONTROL);
-		/* ECC 16 bit col) | ( CS 0 )  | ECC Enable */
-		val = (1 << 7) | (0x0) | (0x1) ;
+		/* (ECC 16 or 8 bit col) | ( CS  )  | ECC Enable */
+		val = (dev_width << 7) | (info->gpmc_cs << 1) | (0x1);
 		break;
 	default:
 		DEBUG(MTD_DEBUG_LEVEL0, "Error: Unrecognized Mode[%d]!\n",
@@ -504,7 +518,38 @@ static void omap_enable_hwecc(struct mtd
 
 	__raw_writel(val, info->gpmc_baseaddr + GPMC_ECC_CONFIG);
 }
+#endif
+
+/*
+ * omap_wait - Wait function is called during Program and erase
+ * operations and the way it is called from MTD layer, we should wait
+ * till the NAND chip is ready after the programming/erase operation
+ * has completed.
+ * @mtd: MTD device structure
+ * @chip: NAND Chip structure
+ */
+static int omap_wait(struct mtd_info *mtd, struct nand_chip *chip)
+{
+	register struct nand_chip *this = mtd->priv;
+	struct omap_nand_info *info = container_of(mtd, struct omap_nand_info,
+							mtd);
+	int status = 0;
+
+	this->IO_ADDR_W = (void *) info->gpmc_cs_baseaddr +
+						GPMC_CS_NAND_COMMAND;
+	this->IO_ADDR_R = (void *) info->gpmc_cs_baseaddr + GPMC_CS_NAND_DATA;
+
+	while (!(status & 0x40)) {
+		 __raw_writeb(NAND_CMD_STATUS & 0xFF, this->IO_ADDR_W);
+		status = __raw_readb(this->IO_ADDR_R);
+	}
+	return status;
+}
 
+/*
+ * omap_dev_ready - calls the platform specific dev_ready function
+ * @mtd: MTD device structure
+ */
 static int omap_dev_ready(struct mtd_info *mtd)
 {
 	struct omap_nand_info *info = container_of(mtd, struct omap_nand_info,
@@ -534,7 +579,7 @@ static int __devinit omap_nand_probe(str
 	struct omap_nand_info		*info;
 	struct omap_nand_platform_data	*pdata;
 	int				err;
-	unsigned long val;
+	unsigned long 			val;
 
 
 	pdata = pdev->dev.platform_data;
@@ -568,15 +613,20 @@ static int __devinit omap_nand_probe(str
 	}
 
 	/* Enable RD PIN Monitoring Reg */
-	val  = gpmc_cs_read_reg(info->gpmc_cs, GPMC_CS_CONFIG1);
-	val |= WR_RD_PIN_MONITORING;
-	gpmc_cs_write_reg(info->gpmc_cs, GPMC_CS_CONFIG1, val);
+	if (pdata->dev_ready) {
+		val  = gpmc_cs_read_reg(info->gpmc_cs, GPMC_CS_CONFIG1);
+		val |= WR_RD_PIN_MONITORING;
+		gpmc_cs_write_reg(info->gpmc_cs, GPMC_CS_CONFIG1, val);
+	}
 
 	val  = gpmc_cs_read_reg(info->gpmc_cs, GPMC_CS_CONFIG7);
 	val &= ~(0xf << 8);
 	val |=  (0xc & 0xf) << 8;
 	gpmc_cs_write_reg(info->gpmc_cs, GPMC_CS_CONFIG7, val);
 
+	/* NAND write protect off */
+	omap_nand_wp(&info->mtd, NAND_WP_OFF);
+
 	if (!request_mem_region(info->phys_base, NAND_IO_SIZE,
 				pdev->dev.driver->name)) {
 		err = -EBUSY;
@@ -597,29 +647,39 @@ static int __devinit omap_nand_probe(str
 	info->nand.write_buf  = omap_write_buf;
 	info->nand.verify_buf = omap_verify_buf;
 
-	info->nand.dev_ready  = omap_dev_ready;
-	info->nand.chip_delay = 0;
-
-	/* Options */
-	info->nand.options   = NAND_BUSWIDTH_16;
-	info->nand.options  |= NAND_SKIP_BBTSCAN;
-
-	if (hw_ecc) {
-		/* init HW ECC */
-		omap_hwecc_init(&info->mtd);
-
-		info->nand.ecc.calculate = omap_calculate_ecc;
-		info->nand.ecc.hwctl     = omap_enable_hwecc;
-		info->nand.ecc.correct   = omap_correct_data;
-		info->nand.ecc.mode      = NAND_ECC_HW;
-		info->nand.ecc.bytes     = 12;
-		info->nand.ecc.size      = 2048;
-		info->nand.ecc.layout    = &omap_hw_eccoob;
-
+	/*
+	* If RDY/BSY line is connected to OMAP then use the omap ready funcrtion
+	* and the generic nand_wait function which reads the status register
+	* after monitoring the RDY/BSY line.Otherwise use a standard chip delay
+	* which is slightly more than tR (AC Timing) of the NAND device and read
+	* status register until you get a failure or success
+	*/
+	if (pdata->dev_ready) {
+		info->nand.dev_ready = omap_dev_ready;
+		info->nand.chip_delay = 0;
 	} else {
-		info->nand.ecc.mode = NAND_ECC_SOFT;
+		info->nand.waitfunc = omap_wait;
+		info->nand.chip_delay = 50;
 	}
 
+	info->nand.options  |= NAND_SKIP_BBTSCAN;
+	if ((gpmc_cs_read_reg(info->gpmc_cs, GPMC_CS_CONFIG1) & 0x3000)
+								== 0x1000)
+		info->nand.options  |= NAND_BUSWIDTH_16;
+
+#ifdef CONFIG_MTD_NAND_OMAP_HWECC
+	info->nand.ecc.bytes		= 3;
+	info->nand.ecc.size		= 512;
+	info->nand.ecc.calculate	= omap_calculate_ecc;
+	info->nand.ecc.hwctl		= omap_enable_hwecc;
+	info->nand.ecc.correct		= omap_correct_data;
+	info->nand.ecc.mode		= NAND_ECC_HW;
+
+	/* init HW ECC */
+	omap_hwecc_init(&info->mtd);
+#else
+	info->nand.ecc.mode = NAND_ECC_SOFT;
+#endif
 
 	/* DIP switches on some boards change between 8 and 16 bit
 	 * bus widths for flash.  Try the other width if the first try fails.
@@ -642,8 +702,6 @@ static int __devinit omap_nand_probe(str
 #endif
 		add_mtd_device(&info->mtd);
 
-	omap_nand_wp(&info->mtd, NAND_WP_OFF);
-
 	platform_set_drvdata(pdev, &info->mtd);
 
 	return 0;

--------------070804080507040009060104--
--
To unsubscribe from this list: send the line "unsubscribe linux-omap" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
