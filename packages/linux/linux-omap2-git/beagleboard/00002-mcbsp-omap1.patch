From: Eduardo Valentin <eduardo.valentin@indt.org.br>

This patch adds support for mach-omap1 based on current
mcbsp platform driver.

Signed-off-by: Eduardo Valentin <eduardo.valentin@indt.org.br>
---
 arch/arm/mach-omap1/Makefile |    2 +
 arch/arm/mach-omap1/mcbsp.c  |  165 ++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 167 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-omap1/mcbsp.c

diff --git a/arch/arm/mach-omap1/Makefile b/arch/arm/mach-omap1/Makefile
index 6ebf23b..09246a7 100644
--- a/arch/arm/mach-omap1/Makefile
+++ b/arch/arm/mach-omap1/Makefile
@@ -5,6 +5,8 @@
 # Common support
 obj-y := io.o id.o clock.o irq.o mux.o serial.o devices.o
 
+obj-$(CONFIG_OMAP_MCBSP) += mcbsp.o
+
 obj-$(CONFIG_OMAP_MPU_TIMER)	+= time.o
 obj-$(CONFIG_OMAP_32K_TIMER)	+= timer32k.o
 
diff --git a/arch/arm/mach-omap1/mcbsp.c b/arch/arm/mach-omap1/mcbsp.c
new file mode 100644
index 0000000..f30624a
--- /dev/null
+++ b/arch/arm/mach-omap1/mcbsp.c
@@ -0,0 +1,165 @@
+/*
+ * linux/arch/arm/mach-omap1/mcbsp.c
+ *
+ * Copyright (C) 2008 Instituto Nokia de Tecnologia
+ * Contact: Eduardo Valentin <eduardo.valentin@indt.org.br>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Multichannel mode not supported.
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/io.h>
+
+#include <asm/arch/dma.h>
+#include <asm/arch/mux.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/mcbsp.h>
+#include <asm/arch/dsp_common.h>
+
+#define DPS_RSTCT2_PER_EN	(1 << 0)
+#define DSP_RSTCT2_WD_PER_EN	(1 << 1)
+
+static int omap1_mcbsp_check(unsigned int id)
+{
+	/* REVISIT: Check correctly for number of registered McBSPs */
+	if (cpu_is_omap730()) {
+		if (id > OMAP_MAX_MCBSP_COUNT - 2) {
+		       printk(KERN_ERR "OMAP-McBSP: McBSP%d doesn't exist\n",
+				id + 1);
+		       return -ENODEV;
+		}
+		return 0;
+	}
+
+	if (cpu_is_omap15xx() || cpu_is_omap16xx()) {
+		if (id > OMAP_MAX_MCBSP_COUNT - 1) {
+			printk(KERN_ERR "OMAP-McBSP: McBSP%d doesn't exist\n",
+				id + 1);
+			return -ENODEV;
+		}
+		return 0;
+	}
+
+	return -ENODEV;
+}
+
+static void omap1_mcbsp_request(unsigned int id)
+{
+	/*
+	 * On 1510, 1610 and 1710, McBSP1 and McBSP3
+	 * are DSP public peripherals.
+	 */
+	if (id == OMAP_MCBSP1 || id == OMAP_MCBSP3) {
+		omap_dsp_request_mem();
+		/*
+		 * DSP external peripheral reset
+		 * FIXME: This should be moved to dsp code
+		 */
+		__raw_writew(__raw_readw(DSP_RSTCT2) | DPS_RSTCT2_PER_EN |
+				DSP_RSTCT2_WD_PER_EN, DSP_RSTCT2);
+	}
+}
+
+static void omap1_mcbsp_free(unsigned int id)
+{
+	if (id == OMAP_MCBSP1 || id == OMAP_MCBSP3)
+		omap_dsp_release_mem();
+}
+
+static struct omap_mcbsp_ops omap1_mcbsp_ops = {
+	.check		= omap1_mcbsp_check,
+	.request	= omap1_mcbsp_request,
+	.free		= omap1_mcbsp_free,
+};
+
+static struct omap_mcbsp_platform_data omap1_mcbsp_pdata[] = {
+#ifdef CONFIG_ARCH_OMAP730
+	{
+		.virt_base	= io_p2v(OMAP730_MCBSP1_BASE),
+		.dma_rx_sync	= OMAP_DMA_MCBSP1_RX,
+		.dma_tx_sync	= OMAP_DMA_MCBSP1_TX,
+		.rx_irq		= INT_730_McBSP1RX,
+		.tx_irq		= INT_730_McBSP1TX,
+		.ops		= &omap1_mcbsp_ops,
+	},
+	{
+		.virt_base	= io_p2v(OMAP730_MCBSP2_BASE),
+		.dma_rx_sync	= OMAP_DMA_MCBSP3_RX,
+		.dma_tx_sync	= OMAP_DMA_MCBSP3_TX,
+		.rx_irq		= INT_730_McBSP2RX,
+		.tx_irq		= INT_730_McBSP2TX
+		.ops		= &omap1_mcbsp_ops,
+	},
+#endif
+#ifdef CONFIG_ARCH_OMAP15XX
+	{
+		.virt_base	= OMAP1510_MCBSP1_BASE,
+		.dma_rx_sync	= OMAP_DMA_MCBSP1_RX,
+		.dma_tx_sync	= OMAP_DMA_MCBSP1_TX,
+		.rx_irq		= INT_McBSP1RX,
+		.tx_irq		= INT_McBSP1TX,
+		.ops		= &omap1_mcbsp_ops,
+		.clocks		= { "dsp_ck", "api_ck", "dspxor_ck" },
+		},
+	{
+		.virt_base	= io_p2v(OMAP1510_MCBSP2_BASE),
+		.dma_rx_sync	= OMAP_DMA_MCBSP2_RX,
+		.dma_tx_sync	= OMAP_DMA_MCBSP2_TX,
+		.rx_irq		= INT_1510_SPI_RX,
+		.tx_irq		= INT_1510_SPI_TX,
+		.ops		= &omap1_mcbsp_ops,
+	},
+	{
+		.virt_base	= OMAP1510_MCBSP3_BASE,
+		.dma_rx_sync	= OMAP_DMA_MCBSP3_RX,
+		.dma_tx_sync	= OMAP_DMA_MCBSP3_TX,
+		.rx_irq		= INT_McBSP3RX,
+		.tx_irq		= INT_McBSP3TX,
+		.ops		= &omap1_mcbsp_ops,
+		.clocks		= { "dsp_ck", "api_ck", "dspxor_ck" },
+	},
+#endif
+#ifdef CONFIG_ARCH_OMAP16XX
+	{
+		.virt_base	= OMAP1610_MCBSP1_BASE,
+		.dma_rx_sync	= OMAP_DMA_MCBSP1_RX,
+		.dma_tx_sync	= OMAP_DMA_MCBSP1_TX,
+		.rx_irq		= INT_McBSP1RX,
+		.tx_irq		= INT_McBSP1TX,
+		.ops		= &omap1_mcbsp_ops,
+		.clocks		= { "dsp_ck", "api_ck", "dspxor_ck" },
+	},
+	{
+		.virt_base	= io_p2v(OMAP1610_MCBSP2_BASE),
+		.dma_rx_sync	= OMAP_DMA_MCBSP2_RX,
+		.dma_tx_sync	= OMAP_DMA_MCBSP2_TX,
+		.rx_irq		= INT_1610_McBSP2_RX,
+		.tx_irq		= INT_1610_McBSP2_TX,
+		.ops		= &omap1_mcbsp_ops,
+	},
+	{
+		.virt_base	= OMAP1610_MCBSP3_BASE,
+		.dma_rx_sync	= OMAP_DMA_MCBSP3_RX,
+		.dma_tx_sync	= OMAP_DMA_MCBSP3_TX,
+		.rx_irq		= INT_McBSP3RX,
+		.tx_irq		= INT_McBSP3TX,
+		.ops		= &omap1_mcbsp_ops,
+		.clocks		= { "dsp_ck", "api_ck", "dspxor_ck" },
+	},
+#endif
+};
+#define mcbsp_count		ARRAY_SIZE(omap1_mcbsp_pdata)
+
+int __init omap1_mcbsp_init(void)
+{
+	omap_mcbsp_register_board_cfg(omap1_mcbsp_pdata, mcbsp_count);
+
+	return omap_mcbsp_init();
+}
+arch_initcall(omap1_mcbsp_init);
-- 
1.5.5.1.67.gbdb8.dirty

--
To unsubscribe from this list: send the line "unsubscribe linux-omap" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

