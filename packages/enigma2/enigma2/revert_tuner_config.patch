diff -u -r1.144 -r1.140
--- lib/python/Components/NimManager.py	2 Jul 2008 11:12:11 -0000	1.144
+++ lib/python/Components/NimManager.py	5 Jun 2008 09:19:01 -0000	1.140
@@ -121,13 +121,13 @@
 				# save what nim we link to/are equal to/satposdepends to.
 				# this is stored in the *value* (not index!) of the config list
 				if nim.configMode.value == "equal":
-					self.equal[int(nim.connectedTo.value)]=x
+					self.equal[int(nim.equalTo.value)]=x
 				elif nim.configMode.value == "loopthrough":
-					self.linkNIMs(sec, x, int(nim.connectedTo.value))
-					self.linked[int(nim.connectedTo.value)]=x
+					self.linkNIMs(sec, x, int(nim.linkedTo.value))
+					self.linked[int(nim.linkedTo.value)]=x
 				elif nim.configMode.value == "satposdepends":
-					self.setSatposDepends(sec, x, int(nim.connectedTo.value))
-					self.satposdepends[int(nim.connectedTo.value)]=x
+					self.setSatposDepends(sec, x, int(nim.satposDependsTo.value))
+					self.satposdepends[int(nim.satposDependsTo.value)]=x
 
 		for slot in nim_slots:
 			x = slot.slot
@@ -357,7 +357,7 @@
 		self.update()
 
 class NIM(object):
-	def __init__(self, slot, type, description, has_outputs = True, internally_connectable = None):
+	def __init__(self, slot, type, description):
 		self.slot = slot
 
 		if type not in ["DVB-S", "DVB-C", "DVB-T", "DVB-S2", None]:
@@ -366,8 +366,6 @@
 
 		self.type = type
 		self.description = description
-		self.has_outputs = has_outputs
-		self.internally_connectable = internally_connectable
 
 	def isCompatible(self, what):
 		compatible = {
@@ -378,15 +376,6 @@
 				"DVB-S2": ["DVB-S", "DVB-S2", None]
 			}
 		return what in compatible[self.type]
-	
-	def connectableTo(self):
-		connectable = {
-				"DVB-S": ["DVB-S", "DVB-S2"],
-				"DVB-C": ["DVB-C"],
-				"DVB-T": ["DVB-T"],
-				"DVB-S2": ["DVB-S", "DVB-S2"]
-			}
-		return connectable[self.type]
 
 	def getSlotName(self):
 		# get a friendly description for a slot name.
@@ -398,12 +387,6 @@
 
 	def getSlotID(self):
 		return chr(ord('A') + self.slot)
-	
-	def hasOutputs(self):
-		return self.has_outputs
-	
-	def internallyConnectableTo(self):
-		return self.internally_connectable
 
 	slot_id = property(getSlotID)
 
@@ -536,12 +519,6 @@
 				entries[current_slot]["type"] = str(line.strip()[6:])
 			elif line.strip().startswith("Name:"):
 				entries[current_slot]["name"] = str(line.strip()[6:])
-			elif line.strip().startswith("Has_Outputs:"):
-				input = str(line.strip()[len("Has_Outputs:") + 1:])
-				entries[current_slot]["has_outputs"] = (input == "yes")
-			elif line.strip().startswith("Internally_Connectable:"):
-				input = int(line.strip()[len("Internally_Connectable:") + 1:])
-				entries[current_slot]["internally_connectable"] = input 
 			elif line.strip().startswith("empty"):
 				entries[current_slot]["type"] = None
 				entries[current_slot]["name"] = _("N/A")
@@ -551,23 +528,13 @@
 			if not (entry.has_key("name") and entry.has_key("type")):
 				entry["name"] =  _("N/A")
 				entry["type"] = None
-			if not (entry.has_key("has_outputs")):
-				entry["has_outputs"] = True
-			if not (entry.has_key("internally_connectable")):
-				entry["internally_connectable"] = None
-			self.nim_slots.append(NIM(slot = id, description = entry["name"], type = entry["type"], has_outputs = entry["has_outputs"], internally_connectable = entry["internally_connectable"]))
+			self.nim_slots.append(NIM(slot = id, description = entry["name"], type = entry["type"]))
 
 	def hasNimType(self, chktype):
 		for slot in self.nim_slots:
 			if slot.isCompatible(chktype):
 				return True
 		return False
-	
-	def getNimType(self, slotid):
-		return self.nim_slots[slotid].type
-	
-	def getNimDescription(self, slotid):
-		return self.nim_slots[slotid].friendly_full_description
 
 	def getNimListOfType(self, type, exception = -1):
 		# returns a list of indexes for NIMs compatible to the given type, except for 'exception'
@@ -591,59 +558,6 @@
 		for slot in self.nim_slots:
 			list.append(slot.friendly_full_description)
 		return list
-	
-	def getSlotCount(self):
-		return len(self.nim_slots)
-	
-	def hasOutputs(self, slotid):
-		return self.nim_slots[slotid].hasOutputs()
-	
-	def canConnectTo(self, slotid):
-		slots = []
-		if self.nim_slots[slotid].internallyConnectableTo() is not None:
-			slots.append(self.nim_slots[slotid].internallyConnectableTo())
-		for type in self.nim_slots[slotid].connectableTo(): 
-			for slot in self.getNimListOfType(type, exception = slotid):
-				# FIXME we restrict loopthrough from dvb-s2 to dvb-s, because the c++ part can't handle it
-				if not (type == "DVB-S" and self.getNimType(slot)):
-					if self.hasOutputs(slot):
-						slots.append(slot)
-		slots.sort()
-		
-		return slots
-	
-	def canEqualTo(self, slotid):
-		type = self.getNimType(slotid)
-		if self.getNimConfig(slotid) == "DVB-S2":
-			type = "DVB-S"
-		nimList = self.getNimListOfType(type, slotid)
-		for nim in nimList[:]:
-			mode = self.getNimConfig(nim)
-			if mode.configMode.value == "loopthrough" or mode.configMode.value == "satposdepends":
-				nimList.remove(nim)
-		return nimList
-	
-	def canDependOn(self, slotid):
-		type = self.getNimType(slotid)
-		if self.getNimConfig(slotid) == "DVB-S2":
-			type = "DVB-S"
-		nimList = self.getNimListOfType(type, slotid)
-		positionerList = []
-		for nim in nimList[:]:
-			mode = self.getNimConfig(nim)
-			if mode.configMode.value == "simple" and mode.diseqcMode.value == "positioner":
-				alreadyConnected = False
-				for testnim in nimList:
-					testmode = self.getNimConfig(testnim)
-					if testmode.configMode.value == "satposdepends" and int(testmode.connectedTo.value) == int(nim):
-						alreadyConnected = True
-						break
-				if not alreadyConnected:
-					positionerList.append(nim)
-		return positionerList
-	
-	def getNimConfig(self, slotid):
-		return config.Nims[slotid]
 
 	def getSatList(self):
 		return self.satList
@@ -778,16 +692,27 @@
 		x = slot.slot
 		nim = config.Nims[x]
 		
+		# HACK: currently, we can only looptrough to socket A
+
 		if slot.isCompatible("DVB-S"):
-			choices = { "nothing": _("nothing connected"),
-					"simple": _("simple"),
-					"advanced": _("advanced")}
-			if len(nimmgr.getNimListOfType(slot.type, exception = x)) > 0:
-				choices["equal"] = _("equal to")
-				choices["satposdepends"] = _("second cable of motorized LNB")
-			if len(nimmgr.canConnectTo(x)) > 0:
-				choices["loopthrough"] = _("loopthrough to")
-			nim.configMode = ConfigSelection(choices = choices, default = "simple")
+			if slot.slot == 0:
+				nim.configMode = ConfigSelection(
+					choices = {
+						"simple": _("simple"),
+						"advanced": _("advanced"),
+						"nothing": _("nothing connected"),
+						},
+					default = "simple")
+			else:
+				nim.configMode = ConfigSelection(
+					choices = {
+						"equal": _("equal to Socket A"),
+						"loopthrough": _("loopthrough to socket A"),
+						"nothing": _("nothing connected"),
+						"satposdepends": _("second cable of motorized LNB"),
+						"simple": _("simple"),
+						"advanced": _("advanced")},
+					default = "loopthrough")
 
 			#important - check if just the 2nd one is LT only and the first one is DVB-S
 			# CHECKME: is this logic correct for >2 slots?
@@ -814,11 +739,6 @@
 					("positioner", _("Positioner"))],
 				default = "diseqc_a_b")
 
-			choices = []
-			for id in nimmgr.getNimListOfType("DVB-S"):
-				if id != x:
-					choices.append((str(id), str(chr(65 + id))))
-			nim.connectedTo = ConfigSelection(choices = choices)
 			nim.diseqcA = getConfigSatlist(192, nimmgr.satList)
 			nim.diseqcB = getConfigSatlist(130, nimmgr.satList)
 			nim.diseqcC = ConfigSatlist(list = nimmgr.satList)
@@ -839,6 +759,19 @@
 			nim.fastTurningBegin = ConfigDateTime(default = mktime(btime.timetuple()), formatstring = _("%H:%M"), increment = 900)
 			etime = datetime(1970, 1, 1, 19, 0);
 			nim.fastTurningEnd = ConfigDateTime(default = mktime(etime.timetuple()), formatstring = _("%H:%M"), increment = 900)
+			# get other frontends of the same type
+
+			satNimList = nimmgr.getNimListOfType("DVB-S", slot.slot)
+			satNimListNames = {}
+
+			for x in satNimList:
+				n = nimmgr.nim_slots[x]
+				satNimListNames["%d" % n.slot] = n.friendly_full_description
+
+			if len(satNimListNames):
+				nim.equalTo = ConfigSelection(choices = satNimListNames)
+				nim.linkedTo = ConfigSelection(choices = satNimListNames)
+				nim.satposDependsTo = ConfigSelection(choices = satNimListNames)
 
 			# advanced config:
 			nim.advanced = ConfigSubsection()
diff -u -r1.72 -r1.66
--- lib/python/Screens/Satconfig.py	11 Jul 2008 12:23:16 -0000	1.72
+++ lib/python/Screens/Satconfig.py	5 Jun 2008 09:19:02 -0000	1.66
@@ -5,7 +5,7 @@
 from Components.ConfigList import ConfigListScreen
 from Components.MenuList import MenuList
 from Components.NimManager import nimmanager
-from Components.config import getConfigListEntry, config, ConfigNothing, ConfigSelection, updateConfigElement
+from Components.config import getConfigListEntry, config, ConfigNothing
 from Screens.MessageBox import MessageBox
 
 from time import mktime, localtime
@@ -46,22 +46,7 @@
 			if nim.powerMeasurement.value:
 				nim.powerMeasurement.value = False
 				nim.powerMeasurement.save()
-		
-	def createConfigMode(self):
-		choices = { "nothing": _("nothing connected"),
-					"simple": _("simple"),
-					"advanced": _("advanced")}
-		#if len(nimmanager.getNimListOfType(nimmanager.getNimType(self.slotid), exception = x)) > 0:
-		#	choices["equal"] = _("equal to")
-		#	choices["satposdepends"] = _("second cable of motorized LNB")
-		if len(nimmanager.canEqualTo(self.slotid)) > 0:
-			choices["equal"] = _("equal to")
-		if len(nimmanager.canDependOn(self.slotid)) > 0:
-			choices["satposdepends"] = _("second cable of motorized LNB")
-		if len(nimmanager.canConnectTo(self.slotid)) > 0:
-			choices["loopthrough"] = _("loopthrough to")
-		self.nimConfig.configMode = updateConfigElement(self.nimConfig.configMode, ConfigSelection(choices = choices, default = "simple"))
-					
+
 	def createSetup(self):
 		print "Creating setup"
 		self.list = [ ]
@@ -92,31 +77,7 @@
 					self.createSimpleSetup(self.list, self.nimConfig.diseqcMode.value)
 				if self.nimConfig.diseqcMode.value == "positioner":
 					self.createPositionerSetup(self.list)
-			elif self.nimConfig.configMode.value == "equal":
-				choices = []
-				nimlist = nimmanager.canEqualTo(self.nim.slot)
-				for id in nimlist:
-					#choices.append((str(id), str(chr(65 + id))))
-					choices.append((str(id), nimmanager.getNimDescription(id)))
-				self.nimConfig.connectedTo = updateConfigElement(self.nimConfig.connectedTo, ConfigSelection(choices = choices))
-				self.list.append(getConfigListEntry(_("Tuner"), self.nimConfig.connectedTo))
-			elif self.nimConfig.configMode.value == "satposdepends":
-				choices = []
-				nimlist = nimmanager.canDependOn(self.nim.slot)
-				for id in nimlist:
-					#choices.append((str(id), str(chr(65 + id))))
-					choices.append((str(id), nimmanager.getNimDescription(id)))
-				self.nimConfig.connectedTo = updateConfigElement(self.nimConfig.connectedTo, ConfigSelection(choices = choices))
-				self.list.append(getConfigListEntry(_("Tuner"), self.nimConfig.connectedTo))
-			elif self.nimConfig.configMode.value == "loopthrough":
-				choices = []
-				print "connectable to:", nimmanager.canConnectTo(self.slotid)
-				connectable = nimmanager.canConnectTo(self.slotid) 
-				for id in connectable:
-					choices.append((str(id), nimmanager.getNimDescription(id)))
-				self.nimConfig.connectedTo = updateConfigElement(self.nimConfig.connectedTo, ConfigSelection(choices = choices))
-				self.list.append(getConfigListEntry(_("Connected to"), self.nimConfig.connectedTo))
-			elif self.nimConfig.configMode.value == "nothing":
+			elif self.nimConfig.configMode.value in ["loopthrough", "satposdepends", "nothing", "equal"]:
 				pass
 			elif self.nimConfig.configMode.value == "advanced": # advanced
 				# SATs
@@ -327,13 +288,9 @@
 			"cancel": self.keyCancel,
 		}, -2)
 
-		self.slotid = slotid
 		self.nim = nimmanager.nim_slots[slotid]
 		self.nimConfig = self.nim.config
-		self.createConfigMode()
 		self.createSetup()
-		# safeAll is needed, so that keyCancel works properly
-		self.saveAll()
 
 	def keyLeft(self):
 		ConfigListScreen.keyLeft(self)
