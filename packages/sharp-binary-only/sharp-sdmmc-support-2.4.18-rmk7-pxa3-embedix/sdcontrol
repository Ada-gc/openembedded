#!/bin/sh
#
# sdcontrol 1.0 2001/8/8 21:33:19 (Hideki Hayami)
#
# Initialize or shutdown a SD card device
#
# The first argument should be either 'insert' of 'eject'.
#

ACTION=$1
DEVICE=/dev/mmcda1
MOUNT_POINT=/mnt/card
SMB_MOUNT=/home/samba/SD_Card
INSTALL_DIR=Documents/Install_Files

# import FS mount options from fstab or use defaults
# if detection fails
SD_OPTS="`grep "/mnt/card" /etc/fstab | awk '{print $4}'`" 
if test -z "$SD_OPTS"
then
	SD_OPTS="noatime,sync"
	echo -e "\nWARNING: Couldn't determine SD mount options from /etc/fstab, using defaults\n"
fi

# The "quiet" option fails on non-VFAT cards. Nice trick ;)
SD_OPTS_VFAT="$SD_OPTS,quiet,umask=000,iocharset=utf8"


###### for QPE ######
get_pid()
{
    echo $1
}

wait_release()
{
    count=1
    while true
    do
        umount $MOUNT_POINT
        if [ $? = 0 ]; then
            #echo umount >> /tmp/sd
            return
        fi
        echo count=$count >> /tmp/sd
        if [ `expr $count \>= 500` = 1 ]; then
            #echo time out >> /tmp/sd
            return
        fi
        count=`expr $count + 1`
        usleep 200000
    done
}

kill_task()
{
    ps_line=`ps ax | grep 'qpe$'` # no -w on busybox
    qpe_pid=`get_pid $ps_line`
    #echo qpe_pid = $qpe_pid >> /tmp/sd
    target_pids=`fuser -m $DEVICE | cut -d : -f2`
    #echo $target_pids >> /tmp/sd
    if [ "$target_pids" = "" ]; then
        return
    fi
    is_exist_qpe=`echo $target_pids | grep $qpe_pid` # no -w on busybox
    if [ "$is_exist_qpe" = "" ]; then
	kill -9 $target_pids
        #echo kill -9 $target_pids >> /tmp/sd
    else
        #echo "found qpe!!!" >> /tmp/sd
	target_pids=`echo $target_pids | sed -e "s/$qpe_pid//"`
	if [ "$target_pids" != "" ]; then
            kill -9 $target_pids
            #echo kill -9 $target_pids >> /tmp/sd
        fi
        wait_release
        exit 0
    fi
}
###### for QPE ######


case "$ACTION" in
'insert')

	# Get available partitions through dmesg. The "tail -1" is needed as
	# sometimes the partitions are printed twice by the kernel.
	OK_PARTS="`dmesg | tail -3 | grep mmcda | tail -1| sed s/^.*\:\ //`"
	echo "Valid SD partitions are: [$OK_PARTS]"
	
	# Allow for "#" in fstab.
	fstab_txt="`cat /etc/fstab | grep -v ^#`"
	
	cnt=1
	for part in $OK_PARTS
	do
		# Read the mount-point for this partition from fstab 
		MOUNT_POINT="`echo "$fstab_txt" | grep "/dev/$part" | awk '{print $2}`"

		# Mount the first valid partition as /mnt/card if there was no entry in fstab
		if test -z "$MOUNT_POINT"
		then
			# See if /mnt/card is already mounted
			if ! mount|awk '{print $3}'|grep "^/mnt/card$"
			then
				# Check if another *existing* partition is configured as /mnt/card				
				if ! echo "$fstab_txt" | grep "/mnt/card" | awk '{print $2}'| grep "^/mnt/card$"
				then
					# As /mnt/card wasn't configured in fstab, we simply mount the
					# first unconfigured partition we find
					MOUNT_POINT="/mnt/card"
				else
					# Go through all partitions, and check if one of them is configured
					# as /mnt/card
					for xpart in $OK_PARTS
					do
						if echo "$fstab_txt" | grep "$xpart" | awk '{print $2}'| grep "^/mnt/card$"
						then
							echo found=1
						fi
					done
					
					if test "$found" = 1
					then	
						# Another existing partition is configured for /mnt/card, leave it alone.
						MOUNT_POINT="/mnt/card$cnt"
						let cnt=$cnt+1
					else
						MOUNT_POINT="/mnt/card"
					fi					
					
				fi
			else
				MOUNT_POINT="/mnt/card$cnt"
				let cnt=$cnt+1				
			fi
		fi

		! test -d $MOUNT_POINT && mkdir -p $MOUNT_POINT	
			
		DEVICE="/dev/$part"
		if ! test -e "$DEVICE"
		then
			DEV_NUM="`echo "$DEVICE" | sed -n "s/.*\([0-9]\)/\1/p"`"
			cd /dev			
			mknod mmcda$DEV_NUM b 60 $DEV_NUM
		fi
		
		echo "Mounting [/dev/$part]"
		echo "* Trying VFAT mount [$SD_OPTS_VFAT]..."
        	mount $FSTYPE -o $SD_OPTS_VFAT $DEVICE $MOUNT_POINT
		MOUNT_RES=`mount | grep $DEVICE`


		if [ "$MOUNT_RES" = "" ]; then
			echo "* Trying ext2 mount [$SD_OPTS]..."
	        	mount $FSTYPE -o $SD_OPTS $DEVICE $MOUNT_POINT
		fi

		MOUNT_RES=`mount | grep $DEVICE`
		if [ "$MOUNT_RES" = "" ]; then
			echo "* Trying failsafe mount..."
	        	mount $FSTYPE $DEVICE $MOUNT_POINT
		fi

		# Um what was the function of that?
#		chkmntsh ${MOUNT_POINT}

	done
	
	# I have no idea what this is good for....
	if [ -d $SMB_MOUNT ] ; then
		rm -rf $SMB_MOUNT
	fi
	ln -s /mnt/card $SMB_MOUNT
	mkdir -p $MOUNT_POINT/$INSTALL_DIR

        ;;
'eject')
	# Doesn't work as "fuser" isn't in a base OZ 3.5.[1|2] ROM
	for part in `mount | grep mmcda|awk '{print $1}'`
	do	
		DEVICE="$part"
        	fuser -s -m $DEVICE
        	if [ $? = 1 ]; then
                	umount $DEVICE
                	rm $SMB_MOUNT
		else
			exit 1
        	fi
	done
        ;;
'compeject')
	for part in `mount | grep mmcda|awk '{print $1}'`
	do
		DEVICE="$part"
	
	        kill_task       # for QPE
		
       		 #fuser -k -m $DEVICE > /dev/null
	        umount $DEVICE
        	if [ $? != 0 ]; then
                	usleep 500000
                	umount $DEVICE
        	fi
		rm $SMB_MOUNT
	done
        ;;
'change')
        $0 compeject
        $0 insert
        ;;
'*')
        exit 1
        ;;
esac

exit 0

